{
  "hash": "e14b06305fd92752cafd90b030e7c15d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Step-by-Step Development of a Molecular Dynamics Simulation\"\nauthor: \"Frank Cichos\"\nformat:\n  live-html:\n    toc: true\n    toc-location: right\npyodide:\n  autorun: true\n  packages:\n    - matplotlib\n    - numpy\n---\n\n\n\n## Implementations\n\n### The Atom Class\nWe define a class `Atom` that contains the properties of an atom. The class `Atom` has the following attributes:\n\n```python\nclass Atom:\n    dimension = 2\n\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.zeros(dimension)\n        self.mass = mass\n        self.force = np.zeros(dimension)\n```\n\nThe class `Atom` has the following attributes:\n\n- `id`: The unique identifier of the atom\n- `type`: The type of the atom (hydrogen or oxygen or ...)\n- `position`: The position of the atom in 3D space (x, y, z)\n- `velocity`: The velocity of the atom in 3D space (vx, vy, vz)\n- `mass`: The mass of the atom\n- `force`: The force acting on the atom in 3D space (fx, fy, fz)\n\nIn addition, we will need some information on the other atoms that are bound to the atom. We will store this information later in a list of atoms called `boundto`. Since we start with a monoatomic gas, we will not need this information for now.\nNote that position, velocity, and force are 3D vectors and we store them in numpy arrays. This is a very convenient way to handle vectors and matrices in Python.\n\nThe class `Atom` should further implement a number of functions, called methods in object-oriented programming, that allow us to interact with the atom. The following methods are implemented in the `Atom` class:\n\n\n#### `add_force(force)`: Adds a force acting on the atom\n\n```python\ndef add_force(self, force):\n    \"\"\"Add force contribution to total force on atom\"\"\"\n    self.force += force\n```\n\n\n#### `reset_force()`: Resets the force acting on the atom\n```python\ndef reset_force(self):\n    \"\"\"Reset force to zero at start of each step\"\"\"\n    self.force = np.zeros(dimension)\n```\n\n\n#### `update_position(dt)`: Updates the position of the atom\n\n```python\ndef update_position(self, dt):\n    \"\"\"First step of velocity Verlet: update position\"\"\"\n    self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n```\n\n#### `update_velocity(dt)`: Updates the velocity of the atom\n\n```python\ndef update_velocity(self, dt, new_force):\n    \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n    self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n    self.force = new_force\n```\n\n#### `apply_periodic_boundaries(box_size)`: Applies periodic boundary conditions to the atom\n\n```python\ndef apply_periodic_boundaries(self, box_size):\n        \"\"\"Apply periodic boundary conditions\"\"\"\n        self.position = self.position % box_size\n```\n\n::: {.callout-note collapse=\"true\"}\n#### Complete Atom class\n\n```python\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n        self.mass = mass\n        self.force = np.zeros(2)\n\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(2)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\n    def apply_periodic_boundaries(self, box_size):\n            \"\"\"Apply periodic boundary conditions\"\"\"\n            self.position = self.position % box_size\n```\n:::\n\n\nThis would be a good time to do something simple with the atom class. Let's create a bunch of atoms and plot them in a 2D space.\n\n\n```{pyodide}\n#| autorun: true\n#| edit: false\n#| echo: false\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.rcParams.update({'font.size': 8,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 10,\n                     'axes.titlesize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))\n\n\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n        self.mass = mass\n        self.force = np.zeros(2)\n\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(2)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\n    def apply_periodic_boundaries(self, box_size):\n            \"\"\"Apply periodic boundary conditions\"\"\"\n            self.position = self.position % box_size\n```\n\n\n```{pyodide}\natoms = [\n    Atom(0, 'C', np.array([0.0, 0.0]), velocity=np.array([1.0, 1.0]), mass=1.0),\n    Atom(1, 'C', np.array([2.0, 2.0]), velocity=np.array([-1.0, 1.0]), mass=1.0)\n]\n\n# Visualize positions\nplt.figure(figsize=(6,6))\nfor atom in atoms:\n    plt.plot(atom.position[0], atom.position[1], 'o')\n    # Add velocity arrows\n    plt.arrow(atom.position[0], atom.position[1],\n             atom.velocity[0], atom.velocity[1],\n             head_width=0.1)\n\nplt.axis('equal')\nplt.show()\n```\n\n",
    "supporting": [
      "md3_files"
    ],
    "filters": [],
    "includes": {}
  }
}