{
  "hash": "e1a9d13ec3b292cdd74512bed9515cba",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Step-by-Step Development of a Molecular Dynamics Simulation\"\nauthor: \"Frank Cichos\"\njupyter: python3\nformat:\n  html:\n    code-fold: true\n---\n\n\n## Molecular Dynamics Simulations\n\nReal molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\n\nBefore we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation.\n\n\n## Basic Physical Concepts\n\n### Newton's Equations of Motion\n\nThe motion of particles in a molecular dynamics simulation is governed by Newton's equations of motion:\n\n$$m_i \\frac{d^2\\vec{r}_i}{dt^2} = \\vec{F}_i$$\n\nwhere:\n\n- $m_i$ is the mass of particle $i$\n- $\\vec{r}_i$ is the position of particle $i$\n- $\\vec{F}_i$ is the force acting on particle $i$\n\nThe force acting on a particle is the sum of all forces acting on it:\n\n$$\\vec{F}_i = \\sum_{j \\neq i} \\vec{F}_{ij}$$\n\nwhere $\\vec{F}_{ij}$ is the force acting on particle $i$ due to particle $j$.\n\n### Potential Energy Functions and Forces\nThe force $\\vec{F}_{ij}$ is usually derived from a potential energy function and may result from a variety of interactions, such as:\n\n- Bonded interactions\n  - bond stretching\n      ![Bond Stretching](img/bond.png){width=30%}\n  - bond angle bending\n    ![Bond Stretching](img/bond_angle.png){width=30%}\n  - torsional interactions\n    ![Bond Stretching](img/dihedral.png){width=30%}\n\n\n- Non-bonded interactions\n  - electrostatic interactions\n  - van der Waals interactions\n\n- External forces\n\nWe will implement some of them but not all of them.\n\n#### Lennard-Jones Potential\n\nThe most common potential energy function used in MD simulations is the Lennard-Jones potential. It is belonging to the class of non-bonded interactions. The force and the potential energy of the Lennard-Jones potential are given by:\n\n$$V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]$$\n\nand\n\n$$F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}$$\n\nwhere:\n\n- $\\epsilon$ is the depth of the potential well\n- $\\sigma$ is the distance at which the potential is zero\n- $r$ is the distance between particles\n\nThe Lenard Jones potential is good for describing the interaction of non-bonded atoms in a molecular system e.g. in a gas or a liquid and is therefore well suited if we first want to simulate a gas or a liquid.\n\n\n\n::: {#0f2b514b .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\ndef lennard_jones(r, epsilon=1, sigma=1):\n    return 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)\n\nr = np.linspace(0.8, 3, 1000)\nV = lennard_jones(r)\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(r, V, 'b-', linewidth=2)\nplt.grid(True)\nplt.xlabel('r/σ')\nplt.ylabel('V/ε')\nplt.title('Lennard-Jones Potential')\nplt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\nplt.ylim(-1.5, 3)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](md1_files/figure-html/cell-3-output-1.png){fig-align='center'}\n:::\n:::\n\n\nThe figure above shows the Lenard-Jones potential as a function of the distance between particles. The potential energy is zero at the equilibrium distance $r = \\sigma$ and has a minimum at $r = 2^{1/6}\\sigma$. The potential energy is positive for $r < \\sigma$ and negative for $r > \\sigma$.\n\n\n::: {.callout-note}\n## Values for atomic hydrogen\nFor atomic hydrogen (H), typical Lennard-Jones parameters are:\n\n- $\\sigma \\approx 2.38$ Å = $2.38 \\times 10^{-10}$ meters\n- $\\epsilon \\approx 0.0167$ kcal/mol = $1.16 \\times 10^{-21}$ joules\n:::\n\nLater, if we manage to advance to some more complicated systems, we may want to introduce:\n\n1. force in bonds between two atoms\n2. force in bond angles between three atoms\n3. force in dihedral angles between four atoms\n\nBut for now, we will stick to the Lennard-Jones potential.\n\n\n## Integrating Newtons Euqation of Motion\nWhen we have the forces on a particle we have in principle its acceleration. To get the velocity and the position of the particle we need to integrate the equations of motion. There are several methods to do this, but we will start with the simplest one, the Euler method.\n\n### Euler Method\nTo obtain this one first needs to know about the Taylor expansion of a function in general. The Taylor expansion of a function $f(x)$ around a point $x_0$ is providing an approximation of the function in the vicinity of $x_0$. It is given by:\n\n$$f(x) = f(x_0) + f'(x_0)(x - x_0) + \\frac{1}{2}f''(x_0)(x - x_0)^2 + \\cdots$$\n\nwhere $f'(x_0)$ is the first derivative of $f(x)$ at $x_0$, $f''(x_0)$ is the second derivative of $f(x)$ at $x_0$, and so on. We can demonstrate that by expanding a sine function around $x_0 = 0$:\n\n$$\\sin(x) = \\sin(0) + \\cos(0)x - \\frac{1}{2}\\sin(0)x^2 + \\cdots = x - \\frac{1}{6}x^3 + \\cdots$$\n\nPlotting this yields:\n\n::: {#3a02fb5a .cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nx = np.linspace(-2*np.pi, 2*np.pi, 1000)\ny = np.sin(x)\ny_taylor = x - 1/6*x**3\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(x, y, 'b-', label='sin(x)', linewidth=2)\nplt.plot(x, y_taylor, 'r--', label='Taylor expansion', linewidth=2)\nplt.grid(True)\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.xlim(-2,2)\nplt.ylim(-2,2)\nplt.title('Taylor Expansion of sin(x)')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](md1_files/figure-html/cell-4-output-1.png){fig-align='center'}\n:::\n:::\n\n\nThe expansion is therefore a good approximation in a region close to $x_0$.\n\n### Velocity Verlet Algorithm\nThe velocity Verlet algorithm is a second-order algorithm that is more accurate than the Euler method. It can be derived from the Taylor expansion of the position and velocity vectors\n\n$$\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2+ O(\\Delta t^3)$$\n\n\nThe higher order terms in the Taylor expansion are neglected, which results in an error of order $\\Delta t^3$. As compared to that the Euler method is obtained by neglecting the higher order terms in the Taylor expansion of the velocity vector:\n\n$$\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m}\\Delta t + O(\\Delta t^2)$$\n\nand is therefore only first order accurate with an error of order $\\Delta t^2$.\n\n\nThe velocity Verlet algorithm consists of three steps:\n\n1. Update positions:\n   $\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2$\n\n2. Calculate new forces:\n   $\\mathbf{F}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))$\n\n3. Update velocities:\n   $\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\frac{\\mathbf{F}(t) + \\mathbf{F}(t + \\Delta t)}{m}\\Delta t$\n\nwhere:\n- $\\mathbf{r}$ is the position vector\n- $\\mathbf{v}$ is the velocity vector\n- $\\mathbf{F}$ is the force vector\n- $m$ is the mass\n- $\\Delta t$ is the timestep\n\n\n### Simple Integration Example: Free Fall\n\nLet's start and try to integrate the equation of motion for a particle in free fall with the help of the Velocity Verlet algorithm. The only force acting on the particle is gravity. The equation of motion is:\n\nNewton's equation of motion:\n$\\mathbf{F} = m\\mathbf{a}$\n\nFor gravity:\n$\\mathbf{F} = -mg\\hat{\\mathbf{y}}$\n\nTherefore:\n$\\ddot{y} = -g$\n\nThe analytical solution is:\n\n  - Position: $y(t) = y_0 + v_0t - \\frac{1}{2}gt^2$\n  - Velocity: $v(t) = v_0 - gt$\n\n::: {#624908a3 .cell execution_count=4}\n``` {.python .cell-code}\n# Parameters\n\ng = 9.81  # m/s^2\ndt = 0.01  # time step\nt_max = 2.0  # total simulation time\nsteps = int(t_max/dt)\n\n# Initial conditions\ny0 = 20.0  # initial height\nv0 = 0.0   # initial velocity\n\n\n# Arrays to store results\nt = np.zeros(steps)\ny = np.zeros(steps)\nv = np.zeros(steps)\na = np.zeros(steps)\n\n# Initial values\ny[0] = y0\nv[0] = v0\na[0] = -g\n\n# Velocity Verlet integration\nfor i in range(1, steps):\n    t[i] = i * dt\n    y[i] = y[i-1] + v[i-1] * dt + 0.5 * a[i-1] * dt**2  # update position\n    a_new = -g                                          # new acceleration (assuming constant gravity)\n    v[i] = v[i-1] + 0.5 * (a[i-1] + a_new) * dt         # update velocity\n    a[i] = a_new                                        # store new acceleration\n\ny_analytical = y0 + v0*t - 0.5*g*t**2\nplt.figure(figsize=get_size(8, 6), dpi=150)\nplt.plot(t, y)\nplt.plot(t, y_analytical, 'r--')\n\nplt.xlabel('Time (s)')\nplt.ylabel('Height (m)')\nplt.title('Free Fall Motion')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](md1_files/figure-html/cell-5-output-1.png){fig-align='center'}\n:::\n:::\n\n\n",
    "supporting": [
      "md1_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}