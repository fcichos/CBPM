{
  "hash": "e547d72e5c3ad1129c4ec9546b833010",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Step-by-Step Development of a Molecular Dynamics Simulation\"\njupyter: python3\nformat:\n  html:\n    code-fold: true\n---\n\n\n\n\n## Molecular Dynamics Simulations\n\nReal molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\n\nBefore we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation. The Jupyter Notebook below will help you to copy and paste the code to test the snippets presented.\n\n\n\n\n\n```{=html}\n<button onclick=\"openInNewWindow()\" style=\"background-color: #4CAF50; color: white; padding: 5px 15px; border: none; border-radius: 8px; cursor: pointer; box-shadow: none;\">Open in New Window</button>\n<iframe id=\"myIframe\" src=\"https://jupyterlite.github.io/demo/\" width=\"100%\" height=\"600px\" allowfullscreen></iframe>\n\n<script>\nfunction openInNewWindow() {\n  window.open('https://jupyterlite.github.io/demo/', '_blank', 'width=1024,height=768');\n}\n</script>\n```\n\n\n\n\n## Basic Physical Concepts\n\n### Newton's Equations of Motion\n\nThe motion of particles in a molecular dynamics simulation is governed by Newton's equations of motion:\n\n$$m_i \\frac{d^2\\vec{r}_i}{dt^2} = \\vec{F}_i$$\n\nwhere $m_i$ is the mass of particle $i$, $\\vec{r}_i$ is the position of particle $i$, and $\\vec{F}_i$ is the force acting on particle $i$.\n\nThe force acting on a particle is the sum of all forces acting on it:\n\n$$\\vec{F}_i = \\sum_{j \\neq i} \\vec{F}_{ij}$$\n\nwhere $\\vec{F}_{ij}$ is the force acting on particle $i$ due to particle $j$.\n\n### Potential Energy Functions and Forces\nThe force $\\vec{F}_{ij}$ is usually derived from a potential energy function and may result from a variety of interactions, such as:\n\n| Interaction Type | Subtype | Illustration |\n|-----------------|---------|--------------|\n| Bonded interactions | Bond stretching | ![Bond Stretching](img/bond.png){width=50%} |\n| | Bond angle bending | ![Bond Stretching](img/bond_angle.png){width=50%} |\n| | Torsional interactions | ![Bond Stretching](img/dihedral.png){width=50%} |\n| Non-bonded interactions | Electrostatic interactions | |\n| | Van der Waals interactions | |\n| External forces | | |\n\nWe will implement some of them but not all of them.\n\n#### Lennard-Jones Potential\n\nThe most common potential energy function used in MD simulations is the Lennard-Jones potential. It is belonging to the class of non-bonded interactions. The force and the potential energy of the Lennard-Jones potential are given by:\n\n$$V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]$$\n\nand\n\n$$F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}$$\n\nwhere $\\frac{\\vec{r}}{r^2}$ represents the direction of the force (the unit vector $\\hat{r} = \\frac{\\vec{r}}{r}$) multiplied by $\\frac{1}{r}$, and $\\epsilon$ is the depth of the potential well, $\\sigma$ is the distance at which the potential is zero, and $r$ is the distance between particles.\n\nThe Lenard Jones potential is good for describing the interaction of non-bonded atoms in a molecular system e.g. in a gas or a liquid and is therefore well suited if we first want to simulate a gas or a liquid.\n\n\n\n::: {#2988cfa5 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\ndef lennard_jones(r, epsilon=1, sigma=1):\n    return 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)\n\nr = np.linspace(0.8, 3, 1000)\nV = lennard_jones(r)\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(r, V, 'b-', linewidth=2)\nplt.grid(True)\nplt.xlabel('r/σ')\nplt.ylabel('V/ε')\nplt.title('Lennard-Jones Potential')\nplt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\nplt.ylim(-1.5, 3)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](md1_files/figure-html/cell-3-output-1.png){width=463 height=389 fig-align='center'}\n:::\n:::\n\n\nThe figure above shows the Lennard-Jones potential as a function of the distance between particles. The potential energy is zero at the equilibrium distance $r = \\sigma$ and has a minimum at $r = 2^{1/6}\\sigma$. The potential energy is positive for $r < \\sigma$ and negative for $r > \\sigma$.\n\n\n::: {.callout-note}\n## Values for atomic hydrogen\nFor atomic hydrogen (H), typical Lennard-Jones parameters are:\n\n- $\\sigma \\approx 2.38$ Å = $2.38 \\times 10^{-10}$ meters\n- $\\epsilon \\approx 0.0167$ kcal/mol = $1.16 \\times 10^{-21}$ joules\n:::\n\nLater, if we manage to advance to some more complicated systems, we may want to introduce:\n\n1. force in bonds between two atoms\n2. force in bond angles between three atoms\n3. force in dihedral angles between four atoms\n\nBut for now, we will stick to the Lennard-Jones potential.\n\n<!--\n## Periodic Boundary Conditions\nIn most molecular dynamics simulations, we use periodic boundary conditions (PBC) to mimic an infinite system while simulating only a finite number of particles. When a particle leaves the simulation box on one side, it re-enters from the opposite side. This eliminates artificial boundary effects and allows us to simulate bulk properties with relatively few particles.\n\n![Periodic Boundary Conditions](img/periodic_boundaries.png){width=50%}\n-->\n\n\n## Integrating Newton's Equation of Motion\nWhen we have the forces on a particle we have in principle its acceleration. To get the velocity and the position of the particle we need to integrate the equations of motion. There are several methods to do this, but we will start with the simplest one, the Euler method.\n\n### Euler Method\nTo obtain this one first needs to know about the Taylor expansion of a function in general. The Taylor expansion of a function $f(x)$ around a point $x_0$ is providing an approximation of the function in the vicinity of $x_0$. It is given by:\n\n$$f(x) = f(x_0) + f'(x_0)(x - x_0) + \\frac{1}{2}f''(x_0)(x - x_0)^2 + \\cdots$$\n\nwhere $f'(x_0)$ is the first derivative of $f(x)$ at $x_0$, $f''(x_0)$ is the second derivative of $f(x)$ at $x_0$, and so on. We can demonstrate that by expanding a sine function around $x_0 = 0$:\n\n$$\\sin(x) = \\sin(0) + \\cos(0)x - \\frac{1}{2}\\sin(0)x^2 + \\cdots = x - \\frac{1}{6}x^3 + \\cdots$$\n\nPlotting this yields:\n\n::: {#fe41f169 .cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nx = np.linspace(-2*np.pi, 2*np.pi, 1000)\ny = np.sin(x)\ny_taylor = x - 1/6*x**3\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(x, y, 'b-', label='sin(x)', linewidth=2)\nplt.plot(x, y_taylor, 'r--', label='Taylor expansion', linewidth=2)\nplt.grid(True)\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.xlim(-2,2)\nplt.ylim(-2,2)\nplt.title('Taylor Expansion of sin(x)')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](md1_files/figure-html/cell-4-output-1.png){width=470 height=389 fig-align='center'}\n:::\n:::\n\n\nThe expansion is therefore a good approximation in a region close to $x_0$.\n\n### Velocity Verlet Algorithm\nThe velocity Verlet algorithm is a second-order algorithm that offers greater accuracy than the Euler method. It can be derived from the Taylor expansion of the position and velocity vectors:\n\n$$\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2+ O(\\Delta t^3)$$\n\nThe higher order terms in the Taylor expansion are neglected, which results in an error of order $\\Delta t^3$. In contrast, the Euler method is obtained by neglecting the higher order terms in the Taylor expansion of the velocity vector:\n\n$$\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m}\\Delta t + O(\\Delta t^2)$$\n\nThis makes the Euler method only first order accurate with an error of order $\\Delta t^2$.\n\nThe Velocity Verlet algorithm is particularly valuable for molecular dynamics simulations because it offers several advantages over the Euler method. It does a much better job preserving the total energy of the system over long simulation times. The algorithm is also time-reversible, which is a property of the exact equations of motion. Furthermore, it provides symplectic integration, preserving the phase space volume, another important property for physical simulations. These properties make the Velocity Verlet algorithm much more stable for long simulations, which is crucial when modeling molecular systems over meaningful timescales.\n\nThe velocity Verlet algorithm provides a stable and accurate way to integrate the equations of motion through a three-stage process. First, we update positions using current velocities and forces:\n$$\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2$$\n\nNext, we calculate new forces based on these updated positions:\n$$\\mathbf{F}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))$$\n\nFinally, we update velocities using an average of old and new forces:\n$$\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\frac{\\mathbf{F}(t) + \\mathbf{F}(t + \\Delta t)}{m}\\Delta t$$\n\nIn these equations, $\\mathbf{r}$ represents the position vector, $\\mathbf{v}$ is the velocity vector, $\\mathbf{F}$ is the force vector, $m$ stands for mass, and $\\Delta t$ is the timestep. This approach ensures greater accuracy and stability in our molecular dynamics simulations compared to simpler methods.\n\n\n\n### Simple Integration Example: Free Fall\n\nLet's start by integrating the equation of motion for a particle in free fall using the Velocity Verlet algorithm. This is an ideal starting example since the physics is straightforward, with gravity being the only force acting on the particle, and we can compare our numerical solution to the well-known analytical one.\n\nNewton's equation of motion:\n$$\\mathbf{F} = m\\mathbf{a}$$\n\nFor gravity, the only force acting on our particle is the gravitational force pointing downward:\n$$\\mathbf{F} = -mg\\hat{\\mathbf{y}}$$\n\nTherefore, the acceleration in the y-direction is constant:\n$$\\ddot{y} = -g$$\n\nThe analytical solution to this differential equation gives us the position and velocity at any time $t$. The position is given by $$y(t) = y_0 + v_0t - \\frac{1}{2}gt^2$$, and the velocity is expressed as $$v(t) = v_0 - gt$$. Here, $y_0$ is the initial height, $v_0$ is the initial velocity, and $g$ is the acceleration due to gravity. We can use this exact solution to verify our numerical integration method.\n\n::: {#dffd3c5b .cell execution_count=4}\n``` {.python .cell-code}\n# Parameters\n\ng = 9.81  # m/s^2\ndt = 0.01  # time step\nt_max = 2.0  # total simulation time\nsteps = int(t_max/dt)\n\n# Initial conditions\ny0 = 20.0  # initial height\nv0 = 0.0   # initial velocity\n\n\n# Arrays to store results\nt = np.zeros(steps)\ny = np.zeros(steps)\nv = np.zeros(steps)\na = np.zeros(steps)\n\n# Initial values\ny[0] = y0\nv[0] = v0\na[0] = -g\n\n# Velocity Verlet integration\nfor i in range(1, steps):\n    t[i] = i * dt\n    y[i] = y[i-1] + v[i-1] * dt + 0.5 * a[i-1] * dt**2  # update position\n    a_new = -g                                          # new acceleration (assuming constant gravity)\n    v[i] = v[i-1] + 0.5 * (a[i-1] + a_new) * dt         # update velocity\n    a[i] = a_new                                        # store new acceleration\n\ny_analytical = y0 + v0*t - 0.5*g*t**2\nplt.figure(figsize=get_size(8, 6), dpi=150)\nplt.plot(t, y)\nplt.plot(t, y_analytical, 'r--')\n\nplt.xlabel('Time (s)')\nplt.ylabel('Height (m)')\nplt.title('Free Fall Motion')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](md1_files/figure-html/cell-5-output-1.png){width=460 height=389 fig-align='center'}\n:::\n:::\n\n\n",
    "supporting": [
      "md1_files"
    ],
    "filters": [],
    "includes": {}
  }
}