{
  "hash": "145213e6026f73cdd6561ec19fbee519",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Step-by-Step Development of a Molecular Dynamics Simulation\"\nauthor: \"Frank Cichos\"\njupyter: python3\nformat:\n  html:\n    code-fold: true\n---\n\n\n\n## From Theory to Code\nIn the previous seminar, we learned about the key components of a molecular dynamics simulation:\n\n- The Lennard-Jones potential describing forces between atoms\n- The Velocity Verlet algorithm for updating positions and velocities\n\nNow we'll implement these concepts in code. To organize our simulation, we'll have to think about some issues:\n\n\n### What to do at the boundary: Boundary Conditions\nIn the previous example, we have assumed that the particle is in free fall. That means eventually it would bounce against the floor. In a real simulation, we need to consider boundary conditions as well. For example, if the particle hits the ground we could implement a simple reflection rule. This is called *reflecting boundary conditions* and would introduce some additional effects to the simulation. On the other side, one could make the system \"kind of\" infinitely large by introducing *periodic boundary conditions*. This means that if a particle leaves the simulation box on one side, it re-enters on the opposite side. This is a common approach in molecular dynamics simulations.\n\n![Perdiodic Boundary Conditions](img/pbc.png){width=50%}\n\n::: {.callout-note collapse=\"true\"}\n#### The Minimum Image Convention in Molecular Dynamics\nWhen we simulate particles in a box with periodic boundary conditions (meaning particles that leave on one side reappear on the opposite side), we need to calculate the forces between them correctly. Imagine two particles near opposite edges of the box: one at position x=1 and another at x=9 in a box of length 10. Without the minimum image convention, we would calculate their distance as 8 units (9-1). However, due to the periodic boundaries, these particles could actually interact across the boundary, with a shorter distance of just 2 units! The minimum image convention automatically finds this shortest distance, ensuring that we calculate the forces between particles correctly. It's like taking a shortcut across the periodic boundary instead of walking the longer path through the box.\n:::\n\n### How to represent atoms\nThe question we have to think about now is how to implement these formulas in a numerical simulation. The goal is to simulate the motion of many atoms in a box. Each atom is different and has its own position, velocity, and force. Consequently we need to store these quantities for each atom, though the structure in which we store them is the same for each atom. All atoms with their properties actually belong to the same class of objects. We can therefore use a very suitable concept of *object-oriented programming*, the class.\n\nA class in object-oriented programming is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods). The class is a template for objects, and an object is an instance of a class. The class defines the properties and behavior common to all objects of the class. The objects are the instances of the class that contain the actual data.\n\nThink of the Atom class as a container for everything we need to know about a single atom:\n\n- Its position (where is it?)\n- Its velocity (how fast is it moving?)\n- The forces acting on it (what's pushing or pulling it?)\n- Its type (is it hydrogen, oxygen, etc.?)\n- Its mass (how heavy is it?)\n\n\n### How to represent forces\nWe also have a set of forces, that is acting between the atoms. These forces are calculated based on the positions of the atoms. The force fields are all the same for the atoms only the parameters are different. We can represent the force field as a class as well. We will first implement the Lennard-Jones potential in the class. Later we will implement more complex force fields. We will realize that we will later have to introduce different parameters for the Lenard Jones potential for different atom types. We will store these parameters in a dictionary. This dictionary will be part of the force field class and actually represent the Force Field.\n\nIf atoms are of the same type, they will have the same parameters. However, if they are of different types we will have to mix the parameters. This is done by the mixing rules. We will implement the Lorentz-Berthelot mixing rules. These rules are used to calculate the parameters for the interaction between two different atom types.\n\n#### Lorentz-Berthelot Mixing Rules\nFor two different atoms (A and B), the Lennard-Jones parameters $\\sigma$ and $\\epsilon$ are calculated using:\n\n- Arithmetic mean for $\\sigma$ (Lorentz rule):\n\n   $$\\sigma_{AB} = \\frac{\\sigma_A + \\sigma_B}{2}$$\n\n- Geometric mean for $\\epsilon$ (Berthelot rule):\n\n   $$\\epsilon_{AB} = \\sqrt{\\epsilon_A \\epsilon_B}$$\n\nThese parameters are then used in the Lennard-Jones potential:\n\n$$V_{LJ}(r) = 4\\epsilon_{AB}\\left[\\left(\\frac{\\sigma_{AB}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{AB}}{r}\\right)^6\\right]$$\n\n### How do we introduce temperature\nIn the previous example, we have started with a particle at rest. In a real simulation, we would like to start with a certain temperature. This means that the particles have a certain velocity distribution. We can introduce this by assigning random velocities to the particles. The velocities should be drawn from a Maxwell-Boltzmann distribution. This is a distribution that describes the velocity distribution of particles in at a certain temperature. The distribution is given by:\n\n$$\nf_v\\left(v_x\\right)=\\sqrt{\\frac{m}{2 \\pi k_B T}} \\exp \\left[\\frac{-m v_x^2}{2 k_B T}\\right]\n$$\n\nwhere $m$ is the mass of the particle, $k_B$ is Boltzmann's constant, and $T$ is the temperature. $v_x$ is the velocity in the x-direction. The velocities in the y and z directions are drawn in the same way. The temperature of the system is related to the kinetic energy of the particles.\n\n::: {.callout-note collapse=\"true\"}\n## Maxwell-Boltzmann Velocities in 3D\n\nThe probability distribution for the velocity magnitude in 3D is:\n\n$$f(v) = 4\\pi v^2 \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\exp\\left(-\\frac{mv^2}{2k_BT}\\right)$$\n\n- Mean velocity magnitude:\n\n   $$\\langle v \\rangle = \\sqrt{\\frac{8k_BT}{\\pi m}}$$\n\n- Most probable velocity (peak of distribution):\n\n   $$v_{mp} = \\sqrt{\\frac{2k_BT}{m}}$$\n\n- Root mean square velocity:\n\n   $$v_{rms} = \\sqrt{\\frac{3k_BT}{m}}$$\n\nThese velocities can also be expressed in terms of the kinetic energy of the particles. The average kinetic energy per particle is:\n\n$$\\langle E_{kin} \\rangle = \\frac{3}{2}k_BT$$\n\nThen we can express the velocities as:\n\n- Mean velocity magnitude:\n\n   $$\\langle v \\rangle = \\sqrt{\\frac{8\\langle E_{kin} \\rangle}{3\\pi m}}$$\n\n- Most probable velocity:\n\n   $$v_{mp} = \\sqrt{\\frac{4\\langle E_{kin} \\rangle}{3m}}$$\n\n- Root mean square velocity:\n\n   $$v_{rms} = \\sqrt{\\frac{2\\langle E_{kin} \\rangle}{m}}$$\n:::\n\n::: {#cell-fig-MB_1D .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\n# Constants\nkb = 1.380649e-23  # Boltzmann constant in J/K\nm_H = 1.6735575e-27  # Mass of hydrogen atom in kg\nT = 300  # Temperature in K\n\n# Velocity range for plotting\nv = np.linspace(-10000, 10000, 1000)  # m/s\nv_mag = np.linspace(0, 10000, 1000)  # m/s\n\n# Maxwell-Boltzmann distribution for x-component\ndef MB_1D(v, m, T):\n    return np.sqrt(m/(2*np.pi*kb*T)) * np.exp(-m*v**2/(2*kb*T))\n\n# Maxwell-Boltzmann distribution for velocity magnitude in 2D\ndef MB_2D_mag(v, m, T):\n    return v * m/(kb*T) * np.exp(-m*v**2/(2*kb*T))\n\n# Create figure\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(16, 8))\n\n# Plot x-component distribution\nax1.plot(v, MB_1D(v, m_H, T))\nax1.set_xlabel('Velocity [m/s]')\nax1.set_ylabel('Probability density')\n\n# Plot magnitude distribution\nax2.plot(v_mag, MB_2D_mag(v_mag, m_H, T))\nax2.set_xlabel('Velocity magnitude [m/s]')\nax2.set_ylabel('Probability density')\nax2.axvline(np.sqrt(kb*T/m_H), color='r', linestyle='--', label='Most probable velocity')\nax2.axvline(np.sqrt(2)*np.sqrt(kb*T/m_H), color='g', linestyle='--', label='Mean velocity')\n\nplt.tight_layout()\nplt.show()\n\n# Print most probable velocity\nv_mp_1D = 0  # Most probable velocity for 1D is zero\nv_mp_2D = np.sqrt(kb*T/m_H)  # Most probable velocity magnitude in 2D\nprint(f\"Most probable velocity magnitude in 2D: {v_mp_2D:.1f} m/s\")\nprint(f\"Mean velocity magnitude in 2D: {np.sqrt(2)*v_mp_2D:.1f} m/s\")\n```\n\n::: {.cell-output .cell-output-display}\n![Maxwell Boltzmann distribution of speeds for one component of the velocity and the magnitude of the velocity vector.](md2_files/figure-html/fig-mb_1d-output-1.png){#fig-mb_1d width=601 height=298}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nMost probable velocity magnitude in 2D: 1573.2 m/s\nMean velocity magnitude in 2D: 2224.8 m/s\n```\n:::\n:::\n\n\nThe temperature T in a 2D system is related to the kinetic energy by:\n\n$$T = \\frac{2K}{N_f k_B}$$\n\nwhere:\n\n- K is the total kinetic energy: $K = \\sum_i \\frac{1}{2}m_i v_i^2$\n- $N_f$ is the number of degrees of freedom (2N in 2D, where N is number of particles)\n- $k_B$ is Boltzmann's constant (often set to 1 in reduced units)\n\nTo scale to a target temperature $T_{target}$, we multiply velocities by $\\sqrt{\\frac{T_{target}}{T_{current}}}$\n\n\n### Who is controlling our simulation: Controller Class\nFinally, we need a class that controls the simulation. This class will contain the main loop of the simulation, where the integration algorithm is called in each time step. It will also contain the methods to calculate the forces between the atoms.\n\n\n### How do we visualize our simulation\n\nBefore we implement all classes, we will first visualize the particles moving in a 2D box. We will use the `matplotlib` library to create an animation of the particles moving in the box. We will also implement periodic boundary conditions, so that particles that leave the box on one side re-enter on the opposite side.\n\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nfrom scipy.spatial.distance import cdist\n\nn_side =2\n\nx = np.linspace(0.05, 0.95, n_side)     #<1>\ny = np.linspace(0.05, 0.95, n_side)\nxx, yy = np.meshgrid(x, y)              #<2>\nparticles = np.vstack([xx.ravel(), yy.ravel()]).T  #<3>\n\nvelocities = np.random.normal(scale=0.005, size=(n_side**2, 2))\n\nradius = 0.0177\nfig, ax = plt.subplots(figsize=(9,9))\n\nn_steps = 200\n\nfor _ in range(n_steps):  #<4>\n    clear_output(wait=True)  #<5>\n\n    # Update particle positions based on their velocities\n    particles += velocities\n    # Apply periodic boundary conditions in x direction (wrap around at 0 and 1)\n    particles[:, 0] = particles[:, 0] % 1\n    # Apply periodic boundary conditions in y direction (wrap around at 0 and 1)\n    particles[:, 1] = particles[:, 1] % 1\n    # Calculate distances between all pairs of particles\n    distances = cdist(particles, particles)\n\n    # Calculate collisions using the upper triangle of the distance matrix\n    # distances < 2*radius gives a boolean matrix where True means collision\n    # np.triu takes only the upper triangle to avoid counting collisions twice\n    collisions = np.triu(distances < 2*radius, 1)\n\n    # Handle collisions between particles\n    for i, j in zip(*np.nonzero(collisions)):\n        # Exchange velocities between colliding particles (elastic collision)\n        velocities[i], velocities[j] = velocities[j], velocities[i].copy() #<6>\n\n        # Calculate how much particles overlap\n        overlap = 2*radius - distances[i, j]\n\n        # Calculate unit vector pointing from j to i\n        direction = particles[i] - particles[j]\n        direction /= np.linalg.norm(direction)\n\n        # Move particles apart to prevent overlap\n        particles[i] += 0.5 * overlap * direction\n        particles[j] -= 0.5 * overlap * direction\n\n    ax.scatter(particles[:, 0], particles[:, 1], s=100, edgecolors='r', facecolors='none')\n\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.axis(\"off\")\n\n    display(fig)\n    plt.pause(0.01)\n\n    # Clear the current plot to prepare for next frame\n    ax.clear()\n```\n\n\n1. Create a 1D array of x and y-coordinates for the particles.\n2. Create a meshgrid of x and y-coordinates.\n3. Flatten the meshgrid to get a 2D array of particle positions.\n4. Simulation loop\n5. Clear the output to display the animation in a single cell.\n6. Handle collisions between particles by exchanging velocities and moving particles apart to prevent overlap. The exchange of velocities in your code works because of the  conservation of momentum and energy:\n\n::: {style=\"margin-left: 2em\"}\n\nFor two particles of equal mass m in a head-on elastic collision:\n Before collision:\n\n - Momentum: $p = mv_1 + mv_2$\n - Energy: $E = \\frac{1}{2}mv_1^2 + \\frac{1}{2}mv_2^2$\n\n After collision (with velocity exchange):\n - Momentum: $p = mv_2 + mv_1$ (same as before!)\n - Energy: $E = \\frac{1}{2}mv_2^2 + \\frac{1}{2}mv_1^2$ (same as before!)\n:::\n\n::: {#cell-fig-maxwell .cell execution_count=3}\n``` {.python .cell-code}\nfrom IPython.display import clear_output\nfrom scipy.spatial.distance import cdist\nfrom scipy.stats import maxwell\n\n# Increase number of particles for better statistics\nn_side = 10  # Creates 100 particles\nx = np.linspace(0.05, 0.95, n_side)\ny = np.linspace(0.05, 0.95, n_side)\nxx, yy = np.meshgrid(x, y)\nparticles = np.vstack([xx.ravel(), yy.ravel()]).T\n\n# Initialize with normal distribution\nvelocities = np.random.normal(scale=0.005, size=(n_side**2, 2))\nradius = 0.0177\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(15, 8))\nn_steps = 500\n\n# Store velocity magnitudes for analysis\nvelocity_history = []\n\nfor step in range(n_steps):\n    clear_output(wait=True)\n    # Update particle positions based on their velocities\n    particles += velocities\n\n    # Apply periodic boundary conditions\n    particles = particles % 1\n\n    # Calculate distances between all pairs of particles\n    distances = cdist(particles, particles)\n\n    # Calculate collisions using the upper triangle of the distance matrix\n    collisions = np.triu(distances < 2*radius, 1)\n\n    # Handle collisions between particles\n    for i, j in zip(*np.nonzero(collisions)):\n        # Get particle positions and velocities\n        pos_i, pos_j = particles[i], particles[j]\n        vel_i, vel_j = velocities[i], velocities[j]\n\n        # Calculate relative position vector (line of centers)\n        r_ij = pos_i - pos_j\n        dist = np.linalg.norm(r_ij)\n        r_ij_normalized = r_ij / dist if dist > 0 else np.array([1, 0])\n\n        # *** CORRECTED COLLISION PHYSICS ***\n        # Split velocities into components parallel and perpendicular to collision axis\n        v_i_parallel = np.dot(vel_i, r_ij_normalized) * r_ij_normalized\n        v_i_perp = vel_i - v_i_parallel\n\n        v_j_parallel = np.dot(vel_j, r_ij_normalized) * r_ij_normalized\n        v_j_perp = vel_j - v_j_parallel\n\n        # Exchange parallel components (proper elastic collision)\n        velocities[i] = v_i_perp + v_j_parallel\n        velocities[j] = v_j_perp + v_i_parallel\n\n        # Move particles apart to prevent overlap\n        overlap = 2*radius - dist\n        particles[i] += 0.5 * overlap * r_ij_normalized\n        particles[j] -= 0.5 * overlap * r_ij_normalized\n\n    # Every 5 steps, record velocity magnitudes\n    if step % 5 == 0:\n        speeds = np.sqrt(np.sum(velocities**2, axis=1))\n        velocity_history.extend(speeds)\n\n    # Every 20 steps, update the visualization\n    if step % 20 == 0:\n        # Clear the current plot to prepare for next frame\n        ax1.clear()\n        ax2.clear()\n\n        # Plot particles\n        ax1.scatter(particles[:, 0], particles[:, 1], s=100, edgecolors='r', facecolors='none')\n        ax1.set_xlim(0, 1)\n        ax1.set_ylim(0, 1)\n        ax1.set_title(f\"Step {step}\")\n        ax1.axis(\"off\")\n\n        # Plot velocity distribution\n        if velocity_history:\n            # Plot histogram of speeds\n            hist, bins = np.histogram(velocity_history, bins=30, density=True)\n            bin_centers = 0.5 * (bins[1:] + bins[:-1])\n            ax2.bar(bin_centers, hist, width=bins[1]-bins[0], alpha=0.7, label='Simulation')\n\n            # Plot Maxwell-Boltzmann distribution for comparison\n            # For 2D Maxwell-Boltzmann, use Rayleigh distribution parameters\n            scale = np.std(velocity_history) / np.sqrt(1 - 2/np.pi)\n            x = np.linspace(0, max(velocity_history), 100)\n\n            # In 2D, speed follows Rayleigh distribution\n            rayleigh_pdf = (x/scale**2) * np.exp(-x**2/(2*scale**2))\n            ax2.plot(x, rayleigh_pdf, 'r-', lw=2, label='Maxwell-Boltzmann (2D)')\n\n            ax2.set_title(\"Speed Distribution\")\n            ax2.set_xlabel(\"Speed\")\n            ax2.set_ylabel(\"Probability Density\")\n            ax2.legend()\n\n        display(fig)\n        plt.pause(0.01)\n\n# Final velocity distribution\nplt.figure(figsize=get_size(12, 8))\nhist, bins = np.histogram(velocity_history, bins=30, density=True)\nbin_centers = 0.5 * (bins[1:] + bins[:-1])\nplt.bar(bin_centers, hist, width=bins[1]-bins[0], alpha=0.7, label='Simulation')\n\n# Plot ideal Maxwell-Boltzmann distribution for 2D (Rayleigh)\nscale = np.std(velocity_history) / np.sqrt(1 - 2/np.pi)\nx = np.linspace(0, max(velocity_history), 100)\nrayleigh_pdf = (x/scale**2) * np.exp(-x**2/(2*scale**2))\nplt.plot(x, rayleigh_pdf, 'r-', lw=2, label='MB (2D)')\n\n\nplt.xlabel(r\"speed $v$\")\nplt.ylabel(\"probability density\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Simulated and analytica  for the Maxwell-Boltzmann distribution.](md2_files/figure-html/fig-maxwell-output-1.png){#fig-maxwell width=419 height=290}\n:::\n:::\n\n\n",
    "supporting": [
      "md2_files"
    ],
    "filters": [],
    "includes": {}
  }
}