{
  "hash": "f3d9bde09beaa7bf27634bbd580f0276",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: NumPy Module\nformat:\n  live-html:\n    toc: true\n    toc-location: right\npyodide:\n  packages:\n    - numpy\n    - matplotlib\n---\n\n\n\n\nNumpy is, besides [SciPy](https://www.scipy.org/), the core library for scientific computing in Python. It provides a high-performance multidimensional array object and tools for working with these arrays. The NumPy array, formally called ndarray in NumPy documentation, is the real workhorse of data structures for scientific and engineering applications. The NumPy array is similar to a list but where all the elements of the list are of the same type. The elements of a **NumPy array** are usually numbers, but can also be booleans, strings, or other objects. When the elements are numbers, they must all be of the same type.\n\nFor physics applications, NumPy is essential because it enables efficient numerical calculations on large datasets, handling of vectors and matrices, and implementation of mathematical models that describe physical phenomena. Whether simulating particle motion, analyzing experimental data, or solving equations of motion, NumPy provides the computational foundation needed for modern physics.\n\n\n\n\n```{pyodide}\nimport numpy as np\n```\n\n\n\n\n## Creating Numpy Arrays\n\nThere are a number of ways to initialize new numpy arrays, for example from\n\n* a Python list or tuples\n* using functions that are dedicated to generating numpy arrays, such as `arange`, `linspace`, etc.\n* reading data from files which will be covered in the files section\n\n::: {.panel-tabset}\n### From lists\n\nFor example, to create new vector and matrix arrays from Python lists we can use the `numpy.array` function.\n\n\n\n\n```{pyodide}\n#| autorun: false\n#this is a list\na = [0, 0, 1, 4, 7, 16, 31, 64, 127]\n```\n\n```{pyodide}\n#| autorun: false\ntype(a)\n```\n\n```{pyodide}\n#| autorun: false\n#this creates an array out of a list\nb=np.array(a,dtype=float)\ntype(b)\n```\n\n```{pyodide}\n#| autorun: false\nnp.array([[1,2,3],[4,5,6],[7,8,9]])\n```\n\n\n\n\n### Using array-generating functions\n\nFor larger arrays it is impractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in `numpy` that generate arrays of different forms. Some of the more common are:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# create a range\n\nx = np.arange(0, 10, 1) # arguments: start, stop, step\nx\n```\n\n```{pyodide}\n#| autorun: false\nx = np.arange(-5, -2, 0.1)\nx\n```\n\n\n\n\n#### linspace and logspace\n\nThe `linspace` function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50.\n\n\n\n\n```{pyodide}\n#| autorun: false\n# using linspace, both end points ARE included\nnp.linspace(0,10,25)\n```\n\n\n\n\n`logspace` is doing equivalent things with logarithmic spacing. Other types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n```{pyodide}\n#| autorun: false\nnp.logspace(0, 10, 10, base=np.e)\n```\n\n\n\n\n#### mgrid\n\n`mgrid` generates a multi-dimensional matrix with increasing value entries, for example in columns and rows:\n\n\n\n\n```{pyodide}\n#| autorun: false\nx, y = np.mgrid[0:1:0.1, 0:5] # similar to meshgrid in MATLAB\n```\n\n```{pyodide}\n#| autorun: false\nx\n```\n\n```{pyodide}\n#| autorun: false\ny\n```\n\n\n\n\n#### diag\n\n`diag` generates a diagonal matrix with the list supplied to it. The values can be also offset from the main diagonal.\n\n\n\n\n```{pyodide}\n#| autorun: false\n# a diagonal matrix\nnp.diag([1,2,3])\n```\n\n```{pyodide}\n#| autorun: false\n# diagonal with offset from the main diagonal\nnp.diag([1,2,3], k=-1)\n```\n\n\n\n\n#### zeros and ones\n\n`zeros` and `ones` creates a matrix with the dimensions given in the argument and filled with 0 or 1.\n\n\n\n\n```{pyodide}\n#| autorun: false\nnp.zeros((3,3))\n```\n\n```{pyodide}\n#| autorun: false\nnp.ones((3,3))\n```\n\n\n\n:::\n\n\n## Array Attributes\n\nNumPy arrays have several attributes that provide information about their size, shape, and data type. These attributes are essential for understanding and debugging your code.\n\n::: {.panel-tabset}\n### shape\n\nThe `shape` attribute returns a tuple that gives the size of the array along each dimension.\n\n\n\n\n```{pyodide}\n#| autorun: false\na = np.array([[1, 2, 3], [4, 5, 6]])\na.shape\n```\n\n\n\n\n### size\n\nThe `size` attribute returns the total number of elements in the array.\n\n\n\n\n```{pyodide}\n#| autorun: false\na.size\n```\n\n\n\n\n### dtype\n\nThe `dtype` attribute returns the data type of the array's elements.\n\n\n\n\n```{pyodide}\n#| autorun: false\na.dtype\n```\n\n```{pyodide}\n#| autorun: false\nb = np.array([1.0, 2.0, 3.0])\nb.dtype\n```\n\n\n\n\nThese attributes are particularly useful when debugging operations between arrays, as many NumPy functions require arrays of specific shapes or compatible data types.\n:::\n\n## Manipulating NumPy arrays\n\n::: {.panel-tabset}\n### Slicing\n\nSlicing is the name for extracting part of an array by the syntax `M[lower:upper:step]`\n\n\n\n\n```{pyodide}\n#| autorun: false\nA = np.array([1,2,3,4,5])\nA\n```\n\n```{pyodide}\n#| autorun: false\nA[1:4]\n```\n\n\n\n\nAny of the three parameters in `M[lower:upper:step]` can be ommited.\n\n\n\n\n```{pyodide}\n#| autorun: false\nA[::] # lower, upper, step all take the default values\n```\n\n```{pyodide}\n#| autorun: false\nA[::2] # step is 2, lower and upper defaults to the beginning and end of the array\n```\n\n\n\n\nNegative indices counts from the end of the array (positive index from the begining):\n\n\n\n\n```{pyodide}\n#| autorun: false\nA = np.array([1,2,3,4,5])\n```\n\n```{pyodide}\n#| autorun: false\nA[-1] # the last element in the array\n```\n\n```{pyodide}\n#| autorun: false\nA[2:] # the last three elements\n```\n\n\n\n\nIndex slicing works exactly the same way for multidimensional arrays:\n\n\n\n\n```{pyodide}\n#| autorun: false\nA = np.array([[n+m*10 for n in range(5)] for m in range(5)])\nA\n```\n\n```{pyodide}\n#| autorun: false\n# a block from the original array\nA[1:3, 1:4]\n```\n\n\n\n\n\n::: {.callout-note}\n## Differences\n\n**Slicing** can be effectively used to calculate differences for example for the calculation of derivatives. Here the position $y_i$ of an object has been measured at times $t_i$ and stored in an array each. We wish to calculate the average velocity at the times $t_{i}$ from the arrays by\n\n\\begin{equation}\nv_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n\\end{equation}\n\n:::\n\n\n\n\n```{pyodide}\n#| autorun: false\ny = np.array([ 0. , 1.3, 5. , 10.9, 18.9, 28.7, 40. ])\nt = np.array([ 0. , 0.49, 1. , 1.5 , 2.08, 2.55, 3.2 ])\n```\n\n```{pyodide}\n#| autorun: false\nv = (y[1:]-y[:-1])/(t[1:]-t[:-1])\nv\n```\n\n\n\n\n### Reshaping\n\nArrays can be reshaped into any form, which contains the same number of elements.\n\n\n\n\n```{pyodide}\n#| autorun: false\na=np.zeros(4)\na\n```\n\n```{pyodide}\n#| autorun: false\nnp.reshape(a,(2,2))\n```\n\n\n\n\n### Adding a new dimension: newaxis\n\nWith `newaxis`, we can insert new dimensions in an array, for example converting a vector to a column or row matrix.\n\n\n\n\n```{pyodide}\n#| autorun: false\nv = np.array([1,2,3])\nv\n```\n\n```{pyodide}\n#| autorun: false\nv.shape\n```\n\n```{pyodide}\n#| autorun: false\n# make a column matrix of the vector v\nv[:, np.newaxis]\n```\n\n```{pyodide}\n#| autorun: false\n# column matrix\nv[:,np.newaxis].shape\n```\n\n```{pyodide}\n#| autorun: false\n# row matrix\nv[np.newaxis,:].shape\n```\n\n\n\n\n### Stacking and repeating arrays\n\nUsing function `repeat`, `tile`, `vstack`, `hstack`, and `concatenate` we can create larger vectors and matrices from smaller ones. Please try the individual functions yourself in your notebook. We wont discuss them in detail.\n\n#### Tile and repeat\n\n\n\n\n```{pyodide}\n#| autorun: false\na = np.array([[1, 2], [3, 4]])\na\n```\n\n```{pyodide}\n#| autorun: false\n# repeat each element 3 times\nnp.repeat(a, 3)\n```\n\n```{pyodide}\n#| autorun: false\n# tile the matrix 3 times\nnp.tile(a, 3)\n```\n\n\n\n\n#### Concatenate\n\n\n\n\n```{pyodide}\n#| autorun: false\nb = np.array([[5, 6]])\n```\n\n```{pyodide}\n#| autorun: false\nnp.concatenate((a, b), axis=0)\n```\n\n```{pyodide}\n#| autorun: false\nnp.concatenate((a, b.T), axis=1)\n```\n\n\n\n\n#### Hstack and vstack\n\n\n\n\n```{pyodide}\n#| autorun: false\nnp.vstack((a,b))\n```\n\n```{pyodide}\n#| autorun: false\nnp.hstack((a,b.T))\n```\n\n\n\n:::\n\n\n\n## Applying mathematical functions\n\nAll kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below.\n\n::: {.panel-tabset}\n### Operation involving one array\n\n\n\n\n```{pyodide}\n#| autorun: false\na=np.arange(0, 10, 1.5)\na\n```\n\n```{pyodide}\n#| autorun: false\na/2\n```\n\n```{pyodide}\n#| autorun: false\na**2\n```\n\n```{pyodide}\n#| autorun: false\n np.sin(a)\n```\n\n```{pyodide}\n#| autorun: false\nnp.exp(-a)\n```\n\n```{pyodide}\n#| autorun: false\n(a+2)/3\n```\n\n\n\n\n### Operations involving multiple arrays\n\nVector operations enable efficient element-wise calculations where corresponding elements at matching positions are processed simultaneously. Instead of handling elements one by one, these operations work on entire arrays at once, making them particularly fast. When multiplying two vectors using these operations, the result is not a single number (as in a dot product) but rather a new array where each element is the product of the corresponding elements from the input vectors. This element-wise multiplication is just one example of vector operations, which can include addition, subtraction, and other mathematical functions.\n\n\n\n\n```{pyodide}\n#| autorun: false\na = np.array([34., -12, 5.,1.2])\nb = np.array([68., 5.0, 20.,40.])\n```\n\n```{pyodide}\n#| autorun: false\na + b\n```\n\n```{pyodide}\n#| autorun: false\n2*b\n```\n\n```{pyodide}\n#| autorun: false\na*np.exp(-b)\n```\n\n```{pyodide}\n#| autorun: false\nv1=np.array([1,2,3])\nv2=np.array([4,2,3])\n```\n\n\n\n\n### Random Numbers\n\nNumPy provides powerful tools for generating random numbers, which are essential for simulations in statistical physics, quantum mechanics, and other fields:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Uniform random numbers between 0 and 1\nuniform_samples = np.random.random(5)\nprint(\"Uniform samples:\", uniform_samples)\n\n# Normal distribution (Gaussian) with mean 0 and standard deviation 1\ngaussian_samples = np.random.normal(0, 1, 5)\nprint(\"Gaussian samples:\", gaussian_samples)\n\n# Random integers\nrandom_integers = np.random.randint(1, 10, 5)  # Values between 1-9\nprint(\"Random integers:\", random_integers)\n```\n\n\n\n\nThese random number generators are particularly useful for Monte Carlo simulations, modeling thermal noise, or simulating quantum mechanical systems.\n:::\n\n## Broadcasting\n\nBroadcasting is a powerful mechanism that allows NumPy to work with arrays of different shapes when performing arithmetic operations. The smaller array is \"broadcast\" across the larger array so that they have compatible shapes.\n\nThe rules for broadcasting are:\n\n1. If the arrays don't have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length.\n2. The size in each dimension of the output shape is the maximum of the sizes of the input arrays along that dimension.\n3. An input can be used in the calculation if its size in a particular dimension matches the output size or if its value is exactly 1.\n4. If an input has a dimension size of 1, the first element is used for all calculations along that dimension.\n\nLet's see some examples:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Broadcasting a scalar to an array\na = np.array([1, 2, 3])\na * 2  # 2 is broadcast to [2, 2, 2]\n```\n\n```{pyodide}\n#| autorun: false\n# Broadcasting arrays of different shapes\na = np.array([[1, 2, 3], [4, 5, 6]])  # Shape: (2, 3)\nb = np.array([10, 20, 30])  # Shape: (3,)\na + b  # b is broadcast to shape (2, 3)\n```\n\n```{pyodide}\n#| autorun: false\n# A more complex example\na = np.ones((3, 4))\nb = np.arange(4)\na + b  # b is broadcast across each row of a\n```\n\n\n\n\nBroadcasting enables efficient computation without the need to create copies of arrays, saving memory and computation time.\n\n## Physics Example: Force Calculations\n\nBroadcasting is particularly useful in physics when applying the same operation to multiple objects. For example, when calculating the gravitational force between one massive object and multiple other objects using Newton's law of universal gravitation:\n\n\\begin{equation}\nF = \\frac{G M m}{r^2}\n\\end{equation}\n\nwhere $F$ is the gravitational force, $G$ is the gravitational constant, $M$ and $m$ are the masses of the two objects, and $r$ is the distance between them.\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Gravitational constant\nG = 6.67430e-11\n\n# Mass of central object (e.g., Sun) in kg\nM = 1.989e30\n\n# Masses of planets in kg (simplified)\nplanet_masses = np.array([3.3e23, 4.87e24, 5.97e24, 6.42e23])  # Mercury, Venus, Earth, Mars\n\n# Distances from Sun in meters (simplified)\ndistances = np.array([5.79e10, 1.08e11, 1.5e11, 2.28e11])\n\n# Calculate gravitational forces\n# F = G*M*m/r²\nforces = G * M * planet_masses / distances**2\n\nprint(forces)  # Force in Newtons\n```\n\n",
    "supporting": [
      "02-lecture03_files"
    ],
    "filters": [],
    "includes": {}
  }
}