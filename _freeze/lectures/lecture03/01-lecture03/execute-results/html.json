{
  "hash": "a49fb228e732122b206e0fa163408564",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Modules\"\nformat:\n  live-html:\n    toc: true\n    toc-location: right\npyodide:\n  autorun: false\n  packages:\n    - matplotlib\n    - numpy\n---\n\nMost of the functionality in Python is provided by *modules*. The Python Standard Library is a large collection of modules that provides *cross-platform* implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\n\nTo use a module in a Python program it first has to be imported. A module can be imported using the `import` statement. For example, to import the module `math`, which contains many standard mathematical functions, we can do:\n\n```{pyodide}\n#| autorun: false\nimport math\n\nx = math.sqrt(2 * math.pi)\n\nprint(x)\n```\n\nThis includes the whole module and makes it available for use later in the program. Note that the functions of the module are accessed using the prefix `math.`, which is the namespace for the module.\n\nAlternatively, we can chose to import all symbols (functions and variables) in a module so that we don't need to use the prefix \"`math.`\" every time we use something from the `math` module:\n\n```{pyodide}\n#| autorun: false\nfrom math import *\n\nx = cos(2 * pi)\n\nprint(x)\n```\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the `import math` pattern. This would eliminate potentially confusing problems.\n\n### Namespaces\n\n::: {.callout-note  title=\"Namespaces\"}\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix `math.` we have used in the previous section is such a namespace. You may also create your own namespace for a module. This is done by using the `import math as mymath` pattern.\n:::\n\n```{pyodide}\n#| autorun: false\nimport math as m\n\nx = m.sqrt(2)\n\nprint(x)\n```\n\nYou may also only import specific functions of a module.\n\n```{pyodide}\n#| autorun: false\nfrom math import sinh as mysinh\n```\n\n### Directory of a module\n\nOnce a module is imported, we can list the symbols it provides using the `dir` function:\n\n```{pyodide}\n#| autorun: false\nimport math\n\nprint(dir(math))\n```\n\nAnd using the function `help` we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n```{pyodide}\n#| autorun: false\n\nhelp(math.log)\n```\n\n```{pyodide}\n#| autorun: false\nmath.log(10)\n```\n\n```{pyodide}\n#| autorun: false\nmath.log(8, 2)\n```\n\nWe can also use the `help` function directly on modules: Try\n\n    help(math)\n\nSome very useful modules from the Python standard library are `os`, `sys`, `math`, `shutil`, `re`, `subprocess`, `multiprocessing`, `threading`.\n\nA complete lists of standard modules for Python 3 is available at [the python website](http://docs.python.org/3/library/) .\n\n\n### Advanced topics\n\n::: {.callout-note  title=\"Create Your Own Modules\" collapse=true}\nCreating your own modules in Python is a great way to organize your code and make it reusable. A module is simply a file containing Python definitions and statements. Here's how you can create and use your own module:\n\n#### Creating a Module\n\nTo create a module, you just need to save your Python code in a file with a `.py` extension. For example, let's create a module named `mymodule.py` with the following content:\n\n```python\n# mymodule.py\n\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -> int:\n    return a + b\n```\n\n#### Using Your Module\n\nOnce you have created your module, you can import it into other Python scripts using the `import` statement. Here's an example of how to use the `mymodule` we just created:\n\n```python\n# main.py\n\nimport mymodule\n\n# Use the functions from mymodule\nprint(mymodule.greet(\"Alice\"))\nprint(mymodule.add(5, 3))\n```\n\n#### Importing Specific Functions\n\nYou can also import specific functions from a module using the `from ... import ...` syntax:\n\n```python\n# main.py\n\nfrom mymodule import greet, add\n\n# Use the imported functions directly\nprint(greet(\"Bob\"))\nprint(add(10, 7))\n```\n\n#### Module Search Path\n\nWhen you import a module, Python searches for the module in the following locations:\n1. The directory containing the input script (or the current directory if no script is specified).\n2. The directories listed in the `PYTHONPATH` environment variable.\n3. The default directory where Python is installed.\n\nYou can view the module search path by printing the `sys.path` variable:\n\n```python\nimport sys\nprint(sys.path)\n```\n\n#### Creating Packages\n\nA package is a way of organizing related modules into a directory hierarchy. A package is simply a directory that contains a special file named `__init__.py`, which can be empty. Here's an example of how to create a package:\n\n```\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\n```\n\nYou can then import modules from the package using the dot notation:\n\n```python\n# main.py\n\nfrom mypackage import module1, module2\n\n# Use the functions from the modules\nprint(module1.some_function())\nprint(module2.another_function())\n```\n\nCreating and using modules and packages in Python helps you organize your code better and makes it easier to maintain and reuse.\n\n#### Namespaces in Packages\n\nYou can also create sub-packages by adding more directories with `__init__.py` files. This allows you to create a hierarchical structure for your modules:\n\n```\nmypackage/\n    __init__.py\n    subpackage/\n        __init__.py\n        submodule.py\n```\n\nYou can then import submodules using the full package name:\n\n```python\n# main.py\n\nfrom mypackage.subpackage import submodule\n\n# Use the functions from the submodule\nprint(submodule.some_sub_function())\n```\n:::\n\n",
    "supporting": [
      "01-lecture03_files"
    ],
    "filters": [],
    "includes": {}
  }
}