{
  "hash": "7b176d4738a81e83ea3d7bb0b4d8d6d9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Basic Plotting with Matplotlib\"\nformat: live-html\npyodide:\n  autorun: true\n  packages:\n    - matplotlib\n    - numpy\n---\n\nData visualization is an essential skill for analyzing and presenting scientific data effectively. Python itself doesn't include plotting capabilities in its core language, but Matplotlib provides powerful and flexible tools for creating visualizations. [Matplotlib](https://matplotlib.org/stable/index.html) is the most widely used plotting library in Python and serves as an excellent starting point for creating basic plots.\n\nMatplotlib works well with NumPy, Python's numerical computing library, to create a variety of plot types including line plots, scatter plots, bar charts, and more. For this document, we've already imported both libraries as you can see in the code below:\n\n```{pyodide}\n#| autorun: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n\nWe've also set up some default styling parameters to make our plots more readable and professional-looking:\n\n```{pyodide}\n#| autorun: true\n\nplt.rcParams.update({'font.size': 12,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 11,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',\n                     'figure.figsize': (4, 3),\n                     'figure.dpi': 150})\n\ndef get_size(w,h):\n      return((w/2.54,h/2.54))\n```\n\nThese settings configure the appearance of our plots with appropriate font sizes, line widths, and tick marks. The `get_size()` function helps us convert dimensions from centimeters to inches, which is useful when specifying figure sizes. With these preparations complete, we're ready to create various types of visualizations to effectively display our data.\n\nMatplotlib offers multiple levels of functionality for creating plots. Throughout this section, we'll primarily focus on using commands that leverage default settings. This approach simplifies the process, as Matplotlib automatically handles much of the graph layout. These high-level commands are ideal for quickly creating effective visualizations without delving into intricate details. Later in this course, we'll briefly touch upon more advanced techniques that provide greater control over plot elements and layout.\n\n## Basic Plotting\n\nTo create a basic line plot, use the following command:\n\n```python\nplt.plot(x, y)\n```\n\nBy default, this generates a line plot. However, you can customize the appearance by adjusting various parameters within the `plot()` function. For instance, you can modify it to resemble a scatter plot by changing certain arguments. The versatility of this command allows for a range of visual representations beyond simple line plots.\n\nLet's create a simple line plot of the sine function over the interval $[0, 4\\pi]$. We'll use NumPy to generate the x-values and calculate the corresponding y-values. The following code snippet demonstrates this process:\n\n```python\nx = np.linspace(0, 4.*np.pi, 100)       #<1>\ny = np.sin(x)     #<2>\n\nplt.figure(figsize=get_size(8,6))      #<3>\nplt.plot(x, y)        #<4>\nplt.tight_layout()          #<5>\nplt.show()          #<6>\n```\n1. Create an array of 100 values between 0 and 4$\\pi$.\n2. Calculate the sine of each value in the array.\n3. create a new figure with a size of (8,6) cm\n4. plot the data\n5. automatically adjust the layout\n6. show the figure\n\nHere is the code in a Python cell:\n\n```{pyodide}\n#| autorun: true\n\nx = np.linspace(0, 4.*np.pi, 100)\ny = np.sin(x)\n\nplt.figure(figsize=get_size(8,6))\nplt.plot(x, y)\nplt.tight_layout()\nplt.show()\n```\n\nTry to change the values of the `x` and `y` arrays and see how the plot changes.\n\n::: {.callout-tip title=\"Why use plt.tight_layout()\" collapse=true}\n\n`plt.tight_layout()` is a very useful function in Matplotlib that automatically adjusts the spacing between plot elements to prevent overlapping and ensure that all elements fit within the figure area. Here's what it does:\n\n1. Padding Adjustment: It adjusts the padding between and around subplots to prevent overlapping of axis labels, titles, and other elements.\n\n2. Subplot Spacing: It optimizes the space between multiple subplots in a figure.\n\n3. Text Accommodation: It ensures that all text elements (like titles, labels, and legends) fit within the figure without being cut off.\n\n4. Margin Adjustment: It adjusts the margins around the entire figure to make sure everything fits neatly.\n\n5. Automatic Resizing: If necessary, it can slightly resize subplot areas to accommodate all elements.\n\n6. Legend Positioning: It takes into account the presence and position of legends when adjusting layouts.\n\nKey benefits of using `plt.tight_layout()`:\n\n- It saves time in manual adjustment of plot elements.\n- It helps create more professional-looking and readable plots.\n- It's particularly useful when creating figures with multiple subplots or when saving figures to files.\n\nYou typically call `plt.tight_layout()` just before `plt.show()` or `plt.savefig()`. For example:\n\n```python\nplt.figure()\n# ... (your plotting code here)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n## Customizing Plots\n\n::: {.panel-tabset}\n### Axis Labels\n\nTo enhance the clarity and interpretability of our plots, it's crucial to provide context through proper labeling. The following commands add descriptive axis labels to our diagram:\n\n```python\nplt.xlabel('x-label')\nplt.ylabel('y-label')\n```\n\nHere's an example of adding labels to our sine plot:\n\n```{pyodide}\n#| autorun: false\n\nx = np.linspace(0, 4.*np.pi, 100)\ny = np.sin(x)\n\nplt.figure(figsize=get_size(8,6))\nplt.plot(x, y)\nplt.xlabel('t')                # set the x-axis label\nplt.ylabel('sin(t)')           # set the y-axis label\nplt.tight_layout()\nplt.show()\n```\n\n### Legends\n\nWhen plotting multiple datasets, it's important to include a legend to identify each line. Use these commands:\n\n```python\nplt.plot(..., label='Label name')\nplt.legend(loc='lower left')\n```\n\nHere's an example with a legend:\n\n```{pyodide}\n#| autorun: false\n\nx = np.linspace(0, 4.*np.pi, 100)\n\nplt.figure(figsize=get_size(8,6))\nplt.plot(x, np.sin(x), \"ko\", markersize=5, label=r\"$\\delta(t)$\")   # define a label\nplt.xlabel('t')\nplt.ylabel(r'$\\sin(t)$')\nplt.legend(loc='lower left')                                        # add the legend\nplt.tight_layout()\nplt.show()\n```\n\n\n### Plotting Multiple Lines\n\nYou can add multiple lines to the same plot:\n\n```{pyodide}\n#| autorun: false\nx = np.linspace(0, 2*np.pi, 100)\n\nplt.figure(figsize=get_size(8, 8))\nplt.plot(x, np.sin(x), label='sin(x)')         # Add a label for the legend\nplt.plot(x, np.cos(x), label='cos(x)')         # Second line\nplt.plot(x, np.sin(2*x), label='sin(2x)')      # Third line\nplt.legend()                                    # Display the legend\nplt.title('Trigonometric Functions')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.tight_layout()\nplt.show()\n```\n\n### Customizing Line Appearance\n\nYou can customize the appearance of lines with additional parameters:\n\n```{pyodide}\n#| autorun: false\nx = np.linspace(0, 2*np.pi, 100)\n\nplt.figure(figsize=get_size(14, 8))\n# Format string: color, marker, line style\nplt.plot(x, np.sin(x), 'r-', label='sin(x)')      # Red solid line\nplt.plot(x, np.cos(x), 'b--', label='cos(x)')     # Blue dashed line\nplt.plot(x, np.sin(2*x), 'g.', label='sin(2x)')   # Green dots\nplt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')  # Place legend outside plot\nplt.xlabel('x')\nplt.ylabel('y')\nplt.subplots_adjust(right=0.8)  # Add space for the legend\nplt.tight_layout()\n\nplt.show()\n```\n### Plots with Error Bars\n\nWhen plotting experimental data, it's customary to include error bars that graphically indicate measurement uncertainty. The `errorbar` function can be used to display both vertical and horizontal error bars:\n\n```python\nplt.errorbar(x, y, xerr=x_errors, yerr=y_errors, fmt='format', label='label')\n```\n\nHere's an example of a plot with error bars:\n\n```{pyodide}\n#| autorun: false\n\nxdata = np.arange(0.5, 3.5, 0.5)\nydata = 210-40/xdata\nyerror = 2e3/ydata\n\nplt.figure(figsize=get_size(8,6))\nplt.errorbar(xdata, ydata, fmt=\"ro\", label=\"data\",\n             xerr=0.15, yerr=yerror, ecolor=\"black\")\nplt.xlabel(\"x\")\nplt.ylabel(\"t-displacement\")\nplt.legend(loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n```\n\n### Visualizing NumPy Arrays\n\nWe can visualize 2D arrays created with NumPy:\n\n```{pyodide}\n#| autorun: false\n# Create a 2D array using mgrid\nx, y = np.mgrid[0:5:0.1, 0:5:0.1]\nz = np.sin(x) * np.cos(y)\n\nplt.figure(figsize=get_size(12, 8))\nplt.pcolormesh(x, y, z, cmap='viridis',edgecolors=\"none\")  # Color mesh plot\nplt.colorbar(label='sin(x)cos(y)')      # Add color scale\nplt.xlabel('x')\nplt.ylabel('y')\nplt.tight_layout()\nplt.show()\n```\n\n:::\n\n\n\n## Saving Figures\n\nTo save a figure to a file, use the `savefig` method. Matplotlib supports multiple formats including PNG, JPG, EPS, SVG, PGF and PDF:\n\n```python\nplt.savefig('filename.extension')\n```\n\nHere's an example of creating and saving a figure:\n\n```{pyodide}\n#| autorun: false\n\ntheta = np.linspace(0.01, 10., 100)\nytan = np.sin(2*theta) + np.cos(3.1*theta)\n\nplt.figure(figsize=get_size(8,6))\nplt.plot(theta, ytan)\nplt.xlabel(r'$\\theta$')\nplt.ylabel('y')\nplt.tight_layout()\nplt.savefig('filename.pdf')    # save figure before showing it\nplt.show()\n```\n\nFor scientific papers, PDF format is recommended whenever possible. LaTeX documents compiled with `pdflatex` can include PDFs using the `includegraphics` command. PGF can also be a good alternative in some cases.\n\n\n\n## NumPy with Visualization\n\nThe arrays and calculations we've learned in NumPy form the foundation for scientific data visualization. In the next section, we'll explore how to use Matplotlib to create visual representations of NumPy arrays, allowing us to interpret and communicate our physics results more effectively.\n\nFor example, we can visualize the planetary force calculations from our broadcasting example:\n\n```{pyodide}\n#| autorun: false\n\n# Planet names for our example\nplanets = ['Mercury', 'Venus', 'Earth', 'Mars']\n\n# Calculate gravitational forces (code from previous example)\nG = 6.67430e-11\nM = 1.989e30\nplanet_masses = np.array([3.3e23, 4.87e24, 5.97e24, 6.42e23])\ndistances = np.array([5.79e10, 1.08e11, 1.5e11, 2.28e11])\nforces = G * M * planet_masses / distances**2\n\n# Plotting\nplt.figure(figsize=get_size(8, 8))\nplt.bar(planets, forces)\nplt.ylabel('Gravitational Force (N)')\n#plt.title('Gravitational Force from Sun to Planets')\nplt.tight_layout()\nplt.show()\n```\n\n",
    "supporting": [
      "03-lecture03_files"
    ],
    "filters": [],
    "includes": {}
  }
}