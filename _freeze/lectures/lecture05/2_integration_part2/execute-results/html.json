{
  "hash": "90a43369beca0a23355e331248a9772c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Advanced Topics in Numerical Integration\n---\n\n\n\n### Adaptive Integration Methods\n\nThe methods we've discussed so far use equal spacing between sampling points. However, most real-world physics problems involve functions that vary dramatically across the integration range. Adaptive methods adjust the point distribution to concentrate more points where the function changes rapidly.\n\n```{pyodide}\n# Simple demonstration of adaptive integration concept\ndef adaptive_demo(f, a, b, tol=1e-5, max_depth=10):\n    \"\"\"Simple demonstration of adaptive integration concept\"\"\"\n    def recursive_integrate(a, b, depth=0):\n        # Compute midpoint\n        c = (a + b) / 2\n        \n        # Estimate integral using Simpson's rule on entire interval\n        I_whole = (b-a)/6 * (f(a) + 4*f(c) + f(b))\n        \n        # Estimate integral using Simpson's rule on each half\n        mid1 = (a + c) / 2\n        mid2 = (c + b) / 2\n        I_left = (c-a)/6 * (f(a) + 4*f(mid1) + f(c))\n        I_right = (b-c)/6 * (f(c) + 4*f(mid2) + f(b))\n        I_parts = I_left + I_right\n        \n        # Check error\n        error = abs(I_whole - I_parts)\n        \n        # If error is small enough or max depth reached, return result\n        if error < tol*(b-a) or depth >= max_depth:\n            return I_parts, [(a, c, b, error)]\n        \n        # Otherwise, recursively integrate each half\n        I_left_result, left_regions = recursive_integrate(a, c, depth+1)\n        I_right_result, right_regions = recursive_integrate(c, b, depth+1)\n        \n        return I_left_result + I_right_result, left_regions + right_regions\n    \n    integral, regions = recursive_integrate(a, b)\n    return integral, regions\n\n# Define a challenging function with a sharp peak\ndef challenging_func(x):\n    \"\"\"Function with a sharp peak at x=0.7\"\"\"\n    return 1 / (0.01 + (x - 0.7)**2)\n\n# Calculate integral using adaptive and non-adaptive methods\na, b = 0, 1\nn_points = 101  # Use a fixed number of points for non-adaptive methods\n\n# Calculate using non-adaptive methods\nbox_result = int_box(challenging_func, a, b, n_points)\ntrap_result = int_trap(challenging_func, a, b, n_points)\nsimp_result = int_simp(challenging_func, a, b, n_points)\n\n# Calculate using adaptive method\nadaptive_result, regions = adaptive_demo(challenging_func, a, b)\n\n# Calculate a reference solution using a very high number of points\nreference = int_simp(challenging_func, a, b, 10001)\n\n# Visualize the function and integration points\nx_fine = np.linspace(a, b, 1000)\ny_fine = [challenging_func(x) for x in x_fine]\n\nplt.figure(figsize=get_size(15, 10))\n\n# Plot the function\nplt.plot(x_fine, y_fine, 'k-', label='f(x)')\n\n# Plot the adaptive integration regions\nfor region in regions:\n    a_r, m_r, b_r, error = region\n    plt.plot([a_r, m_r, b_r], [challenging_func(a_r), challenging_func(m_r), challenging_func(b_r)], \n             'ro-', alpha=0.5)\n\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.title('Adaptive Integration Demonstration')\nplt.grid(True)\n\n# Adjust y-axis to show the function's behavior more clearly\nplt.ylim(0, 40)\n\nplt.legend()\nplt.show()\n\n# Show results\nprint(\"Results for integrating a function with a sharp peak:\")\nprint(f\"Box Method (n={n_points}): {box_result:.8f}, Error: {abs(box_result-reference):.8f}\")\nprint(f\"Trapezoid Method (n={n_points}): {trap_result:.8f}, Error: {abs(trap_result-reference):.8f}\")\nprint(f\"Simpson's Method (n={n_points}): {simp_result:.8f}, Error: {abs(simp_result-reference):.8f}\")\nprint(f\"Adaptive Method: {adaptive_result:.8f}, Error: {abs(adaptive_result-reference):.8f}\")\nprint(f\"Reference value: {reference:.8f}\")\nprint(f\"Number of adaptive regions: {len(regions)}\")\n```\n\n### Multi-dimensional Integration\n\nMany physics problems require integration over multiple dimensions, such as calculating mass moments of inertia, electric fields from volume charge distributions, or statistical mechanics partition functions.\n\nFor 2D integration, we can extend our 1D methods using the concept of iterated integrals:\n\n\\begin{equation}\n\\int_{a}^{b}\\int_{c}^{d} f(x,y) dy dx \\approx \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} w_i w_j f(x_i, y_j)\n\\end{equation}\n\nWhere $w_i$ and $w_j$ are the weights for the respective 1D methods.\n\n```{pyodide}\ndef int_2d_trap(f, x_range, y_range, nx, ny):\n    \"\"\"2D integration using the Trapezoid method\"\"\"\n    x = np.linspace(x_range[0], x_range[1], nx)\n    y = np.linspace(y_range[0], y_range[1], ny)\n    dx = (x_range[1] - x_range[0]) / (nx - 1)\n    dy = (y_range[1] - y_range[0]) / (ny - 1)\n    \n    result = 0\n    for i in range(nx-1):\n        for j in range(ny-1):\n            # Average of function values at the four corners of each cell\n            f_values = [\n                f(x[i], y[j]),\n                f(x[i+1], y[j]),\n                f(x[i], y[j+1]),\n                f(x[i+1], y[j+1])\n            ]\n            result += sum(f_values) / 4 * dx * dy\n    \n    return result\n\n# Example: Electric potential from a square charge distribution\ndef potential_2d(x, y, z=1):\n    \"\"\"Electric potential at (x,y,z) from a square charge distribution in the x-y plane\"\"\"\n    # Avoid division by zero\n    denominator = (x**2 + y**2 + z**2)**0.5\n    if denominator < 1e-10:\n        return 0\n    return 1 / denominator\n\n# Calculate the electric potential at a point above a charged square\nz = 1.0  # height above the plane\npotential = int_2d_trap(lambda x, y: potential_2d(x, y, z), [-1, 1], [-1, 1], 51, 51)\n\n# Visualize the potential in the plane above the charge\nx_vals = np.linspace(-2, 2, 50)\ny_vals = np.linspace(-2, 2, 50)\nX, Y = np.meshgrid(x_vals, y_vals)\nZ = np.zeros_like(X)\n\nfor i in range(len(x_vals)):\n    for j in range(len(y_vals)):\n        Z[j, i] = potential_2d(X[j, i], Y[j, i], z)\n\nplt.figure(figsize=get_size(15, 10))\n\n# Plot the potential as a contour\ncontour = plt.contourf(X, Y, Z, 50, cmap='viridis')\nplt.colorbar(label='Electric Potential')\n\n# Mark the square charge distribution\nplt.plot([-1, 1, 1, -1, -1], [-1, -1, 1, 1, -1], 'r-', linewidth=2)\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title(f'Electric Potential at z={z} from a Square Charge Distribution')\nplt.axis('equal')\nplt.grid(True)\nplt.show()\n\nprint(f\"Electric potential at point (0,0,{z}): {potential:.6f}\")\nprint(f\"Analytical value at center: {np.log(1 + np.sqrt(2)):.6f}\")\n```\n\n### Monte Carlo Integration\n\nFor higher-dimensional integrals and complex domains, Monte Carlo methods become increasingly efficient. These methods use random sampling to approximate integrals and are particularly valuable in quantum and statistical physics.\n\n```{pyodide}\ndef monte_carlo_integrate(f, ranges, n_samples):\n    \"\"\"Monte Carlo integration in arbitrary dimensions\"\"\"\n    # Generate random samples within the integration domain\n    dim = len(ranges)\n    samples = np.random.uniform(\n        low=[r[0] for r in ranges],\n        high=[r[1] for r in ranges],\n        size=(n_samples, dim)\n    )\n    \n    # Evaluate function at sample points\n    f_values = np.array([f(*sample) for sample in samples])\n    \n    # Calculate volume of integration domain\n    volume = np.prod([r[1] - r[0] for r in ranges])\n    \n    # Estimate integral and error\n    integral = volume * np.mean(f_values)\n    error = volume * np.std(f_values) / np.sqrt(n_samples)\n    \n    return integral, error\n\n# Example: Calculate the volume of a n-dimensional hypersphere\ndef sphere_indicator(x, y, z):\n    \"\"\"Return 1 if point is inside unit sphere, 0 otherwise\"\"\"\n    return 1 if x**2 + y**2 + z**2 <= 1 else 0\n\n# Calculate the volume of a 3D sphere using Monte Carlo\nn_samples = 100000\nranges = [[-1, 1], [-1, 1], [-1, 1]]  # Cube containing the sphere\nvolume, error = monte_carlo_integrate(sphere_indicator, ranges, n_samples)\n\n# The exact volume of a unit sphere in 3D is (4/3)π\nexact_volume = 4/3 * np.pi\n\n# Visualize the convergence\nsample_sizes = np.logspace(2, 5, 20, dtype=int)\nvolumes = []\nerrors = []\n\nfor n in sample_sizes:\n    v, e = monte_carlo_integrate(sphere_indicator, ranges, n)\n    volumes.append(v)\n    errors.append(e)\n\nplt.figure(figsize=get_size(15, 10))\nplt.semilogx(sample_sizes, volumes, 'o-', label='Monte Carlo estimate')\nplt.fill_between(\n    sample_sizes, \n    [v - e for v, e in zip(volumes, errors)], \n    [v + e for v, e in zip(volumes, errors)],\n    alpha=0.3\n)\nplt.axhline(exact_volume, color='r', linestyle='--', label='Exact value')\nplt.xlabel('Number of samples')\nplt.ylabel('Volume of unit sphere')\nplt.title('Monte Carlo Integration Convergence')\nplt.grid(True)\nplt.legend()\nplt.show()\n\nprint(f\"Volume of unit sphere (Monte Carlo with {n_samples} samples): {volume:.6f} ± {error:.6f}\")\nprint(f\"Exact volume of unit sphere: {exact_volume:.6f}\")\nprint(f\"Relative error: {abs(volume - exact_volume)/exact_volume*100:.4f}%\")\n```\n\n### Application to Real Physics Problems\n\nLet's examine two common scenarios in physics that benefit from numerical integration:\n\n1. **Non-uniform Magnetic Field**: When a charged particle moves through a non-uniform magnetic field, the work done can be calculated as:\n\n   $$W = q\\int_{\\vec{r}_1}^{\\vec{r}_2} \\vec{v} \\times \\vec{B}(\\vec{r}) \\cdot d\\vec{r}$$\n\n2. **Quantum Tunneling**: The tunneling probability through a potential barrier is given by:\n\n   $$T \\approx \\exp\\left(-\\frac{2}{\\hbar}\\int_{x_1}^{x_2} \\sqrt{2m(V(x) - E)}\\, dx\\right)$$\n\nIn both cases, the integrals frequently cannot be solved analytically due to the complex spatial dependence of the fields or potentials, making numerical integration indispensable for modern physics.\n\n\n",
    "supporting": [
      "2_integration_part2_files"
    ],
    "filters": [],
    "includes": {}
  }
}