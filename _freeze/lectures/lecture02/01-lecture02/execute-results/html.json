{
  "hash": "e65e07213584f6fcd39399c02138c702",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Data Types\nformat:\n  live-html:\n    toc: true\n    toc-location: right\npyodide:\n  packages:\n    - numpy\n---\n\n\n\n\nIt's time to look at different data types we may find useful in our course. Besides the number types mentioned previously, there are also other types like **strings**, **lists**, **tuples**, **dictionaries** and **sets**.\n\n| Data Types | Classes | Description |\n| :--- | :--- | :--- |\n| Numeric | int, float, complex | Holds numeric values |\n| String | str | Stores sequence of characters |\n| Sequence | list, tuple, range | Stores ordered collection of items |\n| Mapping | dict | Stores data as key-value pairs |\n| Boolean | bool | Holds either True or False |\n| Set | set, frozenset | Holds collection of unique items |\n\n\nEach of these data types has a number of connected `methods` (functions) which allow you to manipulate the data contained in a variable. If you want to know which methods are available for a certain object use the command `dir`, e.g.\n\n```\ns = \"string\"\ndir(s)\n```\n\nThe output would be:\n\n```\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__',\n'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',\n'__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__',\n'__init_subclass__', '__iter__', '__le__', '__len__', '__lt__',\n'__mod__', '__mul__', '__ne__', '__new__', '__reduce__',\n'__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__',\n'__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold',\n'center', 'count', 'encode', 'endswith', 'expandtabs', 'find',\n'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii',\n'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric',\n'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust',\n'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix',\n'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition',\n'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',\n'swapcase', 'title', 'translate', 'upper', 'zfill']\n```\n\n\n\n\n\n```{pyodide}\n#| autorun: false\ns = \"string\"\ndir(s)\n```\n\n\n\n\n\nThe following few cells will give you a short introduction into each type.\n\n## Data Types\n\n\n::: {.panel-tabset}\n### Numeric Types\n\nPython supports several numeric data types including **integers**, **floats**, and **complex** numbers.\n\n\n\n\n```{pyodide}\n#| autorun: false\n\nx = 10      # integer\ny = 3.14    # float\nz = 2+3j    # complex number\n\ntype(x), type(y), type(z)\n```\n\n\n\n\nYou can perform various arithmetic operations with numeric types:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Basic arithmetic\nprint(x + y)  # Addition\nprint(x - y)  # Subtraction\nprint(x * y)  # Multiplication\nprint(x / y)  # Division\n```\n\n\n\n\nType conversion works between numeric types:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Converting between numeric types\nint_num = int(3.9)    # Truncates to 3\nfloat_num = float(5)  # Converts to 5.0\n\nprint(int_num, float_num)\n```\n\n\n\n\n\n\n### Strings\n\n**Strings** are lists of keyboard characters as well as other characters not on your keyboard. They are useful for printing results on the screen, during reading and writing of data.\n\n\n\n\n```{pyodide}\n#| autorun: false\ns=\"Hello\" # string variable\ntype(s)\n```\n\n```{pyodide}\n#| autorun: false\nt=\"world!\"\n```\n\n\n\n\nString can be concatenated using the *+* operator.\n\n\n\n\n```{pyodide}\n#| autorun: false\nc=s+' '+t\n```\n\n```{pyodide}\n#| autorun: false\nprint(c)\n```\n\n\n\n\nAs strings are lists, each character in a string can be accessed by addressing the position in the string (see Lists section)\n\n\n\n\n```{pyodide}\n#| autorun: false\nc[1]\n```\n\n\n\n\nStrings can also be made out of numbers.\n\n\n\n\n```{pyodide}\n#| autorun: false\n\"975\"+\"321\"\n```\n\n\n\n\nIf you want to obtain a number of a string, you can use what is known as type casting. Using type casting you may convert the string or any other data type into a different type if this is possible. To find out if a string is a pure number you may use the `str.isnumeric` method. For the above string, we may want to do a conversion to the type *int* by typing:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# you may use as well str.isnumeric(\"975\"+\"321\")\n(\"975\"+\"321\").isnumeric()\n```\n\n```{pyodide}\n#| autorun: false\nint(\"975\"+\"321\")\n```\n\n\n\n\nThere are a number of methods connected to the string data type. Usually the relate to formatting or finding sub-strings. Formatting will be a topic in our next lecture. Here we just refer to one simple find example.\n\n\n\n\n```{pyodide}\n#| autorun: false\nt\n```\n\n```{pyodide}\n#| autorun: false\nt.find('rld') ## returns the index at which the sub string 'ld' starts in t\n```\n\n```{pyodide}\n#| autorun: false\nt[2:5]\n```\n\n```{pyodide}\n#| autorun: false\nt.capitalize()\n```\n\n\n\n\n### Lists\n\n**Lists** are ordered, mutable collections that can store items of different data types.\n\n\n\n\n```{pyodide}\n#| autorun: false\nmy_list = [1, 2.5, \"hello\", True]\nprint(type(my_list))\nprint(my_list)\n```\n\n\n\n\nYou can access and modify list elements:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Accessing elements\nprint(my_list[0])       # First element\nprint(my_list[-1])      # Last element\nprint(my_list[1:3])     # Slicing\n\n# Modifying elements\nmy_list[0] = 100\nprint(my_list)\n\n# Adding elements\nmy_list.append(\"new item\")\nprint(my_list)\n```\n\n\n\n\nCommon list methods:\n\n\n\n\n```{pyodide}\n#| autorun: false\nsample_list = [3, 1, 4, 1, 5, 9]\n\nsample_list.sort()    # Sort the list in-place\nprint(sample_list)\n\nsample_list.reverse() # Reverse the list in-place\nprint(sample_list)\n\nprint(len(sample_list))  # Get the length of the list\n```\n\n\n\n\n### Tuples\n\n**Tuples** are ordered, immutable sequences.\n\n\n\n\n```{pyodide}\n#| autorun: false\nmy_tuple = (1, 2, \"three\", 4.0)\nprint(type(my_tuple))\nprint(my_tuple)\n```\n\n\n\n\nTuples are immutable, meaning you cannot change their elements after creation:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Accessing tuple elements\nprint(my_tuple[0])\nprint(my_tuple[-1])\nprint(my_tuple[1:3])\n\n# This would cause an error\n# my_tuple[0] = 100  # TypeError: 'tuple' object does not support item assignment\n```\n\n\n\n\n### Dictionaries\n\n**Dictionaries** store data as key-value pairs. They are mutable and unordered.\n\n\n\n\n```{pyodide}\n#| autorun: false\nstudent = {\n    \"name\": \"Alice\",\n    \"age\": 21,\n    \"courses\": [\"Math\", \"Physics\", \"Computer Science\"],\n    \"active\": True\n}\n\nprint(type(student))\nprint(student)\n```\n\n\n\n\nAccessing and modifying dictionary elements:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Accessing values\nprint(student[\"name\"])\nprint(student.get(\"age\"))  # Safer method if key might not exist\n\n# Modifying values\nstudent[\"age\"] = 22\nprint(student)\n\n# Adding new key-value pair\nstudent[\"graduation_year\"] = 2023\nprint(student)\n\n# Removing key-value pair\ndel student[\"active\"]\nprint(student)\n```\n\n\n\n\nCommon dictionary methods:\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Get all keys and values\nprint(student.keys())\nprint(student.values())\nprint(student.items())  # Returns key-value pairs as tuples\n```\n\n\n\n\n### Boolean\n\nThe **Boolean** type has only two possible values: `True` and `False`.\n\n\n\n\n```{pyodide}\n#| autorun: false\nx = True\ny = False\nprint(type(x), x)\nprint(type(y), y)\n```\n\n\n\n\nBoolean values are commonly used in conditional statements:\n\n\n\n\n```{pyodide}\n#| autorun: false\nage = 20\nis_adult = age >= 18\nprint(is_adult)\n\nif is_adult:\n    print(\"Person is an adult\")\nelse:\n    print(\"Person is a minor\")\n```\n\n\n\n\nBoolean operations:\n\n\n\n\n```{pyodide}\n#| autorun: false\na = True\nb = False\n\nprint(a and b)  # Logical AND\nprint(a or b)   # Logical OR\nprint(not a)    # Logical NOT\n```\n\n\n\n\n### Sets\n\n**Sets** are unordered collections of unique elements.\n\n\n\n\n```{pyodide}\n#| autorun: false\nmy_set = {1, 2, 3, 4, 5}\nprint(type(my_set))\nprint(my_set)\n\n# Duplicates are automatically removed\nduplicate_set = {1, 2, 2, 3, 4, 4, 5}\nprint(duplicate_set)  # Still {1, 2, 3, 4, 5}\n```\n\n\n\n\nCommon set operations:\n\n\n\n\n```{pyodide}\n#| autorun: false\nset_a = {1, 2, 3, 4, 5}\nset_b = {4, 5, 6, 7, 8}\n\n# Union\nprint(set_a | set_b)  # or set_a.union(set_b)\n\n# Intersection\nprint(set_a & set_b)  # or set_a.intersection(set_b)\n\n# Difference\nprint(set_a - set_b)  # or set_a.difference(set_b)\n\n# Symmetric difference\nprint(set_a ^ set_b)  # or set_a.symmetric_difference(set_b)\n```\n\n\n\n\nAdding and removing elements:\n\n\n\n\n```{pyodide}\n#| autorun: false\nfruits = {\"apple\", \"banana\", \"cherry\"}\n\n# Adding elements\nfruits.add(\"orange\")\nprint(fruits)\n\n# Removing elements\nfruits.remove(\"banana\")  # Raises error if element doesn't exist\nprint(fruits)\n\nfruits.discard(\"kiwi\")   # No error if element doesn't exist\n```\n\n\n\n\n:::\n\n\n## Type Casting\n\nType casting is the process of converting a value from one data type to another. Python provides built-in functions for type conversion.\n\nPython offers several built-in functions for type conversion:\n- `int()`: Converts to integer\n- `float()`: Converts to float\n- `str()`: Converts to string\n- `bool()`: Converts to boolean\n- `list()`: Converts to list\n- `tuple()`: Converts to tuple\n- `set()`: Converts to set\n- `dict()`: Converts from mappings or iterables of key-value pairs\n\nLet's explore various type conversion examples with practical code demonstrations. These examples show how Python handles conversions between different data types.\n\n**Numeric Conversions**\n\nWhen converting between numeric types, it's important to understand how precision and data may change. For example, converting floats to integers removes the decimal portion without rounding.\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Numeric conversions\nprint(int(3.7))       # Float to int (truncates decimal part)\nprint(float(5))       # Int to float\nprint(complex(3, 4))  # Creating complex number\n```\n\n\n\n\n**String Conversions**\n\nString conversions are commonly used when processing user input or preparing data for output. Python provides straightforward functions for converting between strings and numeric types.\n\n\n\n\n```{pyodide}\n#| autorun: false\n# String conversions\nprint(str(123))       # Number to string\nprint(int(\"456\"))     # String to number\nprint(float(\"3.14\"))  # String to float\n```\n\n\n\n\n**Collection Type Conversions**\n\nPython allows for easy conversion between different collection types, which is useful for changing the properties of your data structure (like making elements unique with sets).\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Collection type conversions\nprint(list(\"Python\"))             # String to list\nprint(tuple([1, 2, 3]))          # List to tuple\nprint(set([1, 2, 2, 3, 3, 3]))   # List to set (removes duplicates)\n```\n\n\n\n\n**Boolean Conversion**\n\nBoolean conversion is essential for conditional logic. Python follows specific rules to determine truthiness of values, with certain \"empty\" or \"zero\" values converting to False.\n\nWhen converting to boolean with `bool()`, the following values are considered False:\n- `0` (integer)\n- `0.0` (float)\n- `\"\"` (empty string)\n- `[]` (empty list)\n- `()` (empty tuple)\n- `{}` (empty dictionary)\n- `set()` (empty set)\n- `None`\n\nEverything else converts to `True`.\n\n\n\n\n```{pyodide}\n#| autorun: false\n# Boolean conversions\nprint(bool(0))      # False\nprint(bool(1))      # True\nprint(bool(\"\"))     # False\nprint(bool(\"text\")) # True\nprint(bool([]))     # False\nprint(bool([1, 2])) # True\n```\n\n\n\n\n**Special Cases and Errors**\n\nType conversion can sometimes fail, especially when the source value cannot be logically converted to the target type. Understanding these limitations helps prevent runtime errors in your code.\n\nNot all type conversions are possible. Python will raise an error when the conversion is not possible.\n\n\n\n\n```{pyodide}\n#| autorun: false\n# This works\nprint(int(\"123\"))\n\n# This will cause an error - uncomment to see\n# print(int(\"123.45\"))  # ValueError - can't convert string with decimal to int\n# print(int(\"hello\"))   # ValueError - can't convert arbitrary string to int\n```\n\n\n\n\nTo handle potential errors in type conversion, you can use exception handling with try/except blocks:\n\n\n\n\n```{pyodide}\n#| autorun: false\ntry:\n    user_input = \"abc\"\n    number = int(user_input)\n    print(f\"Converted to number: {number}\")\nexcept ValueError:\n    print(f\"Cannot convert '{user_input}' to an integer\")\n```\n\n",
    "supporting": [
      "01-lecture02_files"
    ],
    "filters": [],
    "includes": {}
  }
}