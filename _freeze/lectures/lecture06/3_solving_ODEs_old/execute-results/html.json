{
  "hash": "a1454908a330c1eff449026c592415f9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nformat:\n  live-html:\n    toc: true\n    toc-location: right\npyodide:\n  autorun: false\n  packages:\n    - matplotlib\n    - numpy\n    - scipy\ntitle: Putting it all together\n---\n\n\n\n\n## Solving ODEs\n\nAll the stuff we have defined in the previous sections is useful for solving ordinary differential equations. This will bring us closer to solving out physics problems now.\n\n```{pyodide}\n#| edit: false\n#| echo: false\n#| execute: true\n\nimport numpy as np\nimport io\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.sparse import diags\n\n# default values for plotting\nplt.rcParams.update({'font.size': 12,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 5,\n                     'axes.labelsize': 11,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})\n\ndef get_size(w,h):\n      return((w/2.54,h/2.54))\n```\n\n## Harmonic Oscillator\n\n\n::: {.callout-note}\n## Physics Interlude: The harmonic oscillator\n\nWe are going to tackle as a first very simple problem, the harmonic oscillator and we will demonstrate that with the matrix (Crank-Nicholson method or implicit scheme), the Euler type integration method and using some 'unknown' integrator in the module `SciPy`.\n\nThe equation of motion for a classical harmonic oscillator is given\n\n\\begin{equation}\n\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2}+\\omega^2 x=0\n\\end{equation}\n\nThis is a second order differential equation which requires for its solution two initial conditions. The first initial condition is the initial elongation $x(t=0)=x_{0}$ and the second the initial velocity $\\dot{x}(t=0)=v_{0}$.\n:::\n\n## Implicit Solution\n\nLets start with the matrix appraoch we have just learned about. Using the matrix version, we can transform the above equation into a system of coupled equations, which we can solve with some standard methods available from e.g. the `SciPy` module.\n\n### Define Matrices\n\nOur matrix will consist of two parts. The first containing the second derivative and the second just the elongation. Suppose we want to calculate the position $x(t)$ at 6 instances in time $t_{i}$\nthen the matrix version of the second derivative reads as\n\n($x_{1}=x(t_{1}), \\ldots$).\n\n$T=\\frac{d^2x}{dt^2}=\\frac{1}{\\delta t^2}\n\\begin{bmatrix}\n-2 & 1  & 0 & 0 & 0 & 0\\\\\n 1 & -2 & 1 & 0 & 0 & 0\\\\\n 0 & 1  & -2 & 1 & 0 & 0\\\\\n 0 & 0  & 1  & -2 & 1 & 0\\\\\n 0 & 0  & 0  &  1 & -2 & 1\\\\\n 0 & 0  & 0  &  0 &  1 & -2\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{1}\\\\\nx_{2}\\\\\nx_{3}\\\\\nx_{4}\\\\\nx_{5}\\\\\nx_{6}\n\\end{bmatrix}$\n\nThe second term in the equation of motion is a multiplication of the elongation $x(t_{i})$ by $\\omega^{2}$ and can be written as\n\n\n$V=\\omega^2 x=\\begin{bmatrix}\n\\omega^2  & 0  & 0 & 0 & 0 & 0\\\\\n 0 & \\omega^2  & 0 & 0 & 0 & 0\\\\\n 0 & 0  & \\omega^2  & 0 & 0 & 0\\\\\n 0 & 0  & 0  & \\omega^2  & 0 & 0\\\\\n 0 & 0  & 0  &  0 & \\omega^2  & 0\\\\\n 0 & 0  & 0  &  0 &  0 & \\omega^2 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{1}\\\\\nx_{2}\\\\\nx_{3}\\\\\nx_{4}\\\\\nx_{5}\\\\\nx_{6}\n\\end{bmatrix}$\n\nThe left hand side of the would threfore contain a sum of the two matrices $M=T+V$ multiplied by the vector $x$.\nWe have therfore almost all things together to solve this differential equation with the help of an implicit scheme. What we have ignored so far are the initial conditions.\n\n\n### Use Initial Conditions\n\nThe matrix given for the second detivative actually implies already some initial (bounary) conditions. You probably noticed that the matrix contains incomplete coefficients for the second derivative in the first and last line. The first line contains $(-2,1)$, but the second derivative should contain $(1,-2,1)$. This $(-2,1)$ thus always includes the boundary condition that $x_{0}=0$. To include our own initial/boundary conditions, we have to construct the matrix for the second derivative slightly differently and modify the differential equation to\n\n\\begin{equation}\n\\frac{\\mathrm{d}^2x}{\\mathrm{d}t^2}+\\omega^2 x=b\n\\end{equation}\n\nwhere the vector b takes care of the initial conditions.\n\nIf we have $N$ positions in time at which we calculate the elongation $x$, we have a $N\\times N$ matrix of for the second derivatives. The lower $N-2$ lines will contain the the coefficients for the second derivative $(1,-2,1)$. The first two lines supply the initial/boundary conditions.\n\nThe initial condition for the elongation $x(t=0)=x_{0}$ is obtained when the first element of the first line is a **1**.\nThe matrix multiplication $M\\, x=b$ for yields thus in the first line $x_{1}=b_{1}$ and we set $b_{1}=x_{0}$. The second line shall give the initial velocity. So the matrix entries of the second line contain a first derivative $(-1,1)$. The matrix multiplication thus yields $x_{2}-x_{1}=b_{2}$. We can therefore need to set $b_{2}=v_{0}\\delta t$. All of the other entries of $b$ shall be set to zero according to the differential equation of the harmonic oscillator.\n\nOur final problem $M\\, x=b$ will thus have the following shape\n\n\\begin{equation}\n\\begin{bmatrix}\n1 & 0  & 0 & 0 & 0 & 0\\\\\n-1 & 1 & 0 & 0 & 0 & 0\\\\\n1 & -2+\\omega^2*\\delta t^2  & 1 & 0 & 0 & 0\\\\\n0 & 1  & -2+\\omega^2*\\delta t^2  & 1 & 0 & 0\\\\\n0 & 0  & 1  &  -2+\\omega^2*\\delta t^2 & 1 & 0\\\\\n0 & 0  & 0  &  1 &  -2+\\omega^2*\\delta t^2 & 1\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{1}\\\\\nx_{2}\\\\\nx_{3}\\\\\nx_{4}\\\\\nx_{5}\\\\\nx_{6}\n\\end{bmatrix}=\n\\begin{bmatrix}\nx_{0}\\\\\nv_{0}\\delta t\\\\\n0\\\\\n0\\\\\n0\\\\\n0\n\\end{bmatrix}\n\\end{equation}\n\n### Solution\n\nThis is the final system of coupled equations which we can supply to any matrix solver. We will use a solver from the `scipy.linalg` module. Lets have a look at the details below.\n\n```python\nN=10\n\n(diags([-2., 1., 1.], [-1,-2, 0],\n    shape=(N, N))+diags([1], [-1], shape=(N, N))* omega**2*dt**2)\n```\n\n```{pyodide}\n#| autorun: false\nfrom scipy.sparse import diags\n\nk = 15.5 # spring constant\nm = 0.2 # mass\nomega=np.sqrt(k/m) # frequency of the oscillator\n\nL = np.pi # time period over which we solve the ODE\nN = 500 # number of data points\nt = np.linspace(0, L, N) # time axis\n\nb = np.zeros(N) # initial conditions vector\nb[0]=1 # initial elongation\nb[1]=0 # initial velocity\n\nx = np.zeros(N) # solution vector\ndt = t[1] - t[0] # time intervall of each step\n\n# construct the matrix\nT= diags([-2., 1., 1.], [-1,-2, 0], shape=(N, N)).todense()\nV= diags([1], [-1], shape=(N, N)).todense()\nM= T/dt**2 + V*omega**2\n\nM[0,0]=1 # initial condition for amplitude, x1=1\nM[1,0]=-1 # initial condition for velocity, dx/dt=0\nM[1,1]=1\n\n# initial condition vector\nb=b.transpose()\n\nx= np.linalg.solve(M, b) # this is the solution\n```\n\n```{pyodide}\n#| autorun: false\n#| fig-align: center\nplt.figure(figsize=get_size(8,6))\nplt.plot(t,x)\nplt.xlabel('time t')\nplt.ylabel('elongation x(t)')\nplt.tight_layout()\nplt.show()\n```\n\n## Explicit Solution - Numerical Integration\n\nBefore implementing explicit numerical schemes, let's develop a standardized approach for solving ODEs. This framework will allow us to solve different problems using various methods with minimal code modification.\n\nLet's examine the free fall problem as an example:\n\n\\begin{equation}\n\\ddot{x}= -g\n\\end{equation}\n\nThis second-order equation can be transformed into a system of two first-order equations:\n\n\\begin{eqnarray}\n\\dot{x} &= v \\\\\n\\dot{v} &= -g\n\\end{eqnarray}\n\nUsing the Euler method, these equations become:\n\n\\begin{eqnarray}\nx_{i+1} &= x_i + v_i \\Delta t \\\\\nv_{i+1} &= v_i - g\\Delta t\n\\end{eqnarray}\n\nNote: The original equations had $\\dot{x}$ and $\\dot{v}$ in the right-hand side, which should be replaced with their actual values ($v$ and $-g$ respectively).\n\nThese equations can be written more compactly in vector form:\n\n\\begin{equation}\n\\vec{y}_{i+1} = \\vec{y}_i + \\dot{\\vec{y}}_i \\Delta t\n\\end{equation}\n\nwhere\n\n\\begin{equation}\n\\vec{y}=\n\\begin{bmatrix}\nx \\\\\nv\n\\end{bmatrix}\n\\end{equation}\n\nand\n\n\\begin{equation}\n\\dot{\\vec{y}}=\n\\begin{bmatrix}\nv \\\\\n-g\n\\end{bmatrix}\n\\end{equation}\n\nThis vector formulation allows us to separate:\n1. Problem definition (specifying $\\dot{\\vec{y}}$ as a function of $\\vec{y}$ and $t$)\n2. Solution method (implementing the numerical integration scheme)\n\nWe'll explore three numerical methods:\n\n- **Euler Method**: First-order accurate\n- **Euler-Cromer Method**: Modified Euler method, better for oscillatory systems\n- **Midpoint Method**: Second-order accurate\n\nMore sophisticated methods like the Runge-Kutta family offer higher accuracy but are not covered here.\n\n\n### Euler Method\n\nThe **Euler method** is derived from the Taylor expansion of the solution $\\vec{y}(t)$ around the current time $t$:\n\n\\begin{equation}\n\\vec{y}(t+\\Delta t)=\\vec{y}(t)+\\dot{\\vec{y}}(t)\\Delta t+\\frac{1}{2}\\ddot{\\vec{y}}(t)\\Delta t^{2}+ \\mathcal{O}(\\Delta t^3)\n\\end{equation}\n\nThe Euler method approximates this by truncating after the first-order term:\n\n\\begin{equation}\n\\vec{y}(t+\\Delta t) \\approx \\vec{y}(t) + \\dot{\\vec{y}}(t) \\Delta t\n\\end{equation}\n\nFor our free fall example, this becomes:\n\n\\begin{equation}\n\\begin{bmatrix} x_{i+1} \\\\ v_{i+1} \\end{bmatrix} =\n\\begin{bmatrix} x_i \\\\ v_i \\end{bmatrix} +\n\\begin{bmatrix} v_i \\\\ -g \\end{bmatrix} \\Delta t\n\\end{equation}\n\nError Analysis:\nThe method has two distinct types of errors. The local truncation error, which represents the error made in a single step, is of order $\\mathcal{O}(\\Delta t^2)$. This corresponds to the first term omitted in the Taylor expansion. The global truncation error, which accumulates over the entire integration interval $[0,\\tau]$, is of order $\\mathcal{O}(\\Delta t)$. This can be understood by considering that we take $N = \\tau/\\Delta t$ steps, each contributing an error proportional to $\\Delta t^2$. The total error thus scales as $N \\cdot \\Delta t^2 = \\tau \\Delta t$.\n\nLimitations and Extensions:\nThe method is directly applicable only to first-order systems of the form $\\dot{\\vec{y}} = \\vec{f}(\\vec{y},t)$. However, this is not a fundamental limitation as higher-order equations can be converted to systems of first-order equations. For example, a second-order equation $\\ddot{x} = f(x,\\dot{x},t)$ can be transformed into a system of two first-order equations by introducing the velocity as an additional variable. The resulting system becomes:\n\n\\begin{equation}\n\\begin{bmatrix} \\dot{x} \\\\ \\dot{v} \\end{bmatrix} =\n\\begin{bmatrix} v \\\\ f(x,v,t) \\end{bmatrix}\n\\end{equation}\n\nThis transformation allows us to apply the method to a wider class of problems while maintaining its fundamental characteristics.\n\n### Euler-Cromer Method\n\nThe **Euler-Cromer method** (also known as the semi-implicit Euler method) modifies the basic Euler method by using the updated velocity when calculating the position. For a system described by position and velocity:\n\n\\begin{equation}\n\\begin{aligned}\n\\dot{x} &= v \\\\\n\\dot{v} &= f(x,v,t)\n\\end{aligned}\n\\end{equation}\n\nThe integration steps are:\n\n\\begin{equation}\n\\begin{aligned}\nv_{i+1} &= v_i + f(x_i,v_i,t_i)\\Delta t \\\\\nx_{i+1} &= x_i + v_{i+1}\\Delta t\n\\end{aligned}\n\\end{equation}\n\nFor our free fall example:\n\\begin{equation}\n\\begin{aligned}\nv_{i+1} &= v_i - g\\Delta t \\\\\nx_{i+1} &= x_i + v_{i+1}\\Delta t\n\\end{aligned}\n\\end{equation}\n\nEnergy Behavior:\nThe method shows improved energy conservation for oscillatory systems compared to the standard Euler method. While the Euler method typically increases energy over time, the Euler-Cromer method exhibits small energy oscillations around the correct value.\n\nError Analysis:\nThe method maintains a local truncation error of $\\mathcal{O}(\\Delta t^2)$ and a global truncation error of $\\mathcal{O}(\\Delta t)$. Despite having the same order of accuracy as the Euler method, it provides more stable solutions for oscillatory systems.\n\nAdvantages:\nThe Euler-Cromer method represents a simple modification of the Euler method that achieves better stability for oscillatory systems without requiring additional function evaluations.\n\nLimitations:\nThe method remains first-order accurate globally and is not symmetric in time. While it performs well for certain types of problems, particularly oscillatory systems, it may not be suitable for all differential equations.\n\nComparison with Euler Method:\n\n```python\n# Euler Method\nv[i+1] = v[i] + f(x[i],v[i],t[i])*dt\nx[i+1] = x[i] + v[i]*dt       # Uses old velocity\n\n# Euler-Cromer Method\nv[i+1] = v[i] + f(x[i],v[i],t[i])*dt\nx[i+1] = x[i] + v[i+1]*dt     # Uses new velocity\n```\n\n\n### Midpoint Method\n\nThe **Midpoint Method** (also known as the second-order Runge-Kutta method) improves upon both the Euler and Euler-Cromer methods by using the average of the derivatives at the current point and an estimated midpoint.\n\nFor a system of first-order differential equations:\n\n\\begin{equation}\n\\dot{\\vec{y}} = \\vec{f}(\\vec{y},t)\n\\end{equation}\n\nThe algorithm proceeds in two steps:\n\n1. Calculate an intermediate point using an Euler step to the midpoint:\n\\begin{equation}\n\\vec{k}_1 = \\vec{f}(\\vec{y}_i,t_i)\n\\end{equation}\n\\begin{equation}\n\\vec{y}_{i+1/2} = \\vec{y}_i + \\frac{\\Delta t}{2}\\vec{k}_1\n\\end{equation}\n\n2. Use the derivative at this midpoint for the full step:\n\\begin{equation}\n\\vec{k}_2 = \\vec{f}(\\vec{y}_{i+1/2},t_i+\\Delta t/2)\n\\end{equation}\n\\begin{equation}\n\\vec{y}_{i+1} = \\vec{y}_i + \\Delta t\\vec{k}_2\n\\end{equation}\n\nFor our free fall example, this becomes:\n\n\\begin{equation}\n\\begin{aligned}\nv_{i+1/2} &= v_i - \\frac{g\\Delta t}{2} \\\\\nx_{i+1/2} &= x_i + v_i\\frac{\\Delta t}{2} \\\\\nv_{i+1} &= v_i - g\\Delta t \\\\\nx_{i+1} &= x_i + v_{i+1/2}\\Delta t\n\\end{aligned}\n\\end{equation}\n\nError Analysis:\nThe method achieves higher accuracy than both Euler and Euler-Cromer methods with:\n\n- Local truncation error: $\\mathcal{O}(\\Delta t^3)$\n- Global truncation error: $\\mathcal{O}(\\Delta t^2)$\n\nImplementation:\n```python\ndef midpoint_step(y, t, dt, f):\n    # Calculate k1\n    k1 = f(y, t)\n\n    # Calculate midpoint\n    y_mid = y + 0.5 * dt * k1\n\n    # Calculate k2 at midpoint\n    k2 = f(y_mid, t + 0.5*dt)\n\n    # Full step using midpoint derivative\n    return y + dt * k2\n```\n\n::: {#64f2832a .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](3_solving_ODEs_old_files/figure-html/cell-2-output-1.png){width=747 height=371 fig-align='center'}\n:::\n:::\n\n\n\nNow we can implement our numerical solution by combining our understanding of both the physical system and numerical methods. This implementation consists of two main parts: defining the differential equation and solving it numerically.\n\n#### The Definition of the Problem\n\nFor the simple harmonic oscillator, we start with the second-order differential equation:\n\n\\begin{equation}\n\\frac{d^2x}{dt^2} + \\omega^2x = 0\n\\end{equation}\n\nTo solve this numerically, we convert it to a system of first-order equations using our state vector $\\vec{y} = [x, v]^T$:\n\n\\begin{equation}\n\\frac{d}{dt}\\begin{bmatrix} x \\\\ v \\end{bmatrix} =\n\\begin{bmatrix} v \\\\ -\\omega^2x \\end{bmatrix}\n\\end{equation}\n\nThis is implemented as:\n~~~\ndef SHO(state, time):\n    \"\"\"\n    Define the harmonic oscillator system.\n    state[0] : position x\n    state[1] : velocity v\n    returns  : [dx/dt, dv/dt]\n    \"\"\"\n    g0 = state[1]         # dx/dt = v\n    g1 = -k/m*state[0]    # dv/dt = -ω²x\n    return np.array([g0, g1])\n~~~\n\nThis function defines our physical system by returning the derivatives of our state variables at any given point.\n\n#### Solving the Problem\n\nWith our system defined, we can implement the numerical solution using Euler's method. The basic algorithm takes the current state and advances it by one time step:\n\n~~~\ndef euler(y, t, dt, derivs):\n    \"\"\"\n    Perform one step of the Euler method.\n    y      : current state [x, v]\n    t      : current time\n    dt     : time step\n    derivs : function returning derivatives\n    \"\"\"\n    y_next = y + derivs(y, t) * dt\n    return y_next\n~~~\n\nThis simple structure allows us to solve different physical problems by just changing the derivative function. For example, we can solve the free fall problem with initial conditions $x_0=0$ and $v_0=10$, or the harmonic oscillator with specified spring constant $k$ and mass $m$.\n\nThe key advantage of this structure lies in its flexibility. We can change the physical system by providing a different derivative function, implement various numerical methods by modifying the integration step, and explore the system behavior by adjusting parameters and initial conditions. This modular approach allows us to study a wide range of physical systems using the same basic numerical framework.\n\n```{pyodide}\n#| autorun: false\n# Parameters\nN = 2000  # number of steps\ntau = 4*np.pi  # time period\nxo = 1.0  # initial position\nvo = 0.0  # initial velocity\n\nk = 3.5\nm = 0.2\ngravity = 9.8\n\ndt = tau/float(N-1)\ntime = np.linspace(0, tau, N)\n\ny = np.zeros([N, 2])\ny[0, 0] = xo\ny[0, 1] = vo\n\n\n##  defining the problem\ndef free_fall(state , time):\n    g0 = state[1]\n    g1 = -gravity\n    return(np.array([g0, g1]))\n\n\ndef SHO(y, t, b=0, k=3.5):\n    x, v = y\n    dydt = [v, -b*v - k*x]\n    return np.array(dydt)\n\n\ndef MMM(state, time):\n    g0 = state[1]-1.1*state[1]\n    g1 = -k/m * state[0]-12\n    return(np.array([g0, g1]))\n\n##  solving the problem with euler\ndef euler(y, t, dt, derivs):\n    y_next = y + derivs(y,t)* dt\n    return(y_next)\n\ndef runge_kutta2(y, time, dt, derivs):\n    k0 = dt * derivs(y, time)\n    k1 = dt * derivs(y + k0, time + dt)\n    y_next = y + 0.5 * (k0 + k1)\n    return y_next\n\n# Solve the differential equation\nfor j in range(N-1):\n    y[j+1] = euler(y[j], time[j], dt, SHO)\n\n# Plot results\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))\n\nax1.plot(time, y[:, 0])\nax1.set_title(\"Position\")\nax1.set_xlabel('time [s]', fontsize=16)\nax1.set_ylabel('position x [m]', fontsize=16)\nax1.tick_params(labelsize=14)\n\nax2.plot(time, y[:, 1])\nax2.set_title(\"Velocity\")\nax2.set_xlabel('time [s]', fontsize=16)\nax2.set_ylabel('velocity v [m/s]', fontsize=16)\nax2.tick_params(labelsize=14)\n\nplt.tight_layout()\nplt.show()\n```\n\n## Solving the Harmonic Oscillator with SciPy {#sec-solving-ODE}\n\nHaving explored basic numerical integration methods, we can now utilize more sophisticated tools available in SciPy. The `scipy.integrate.odeint()` function provides a robust and accurate integration method with several advantages over our simple implementations.\n\nTo use SciPy's integrator:\n```python\nfrom scipy.integrate import odeint\n```\n\nThe basic syntax is:\n```python\nsolution = odeint(derivative_function, initial_conditions, time_points)\n```\n\nwhere:\n\n- `derivative_function` defines the system (like our `SHO` function)\n- `initial_conditions` is a vector containing $[x_0, v_0]$\n- `time_points` is an array of times at which to compute the solution\n\nThe `odeint` function offers several significant advantages over our simple implementations. It features adaptive step size control, which automatically adjusts the integration step size based on the local error. The function performs continuous error estimation and correction to maintain accuracy throughout the integration. It also provides various integration methods that can be selected based on the problem's requirements. The function is capable of handling stiff equations, which are particularly challenging for simpler methods, and generally provides better numerical stability across a wide range of problems.\n\nFor example, to solve the harmonic oscillator:\n```python\ndef SHO(state, t, k=1.0, m=1.0):\n    x, v = state\n    return [v, -k/m * x]\n\n# Initial conditions\ny0 = [1.0, 0.0]  # x₀ = 1, v₀ = 0\nt = np.linspace(0, 10, 1000)\n\n# Solve the system\nsolution = odeint(SHO, y0, t)\n```\n\nThe solution array contains:\n\n- `solution[:, 0]`: position values\n- `solution[:, 1]`: velocity values\n\nHaving understood the fundamentals of numerical integration through our implementations of Euler and other methods, we can now confidently use this more sophisticated tool for solving differential equations more accurately and efficiently.\n\n### Setup\n\n```{pyodide}\n#| autorun: false\nfrom scipy.integrate import odeint\n\nN = 1000  # number of steps\nxo = 1.0 # initial position\nvo = 0.0 # initial velocity\ntau = 4*np.pi # time period\n\nk = 3.5\nm = 0.2\ngravity = 9.8\n\ntime = np.linspace(0, tau, N)\n\ny = np.zeros(2)\ny[0] = xo\ny[1] = vo\n\n```\n\n### Definition\n\n```{pyodide}\n#| autorun: false\n##  defining the problem\ndef SHO(state, time):\n    g0 = state[1]\n    g1 = -k/m * state [0]\n    return(np.array([g0, g1]))\n```\n\n### Solution\n\n```{pyodide}\n#| autorun: false\n\nanswer = odeint( SHO, y , time )\n```\n\n### Plotting\n\n```{pyodide}\n#| autorun: false\nfig=plt.figure(1, figsize = (10,5) )\nplt.subplot(1, 2, 1)\nplt.plot(time, answer[:,0])\nplt.ylabel(\"position , velocity\")\nplt.xlabel('time [s]', fontsize=16)\nplt.ylabel('position x [m]',fontsize=16)\nplt.tick_params(labelsize=14)\n\nplt.subplot(1, 2, 2)\nplt.plot(time, answer[:,1])\nplt.xlabel('time [s]', fontsize=16)\nplt.ylabel('velocity v [m/s]',fontsize=16)\nplt.tick_params(labelsize=14)\n\nplt.tight_layout()\nplt.show()\n```\n\n## Damped Driven Pendulum in SciPy\n\nWrite a `derivs` function for a damped driven pendulum:\n\n\\begin{equation}\n\\ddot{\\theta}=-\\frac{g}{L}\\sin(\\theta)-b \\dot{\\theta}+\\beta\\cos(\\omega t)\n\\end{equation}\n\nUse this *derivs* function with the *SciPy* solver and plot the result for different parameters. Vary the damping parameter $b$. Observe the contributions of the homogeneous and the particular solution. Plot the amplitude of the stationary solution as a function of frequency!\n\n### Setup\n\n```{pyodide}\n#| autorun: false\nN = 10000  # number of steps\ntheta_o = 1.0 # initial position\nvo = -0.0 # initial velocity\ntau = 100.0 # time period\n\nlength=10.0\nb=0.2\nbeta=np.pi/2\ngravity = 9.8\nomega=np.sqrt(gravity/length)\n\n\ntime = np.linspace(0, tau, N)\n\ny = np.zeros (2)\ny[0] = theta_o\ny[1] = vo\n```\n\n### Definition\n\n```{pyodide}\n#| autorun: false\ndef pendulum_def(state , time):\n    g0 = state[1]\n    g1 = -gravity/length * np.sin(state[0]) - b*state[1] + beta*np.cos(omega * time)\n    return(np.array([g0, g1]) )\n```\n\n### Solution\n\n```{pyodide}\n#| autorun: false\nanswer = odeint( pendulum_def, y , time )\n```\n\n### Plotting\n\n```{pyodide}\n#| autorun: false\nfig=plt.figure(1, figsize = (8,6) )\nplt.plot(time,beta*np.cos(omega * time),'r--',alpha=0.3)\nplt.plot(time, answer[:,0])\nplt.xlabel('time [s]', fontsize=16)\nplt.ylabel('angular velocity',fontsize=16)\nplt.tick_params(labelsize=14)\nplt.show()\n```\n\n\n",
    "supporting": [
      "3_solving_ODEs_old_files"
    ],
    "filters": [],
    "includes": {}
  }
}