{
  "hash": "25ca3713f29723875ab09153985e0751",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Solving Ordinary Differential Equations (ODEs)\nsubtitle: From Basic Methods to Advanced Applications\nformat:\n  live-html:\n    toc: true\n    toc-location: right\npyodide:\n  autorun: false\n  packages:\n    - matplotlib\n    - numpy\n    - scipy\n---\n\n## Introduction\n\nThis lecture covers methods for solving ordinary differential equations (ODEs), which are fundamental to many physics problems. We'll explore different numerical approaches, from basic to more sophisticated methods.\n\n```{pyodide}\n#| edit: false\n#| echo: false\n#| execute: true\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.sparse import diags\nfrom scipy.integrate import odeint\n\n# Set plotting defaults\nplt.rcParams.update({\n    'font.size': 12,\n    'lines.linewidth': 1,\n    'lines.markersize': 5,\n    'axes.labelsize': 11,\n    'xtick.labelsize': 10,\n    'ytick.labelsize': 10,\n    'xtick.top': True,\n    'xtick.direction': 'in',\n    'ytick.right': True,\n    'ytick.direction': 'in',\n})\n\ndef get_size(w, h):\n    \"\"\"Convert dimensions from cm to inches\"\"\"\n    return (w/2.54, h/2.54)\n```\n\n## The Harmonic Oscillator\n\n::: {.callout-note}\n## The Classical Harmonic Oscillator\n\nThe harmonic oscillator represents one of the most important physical systems, appearing in:\n- Mechanical oscillations (springs, pendulums)\n- Electrical circuits (LC circuits)\n- Quantum mechanics (quantum harmonic oscillator)\n- Molecular vibrations\n\nThe equation of motion is:\n\n\\begin{equation}\n\\frac{d^2x}{dt^2} + \\omega^2 x = 0\n\\end{equation}\n\nwhere:\n- $x$ is the displacement\n- $t$ is time\n- $\\omega = \\sqrt{k/m}$ is the angular frequency\n- $k$ is the spring constant\n- $m$ is the mass\n\nInitial conditions required:\n- Initial position: $x(t=0) = x_0$\n- Initial velocity: $\\dot{x}(t=0) = v_0$\n:::\n\n## Numerical Solution Methods\n\n### 1. Implicit Solution (Crank-Nicolson Method)\n\nThe matrix approach transforms our second-order ODE into a system of coupled equations. This method is particularly stable for oscillatory systems.\n\n#### Matrix Construction\n\nFor $N$ time points, we construct two matrices:\n\n1. The second derivative matrix ($T$):\n\n\\begin{equation}\nT=\\frac{1}{\\delta t^2}\n\\begin{bmatrix}\n-2 & 1  & 0 & \\cdots & 0\\\\\n1 & -2 & 1 & \\cdots & 0\\\\\n\\vdots & \\ddots & \\ddots & \\ddots & \\vdots\\\\\n0 & \\cdots & 1 & -2 & 1\\\\\n0 & \\cdots & 0 & 1 & -2\n\\end{bmatrix}\n\\end{equation}\n\n2. The potential term matrix ($V$):\n\n\\begin{equation}\nV = \\omega^2\n\\begin{bmatrix}\n1 & 0 & \\cdots & 0\\\\\n0 & 1 & \\cdots & 0\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\n0 & 0 & \\cdots & 1\n\\end{bmatrix}\n\\end{equation}\n\n```{pyodide}\ndef build_matrices(N, omega, dt):\n    # Second derivative matrix with correct finite difference\n    T = diags([1, -2, 1], [-1, 0, 1], shape=(N, N)).todense()\n\n    # Combined matrix including potential term\n    M = T/(dt**2) + omega**2 * np.eye(N)\n\n    # Initial conditions\n    M[0,:] = 0\n    M[0,0] = 1  # x(0) = x0\n\n    M[1,:] = 0\n    M[1,0] = -1\n    M[1,1] = 1  # Forward difference for velocity\n\n    return M\n\ndef solve_harmonic_oscillator(k=15.5, m=0.2, L=10.0, N=1000, x0=1.0, v0=0.0):\n    \"\"\"\n    Solve the harmonic oscillator equation.\n\n    Parameters:\n    -----------\n    k : float\n        Spring constant\n    m : float\n        Mass\n    L : float\n        Time period to solve for\n    N : int\n        Number of time points\n    x0 : float\n        Initial position\n    v0 : float\n        Initial velocity\n\n    Returns:\n    --------\n    t : numpy.ndarray\n        Time points\n    x : numpy.ndarray\n        Solution positions\n    \"\"\"\n    # Calculate system parameters\n    omega = np.sqrt(k/m)\n    t = np.linspace(0, L, N)\n    dt = t[1] - t[0]\n\n    # Initialize right-hand side vector\n    b = np.zeros(N)\n    b[0] = x0\n    b[1] = v0 * dt + x0  # Correct initial velocity condition\n\n    # Build and solve system\n    M = build_matrices(N, omega, dt)\n    x = np.linalg.solve(M, b)\n\n    return t, x\n\n# Solve and compare with analytical solution\nt, x_num = solve_harmonic_oscillator(k=15.5, m=0.2, L=10.0, N=1000, x0=1.0, v0=0.0)\n\n# Analytical solution\nomega = np.sqrt(15.5/0.2)\nx_anal = np.cos(omega * t)  # For x0=1, v0=0\n\n# Plot both solutions\nplt.figure(figsize=get_size(12,8))\nplt.plot(t, x_num, 'b-', label='Numerical', linewidth=2)\nplt.plot(t, x_anal, 'r--', label='Analytical', alpha=0.7)\nplt.xlabel('Time (s)')\nplt.ylabel('Position x(t)')\nplt.title('Harmonic Oscillator: Numerical vs Analytical Solution')\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\n\n# Calculate and print maximum difference\nmax_diff = np.max(np.abs(x_num - x_anal))\nprint(f\"Maximum difference between solutions: {max_diff:.2e}\")\n\nplt.show()\n\n# Plot difference\nplt.figure(figsize=get_size(12,4))\nplt.plot(t, x_num - x_anal, 'k-', label='Difference')\nplt.xlabel('Time (s)')\nplt.ylabel('Difference')\nplt.title('Difference between Numerical and Analytical Solutions')\nplt.grid(True)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n\n## Explicit Solution Methods\n\n### State-Space Representation\n\nTo implement explicit numerical methods effectively, we first convert our second-order ODE into a system of first-order equations. This state-space representation is crucial for numerical integration.\n\nFor the harmonic oscillator:\n\n\\begin{equation}\n\\ddot{x} + \\omega^2x = 0\n\\end{equation}\n\nWe define:\n- Position: $x$\n- Velocity: $v = \\dot{x}$\n\nThis gives us the system:\n\n\\begin{equation}\n\\begin{bmatrix} \\dot{x} \\\\ \\dot{v} \\end{bmatrix} =\n\\begin{bmatrix} v \\\\ -\\omega^2x \\end{bmatrix}\n\\end{equation}\n\nOur state vector is:\n\n\\begin{equation}\ny = \\begin{bmatrix} x \\\\ v \\end{bmatrix}\n\\end{equation}\n\n### 1. Euler Method\n\nThe Euler method is the simplest numerical integration technique. It comes directly from the Taylor expansion:\n\n\\begin{equation}\ny(t + \\Delta t) = y(t) + \\dot{y}(t)\\Delta t + O(\\Delta t^2)\n\\end{equation}\n\n```{pyodide}\ndef euler_step(y, t, dt, deriv_func, params=None):\n    \"\"\"\n    Perform one step of the Euler method.\n\n    Parameters:\n    -----------\n    y : numpy.ndarray\n        Current state vector [position, velocity]\n    t : float\n        Current time\n    dt : float\n        Time step\n    deriv_func : callable\n        Function that returns derivatives\n    params : dict, optional\n        Additional parameters for deriv_func\n\n    Returns:\n    --------\n    numpy.ndarray\n        Next state vector\n    \"\"\"\n    if params is None:\n        dy = deriv_func(y, t)\n    else:\n        dy = deriv_func(y, t, **params)\n    return y + dy * dt\n\ndef euler_integrate(deriv_func, y0, t, params=None):\n    \"\"\"\n    Integrate using Euler method.\n\n    Parameters:\n    -----------\n    deriv_func : callable\n        Function that returns derivatives\n    y0 : numpy.ndarray\n        Initial state vector\n    t : numpy.ndarray\n        Time points\n    params : dict, optional\n        Additional parameters for deriv_func\n\n    Returns:\n    --------\n    numpy.ndarray\n        Solution array, shape (len(t), len(y0))\n    \"\"\"\n    y = np.zeros((len(t), len(y0)))\n    y[0] = y0\n    dt = t[1] - t[0]\n\n    for i in range(len(t)-1):\n        y[i+1] = euler_step(y[i], t[i], dt, deriv_func, params)\n\n    return y\n```\n\n### 2. Euler-Cromer Method\n\nThe Euler-Cromer method (also known as the semi-implicit Euler method) is particularly good for oscillatory systems because it conserves energy better than the standard Euler method.\n\nKey difference:\n- Uses the updated velocity to compute position\n- Better energy conservation for oscillatory systems\n\n\\begin{align}\nv_{i+1} &= v_i - \\omega^2 x_i \\Delta t \\\\\nx_{i+1} &= x_i + v_{i+1} \\Delta t\n\\end{align}\n\n```{pyodide}\ndef euler_cromer_step(y, t, dt, deriv_func, params=None):\n    \"\"\"\n    Perform one step of the Euler-Cromer method.\n\n    Parameters:\n    -----------\n    y : numpy.ndarray\n        Current state vector [position, velocity]\n    t : float\n        Current time\n    dt : float\n        Time step\n    deriv_func : callable\n        Function that returns derivatives\n    params : dict, optional\n        Additional parameters for deriv_func\n\n    Returns:\n    --------\n    numpy.ndarray\n        Next state vector\n    \"\"\"\n    if params is None:\n        derivatives = deriv_func(y, t)\n    else:\n        derivatives = deriv_func(y, t, **params)\n\n    # First update velocity\n    v_new = y[1] + derivatives[1] * dt\n\n    # Use new velocity to update position\n    x_new = y[0] + v_new * dt\n\n    return np.array([x_new, v_new])\n\ndef euler_cromer_integrate(deriv_func, y0, t, params=None):\n    \"\"\"\n    Integrate using Euler-Cromer method.\n    \"\"\"\n    y = np.zeros((len(t), len(y0)))\n    y[0] = y0\n    dt = t[1] - t[0]\n\n    for i in range(len(t)-1):\n        y[i+1] = euler_cromer_step(y[i], t[i], dt, deriv_func, params)\n\n    return y\n```\n\n### 3. Velocity Verlet Method\n\nThe Velocity Verlet method is a symplectic integrator that provides excellent energy conservation for Hamiltonian systems. It's particularly useful for molecular dynamics simulations.\n\nThe algorithm:\n1. Update position using current velocity and acceleration\n2. Calculate new acceleration at new position\n3. Update velocity using average of old and new accelerations\n\n\\begin{align}\nx_{i+1} &= x_i + v_i\\Delta t + \\frac{1}{2}a_i\\Delta t^2 \\\\\na_{i+1} &= -\\omega^2 x_{i+1} \\\\\nv_{i+1} &= v_i + \\frac{1}{2}(a_i + a_{i+1})\\Delta t\n\\end{align}\n\n```{pyodide}\ndef verlet_step(y, t, dt, force_func, params=None):\n    \"\"\"\n    Perform one step of the Velocity Verlet method.\n\n    Parameters:\n    -----------\n    y : numpy.ndarray\n        Current state vector [position, velocity]\n    t : float\n        Current time\n    dt : float\n        Time step\n    force_func : callable\n        Function that returns acceleration\n    params : dict, optional\n        Additional parameters for force_func\n\n    Returns:\n    --------\n    numpy.ndarray\n        Next state vector\n    \"\"\"\n    x, v = y\n\n    # Calculate current acceleration\n    if params is None:\n        a = force_func(x, t)\n    else:\n        a = force_func(x, t, **params)\n\n    # Update position\n    x_new = x + v*dt + 0.5*a*dt**2\n\n    # Calculate new acceleration\n    if params is None:\n        a_new = force_func(x_new, t + dt)\n    else:\n        a_new = force_func(x_new, t + dt, **params)\n\n    # Update velocity\n    v_new = v + 0.5*(a + a_new)*dt\n\n    return np.array([x_new, v_new])\n\ndef verlet_integrate(force_func, y0, t, params=None):\n    \"\"\"\n    Integrate using Velocity Verlet method.\n    \"\"\"\n    y = np.zeros((len(t), len(y0)))\n    y[0] = y0\n    dt = t[1] - t[0]\n\n    for i in range(len(t)-1):\n        y[i+1] = verlet_step(y[i], t[i], dt, force_func, params)\n\n    return y\n```\n\n### Comparison of Methods\n\nLet's compare these methods for the harmonic oscillator:\n\n```{pyodide}\ndef harmonic_oscillator_deriv(y, t, omega=1.0):\n    \"\"\"\n    Define harmonic oscillator equations.\n\n    Returns derivatives [dx/dt, dv/dt]\n    \"\"\"\n    return np.array([y[1], -omega**2 * y[0]])\n\ndef compare_methods(T=20.0, N=1000, x0=1.0, v0=0.0, omega=1.0):\n    \"\"\"Compare different integration methods\"\"\"\n    t = np.linspace(0, T, N)\n    y0 = np.array([x0, v0])\n    params = {'omega': omega}\n\n    # Compute solutions using different methods\n    y_euler = euler_integrate(harmonic_oscillator_deriv, y0, t, params)\n    y_euler_cromer = euler_cromer_integrate(harmonic_oscillator_deriv, y0, t, params)\n\n    # Exact solution\n    exact_x = x0 * np.cos(omega * t)\n    exact_v = -x0 * omega * np.sin(omega * t)\n\n    # Create comparison plots\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=get_size(15, 12))\n\n    # Position plot\n    ax1.plot(t, y_euler[:, 0], 'b-', label='Euler', alpha=0.7)\n    ax1.plot(t, y_euler_cromer[:, 0], 'r-', label='Euler-Cromer', alpha=0.7)\n    ax1.plot(t, exact_x, 'k--', label='Exact')\n    ax1.set_ylabel('Position')\n    ax1.legend()\n    ax1.grid(True)\n\n    # Phase space plot\n    ax2.plot(y_euler[:, 0], y_euler[:, 1], 'b-', label='Euler', alpha=0.7)\n    ax2.plot(y_euler_cromer[:, 0], y_euler_cromer[:, 1], 'r-', label='Euler-Cromer', alpha=0.7)\n    ax2.plot(exact_x, exact_v, 'k--', label='Exact')\n    ax2.set_xlabel('Position')\n    ax2.set_ylabel('Velocity')\n    ax2.legend()\n    ax2.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n# Run comparison\ncompare_methods()\n```\n\n::: {.callout-note}\n## Method Characteristics\n\n1. **Euler Method**:\n   - Simplest method\n   - First-order accurate ($O(\\Delta t)$)\n   - Often unstable for oscillatory systems\n   - Energy tends to increase over time\n\n2. **Euler-Cromer Method**:\n   - Better energy conservation\n   - Still first-order accurate\n   - More stable for oscillatory systems\n   - Energy tends to decrease slightly over time\n\n3. **Velocity Verlet Method**:\n   - Second-order accurate ($O(\\Delta t^2)$)\n   - Excellent energy conservation\n   - Symplectic (preserves phase space volume)\n   - Recommended for long-time integration\n:::\n\n\n## Solving ODEs with SciPy\n\nSciPy provides sophisticated ODE solvers through `scipy.integrate.odeint` and `scipy.integrate.solve_ivp`. These implementations use advanced algorithms with automatic step size adjustment and error control.\n\n### Using scipy.integrate.odeint\n\nThe `odeint` function uses the LSODA algorithm from the FORTRAN library ODEPACK, which automatically switches between methods for stiff and non-stiff problems.\n\n::: {.callout-note}\n## Stiff vs Non-stiff Problems\n\n- **Stiff problems**: Have multiple timescales with widely different magnitudes\n- **Non-stiff problems**: Have timescales of similar magnitude\n\nLSODA uses:\n- Adams method for non-stiff problems\n- BDF method (Backward Differentiation Formula) for stiff problems\n:::\n\n```{pyodide}\nfrom scipy.integrate import odeint\n\ndef harmonic_oscillator_scipy(y, t, omega=1.0):\n    \"\"\"\n    Define harmonic oscillator system for scipy.integrate.odeint\n\n    Parameters:\n    -----------\n    y : array_like\n        State vector [position, velocity]\n    t : float\n        Time\n    omega : float\n        Angular frequency\n\n    Returns:\n    --------\n    array_like\n        Derivatives [dx/dt, dv/dt]\n    \"\"\"\n    x, v = y\n    return [v, -omega**2 * x]\n\ndef solve_ho_scipy(T=20.0, N=1000, x0=1.0, v0=0.0, omega=1.0):\n    \"\"\"\n    Solve harmonic oscillator using SciPy's odeint\n    \"\"\"\n    t = np.linspace(0, T, N)\n    y0 = [x0, v0]\n\n    # Solve ODE\n    solution = odeint(harmonic_oscillator_scipy, y0, t, args=(omega,))\n\n    # Plot results\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=get_size(15, 12))\n\n    # Position vs time\n    ax1.plot(t, solution[:, 0], 'b-', label='Position')\n    ax1.set_xlabel('Time')\n    ax1.set_ylabel('Position')\n    ax1.grid(True)\n    ax1.legend()\n\n    # Phase space\n    ax2.plot(solution[:, 0], solution[:, 1], 'r-', label='Phase Space')\n    ax2.set_xlabel('Position')\n    ax2.set_ylabel('Velocity')\n    ax2.grid(True)\n    ax2.legend()\n\n    plt.tight_layout()\n    plt.show()\n\n    return t, solution\n\n# Example usage\nt, solution = solve_ho_scipy()\n```\n\n### Using scipy.integrate.solve_ivp\n\nThe newer `solve_ivp` function provides more control over the integration process and supports multiple modern solving methods.\n\n```{pyodide}\nfrom scipy.integrate import solve_ivp\n\ndef solve_ho_ivp(T=20.0, x0=1.0, v0=0.0, omega=1.0, method='RK45'):\n    \"\"\"\n    Solve harmonic oscillator using SciPy's solve_ivp\n\n    Parameters:\n    -----------\n    T : float\n        End time\n    x0, v0 : float\n        Initial conditions\n    omega : float\n        Angular frequency\n    method : str\n        Integration method ('RK45', 'RK23', 'DOP853', 'BDF', 'LSODA')\n    \"\"\"\n    def system(t, y):\n        return [y[1], -omega**2 * y[0]]\n\n    # Time span\n    t_span = (0, T)\n    # Initial conditions\n    y0 = [x0, v0]\n\n    # Solve ODE\n    sol = solve_ivp(system, t_span, y0, method=method,\n                    dense_output=True, rtol=1e-8)\n\n    # Generate smooth solution for plotting\n    t = np.linspace(0, T, 1000)\n    y = sol.sol(t)\n\n    # Plot results\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=get_size(15, 12))\n\n    # Position vs time\n    ax1.plot(t, y[0], 'b-', label=f'Position ({method})')\n    ax1.set_xlabel('Time')\n    ax1.set_ylabel('Position')\n    ax1.grid(True)\n    ax1.legend()\n\n    # Phase space\n    ax2.plot(y[0], y[1], 'r-', label=f'Phase Space ({method})')\n    ax2.set_xlabel('Position')\n    ax2.set_ylabel('Velocity')\n    ax2.grid(True)\n    ax2.legend()\n\n    plt.tight_layout()\n    plt.show()\n\n    return t, y\n\n# Compare different methods\nmethods = ['RK45', 'RK23', 'DOP853', 'BDF', 'LSODA']\n\ndef compare_scipy_methods(T=20.0, x0=1.0, v0=0.0, omega=1.0):\n    \"\"\"Compare different SciPy integration methods\"\"\"\n    plt.figure(figsize=get_size(15, 10))\n\n    for method in methods:\n        t, y = solve_ho_ivp(T, x0, v0, omega, method)\n        plt.plot(t, y[0], label=method, alpha=0.7)\n\n    plt.xlabel('Time')\n    plt.ylabel('Position')\n    plt.title('Comparison of Integration Methods')\n    plt.grid(True)\n    plt.legend()\n    plt.show()\n\n# Run comparison\ncompare_scipy_methods()\n```\n\n::: {.callout-note}\n## Available Methods in solve_ivp\n\n1. **RK45** (default):\n   - Explicit Runge-Kutta method of order 5(4)\n   - Good general-purpose method\n   - Adaptive step size\n\n2. **RK23**:\n   - Explicit Runge-Kutta method of order 3(2)\n   - Usually faster but less accurate than RK45\n   - Good for rough solutions\n\n3. **DOP853**:\n   - Explicit Runge-Kutta method of order 8\n   - High accuracy\n   - More expensive computationally\n\n4. **BDF**:\n   - Implicit method\n   - Good for stiff problems\n   - Variable order (1 to 5)\n\n5. **LSODA**:\n   - Automatic method switching\n   - Adapts between Adams and BDF\n   - Good all-purpose solver\n:::\n\n### Advantages of SciPy Methods\n\n1. **Adaptive Step Size**:\n   - Automatically adjusts step size for efficiency\n   - Maintains desired accuracy\n   - Handles rapid changes better\n\n2. **Error Control**:\n   - Specified through relative and absolute tolerances\n   - Ensures solution reliability\n   - Provides error estimates\n\n3. **Method Selection**:\n   - Choose method based on problem characteristics\n   - Automatic stiffness detection (LSODA)\n   - Higher-order methods available\n\n4. **Dense Output**:\n   - Continuous solution representation\n   - Interpolation between steps\n   - Efficient for plotting or further analysis\n\n```{pyodide}\ndef analyze_efficiency():\n    \"\"\"Compare computational efficiency of different methods\"\"\"\n    import time\n\n    results = {}\n    T = 100.0  # longer time period for better comparison\n\n    for method in methods:\n        start_time = time.time()\n        _, _ = solve_ho_ivp(T, method=method)\n        end_time = time.time()\n        results[method] = end_time - start_time\n\n    # Plot timing results\n    plt.figure(figsize=get_size(10, 6))\n    plt.bar(results.keys(), results.values())\n    plt.ylabel('Computation Time (s)')\n    plt.title('Computational Efficiency Comparison')\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    plt.show()\n\n# Run efficiency analysis\nanalyze_efficiency()\n```\n\n\n## Damped Driven Pendulum\n\nThe damped driven pendulum is an excellent example of a nonlinear system that can exhibit both regular and chaotic behavior.\n\n::: {.callout-note}\n## The Damped Driven Pendulum Equation\n\nThe equation of motion is:\n\n\\begin{equation}\n\\ddot{\\theta} + \\frac{g}{L}\\sin(\\theta) + b\\dot{\\theta} = \\beta\\cos(\\omega t)\n\\end{equation}\n\nwhere:\n- $\\theta$ is the angle from vertical\n- $g$ is gravitational acceleration\n- $L$ is pendulum length\n- $b$ is damping coefficient\n- $\\beta$ is driving amplitude\n- $\\omega$ is driving frequency\n:::\n\n```{pyodide}\ndef damped_driven_pendulum(state, t, g=9.81, L=1.0, b=0.2, beta=1.0, omega=2/3):\n    \"\"\"\n    Define the damped driven pendulum system.\n\n    Parameters:\n    -----------\n    state : array_like\n        [theta, omega] - angle and angular velocity\n    t : float\n        Time\n    g : float\n        Gravitational acceleration\n    L : float\n        Pendulum length\n    b : float\n        Damping coefficient\n    beta : float\n        Driving amplitude\n    omega : float\n        Driving frequency\n\n    Returns:\n    --------\n    array_like\n        Derivatives [dtheta/dt, domega/dt]\n    \"\"\"\n    theta, theta_dot = state\n\n    # Angular acceleration\n    theta_ddot = -g/L * np.sin(theta) - b*theta_dot + beta*np.cos(omega*t)\n\n    return [theta_dot, theta_ddot]\n\nclass PendulumSimulation:\n    \"\"\"Class to handle pendulum simulation and analysis\"\"\"\n\n    def __init__(self, g=9.81, L=1.0, b=0.2, beta=1.0, omega=2/3):\n        self.params = {\n            'g': g,\n            'L': L,\n            'b': b,\n            'beta': beta,\n            'omega': omega\n        }\n\n    def solve_pendulum(self, T=100.0, theta0=0.1, omega0=0.0, N=10000):\n        \"\"\"Solve pendulum equation for given time period\"\"\"\n        t = np.linspace(0, T, N)\n        y0 = [theta0, omega0]\n\n        solution = odeint(damped_driven_pendulum, y0, t, args=(\n            self.params['g'], self.params['L'],\n            self.params['b'], self.params['beta'],\n            self.params['omega']))\n\n        return t, solution\n\n    def plot_solution(self, T=100.0, theta0=0.1, omega0=0.0, N=10000):\n        \"\"\"Plot the pendulum motion\"\"\"\n        t, solution = self.solve_pendulum(T, theta0, omega0, N)\n\n        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=get_size(15, 18))\n\n        # Angle vs time\n        ax1.plot(t, solution[:, 0], 'b-', label='θ(t)')\n        ax1.set_xlabel('Time')\n        ax1.set_ylabel('Angle θ')\n        ax1.grid(True)\n        ax1.legend()\n\n        # Angular velocity vs time\n        ax2.plot(t, solution[:, 1], 'r-', label='ω(t)')\n        ax2.set_xlabel('Time')\n        ax2.set_ylabel('Angular Velocity ω')\n        ax2.grid(True)\n        ax2.legend()\n\n        # Phase space\n        ax3.plot(solution[:, 0], solution[:, 1], 'g-', label='Phase Space')\n        ax3.set_xlabel('Angle θ')\n        ax3.set_ylabel('Angular Velocity ω')\n        ax3.grid(True)\n        ax3.legend()\n\n        plt.tight_layout()\n        plt.show()\n\n    def phase_space_analysis(self, T=100.0, n_trajectories=5):\n        \"\"\"Analyze phase space with multiple initial conditions\"\"\"\n        theta0_range = np.linspace(-np.pi, np.pi, n_trajectories)\n\n        plt.figure(figsize=get_size(12, 12))\n\n        for theta0 in theta0_range:\n            _, solution = self.solve_pendulum(T, theta0=theta0)\n            plt.plot(solution[:, 0], solution[:, 1], '-', alpha=0.5,\n                    label=f'θ₀ = {theta0:.2f}')\n\n        plt.xlabel('Angle θ')\n        plt.ylabel('Angular Velocity ω')\n        plt.title('Phase Space Analysis')\n        plt.grid(True)\n        plt.legend()\n        plt.show()\n\n    def poincare_section(self, T=1000.0, N=100000):\n        \"\"\"Generate Poincaré section\"\"\"\n        t, solution = self.solve_pendulum(T, N=N)\n\n        # Find points where driving force period is complete\n        dt = t[1] - t[0]\n        drive_period = 2*np.pi/self.params['omega']\n        points_per_period = int(drive_period/dt)\n\n        # Extract points\n        indices = np.arange(0, len(t), points_per_period)\n\n        plt.figure(figsize=get_size(10, 10))\n        plt.scatter(solution[indices, 0], solution[indices, 1],\n                   s=1, c='b', alpha=0.5)\n        plt.xlabel('Angle θ')\n        plt.ylabel('Angular Velocity ω')\n        plt.title('Poincaré Section')\n        plt.grid(True)\n        plt.show()\n\n# Create simulation instances with different parameters\ndef demonstrate_pendulum_behavior():\n    \"\"\"Demonstrate different pendulum behaviors\"\"\"\n\n    # Regular motion\n    print(\"Regular Motion (small driving force)\")\n    pendulum1 = PendulumSimulation(beta=0.5, omega=2/3)\n    pendulum1.plot_solution(T=50)\n\n    # Chaotic motion\n    print(\"\\nChaotic Motion (larger driving force)\")\n    pendulum2 = PendulumSimulation(beta=1.5, omega=2/3)\n    pendulum2.plot_solution(T=50)\n\n    # Phase space analysis\n    print(\"\\nPhase Space Analysis\")\n    pendulum1.phase_space_analysis()\n\n    # Poincaré section for chaotic case\n    print(\"\\nPoincaré Section (Chaotic Case)\")\n    pendulum2.poincare_section()\n\n# Run demonstrations\ndemonstrate_pendulum_behavior()\n```\n\n### Parameter Study: Transition to Chaos\n\nLet's examine how the system behavior changes with driving amplitude:\n\n```{pyodide}\ndef parameter_study(beta_range=np.linspace(0.1, 2.0, 5)):\n    \"\"\"Study system behavior for different driving amplitudes\"\"\"\n\n    fig, axes = plt.subplots(len(beta_range), 1,\n                            figsize=get_size(15, 4*len(beta_range)))\n\n    for i, beta in enumerate(beta_range):\n        pendulum = PendulumSimulation(beta=beta)\n        t, solution = pendulum.solve_pendulum(T=50)\n\n        axes[i].plot(t, solution[:, 0], 'b-', alpha=0.7)\n        axes[i].set_ylabel('θ')\n        axes[i].set_title(f'β = {beta:.2f}')\n        axes[i].grid(True)\n\n    axes[-1].set_xlabel('Time')\n    plt.tight_layout()\n    plt.show()\n\n# Run parameter study\nparameter_study()\n```\n\n::: {.callout-note}\n## Key Features of the Damped Driven Pendulum\n\n1. **Regular Motion**:\n   - Small driving forces lead to periodic motion\n   - System settles into a stable orbit\n   - Predictable long-term behavior\n\n2. **Chaotic Motion**:\n   - Larger driving forces can lead to chaos\n   - Sensitive dependence on initial conditions\n   - Unpredictable long-term behavior\n\n3. **Bifurcations**:\n   - System can transition between different types of motion\n   - Critical points where behavior changes qualitatively\n   - Period doubling route to chaos\n\n4. **Energy Balance**:\n   - Driving force adds energy\n   - Damping removes energy\n   - Competition leads to rich dynamics\n:::\n\n### Energy Analysis\n\nLet's analyze the system's energy over time:\n\n```{pyodide}\ndef energy_analysis(pendulum, T=50.0):\n    \"\"\"Analyze system energy components\"\"\"\n    t, solution = pendulum.solve_pendulum(T)\n\n    # Calculate energies\n    theta, theta_dot = solution[:, 0], solution[:, 1]\n    g, L = pendulum.params['g'], pendulum.params['L']\n\n    # Kinetic energy\n    KE = 0.5 * (L * theta_dot)**2\n\n    # Potential energy\n    PE = g * L * (1 - np.cos(theta))\n\n    # Total mechanical energy\n    E = KE + PE\n\n    plt.figure(figsize=get_size(12, 8))\n    plt.plot(t, KE, 'r-', label='Kinetic', alpha=0.7)\n    plt.plot(t, PE, 'b-', label='Potential', alpha=0.7)\n    plt.plot(t, E, 'k-', label='Total', alpha=0.7)\n    plt.xlabel('Time')\n    plt.ylabel('Energy')\n    plt.title('Energy Components')\n    plt.grid(True)\n    plt.legend()\n    plt.show()\n\n# Regular and chaotic cases\npendulum_regular = PendulumSimulation(beta=0.5)\npendulum_chaotic = PendulumSimulation(beta=1.5)\n\nprint(\"Energy Analysis - Regular Motion\")\nenergy_analysis(pendulum_regular)\n\nprint(\"\\nEnergy Analysis - Chaotic Motion\")\nenergy_analysis(pendulum_chaotic)\n```\n\nThis completes our analysis of the damped driven pendulum, demonstrating its rich dynamical behavior and various analysis techniques. The system serves as an excellent example of how nonlinearity can lead to complex behavior in even seemingly simple mechanical systems.\n\n",
    "supporting": [
      "4_solving_ODEs_files"
    ],
    "filters": [],
    "includes": {}
  }
}