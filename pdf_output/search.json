[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Computer-based Physical Modeling",
    "section": "",
    "text": "1 Welcome to Computer-Based Physical Modelling!\nThe programming language Python is useful for all kinds of scientific and technical tasks. You can use it to analyze and visualize data. You can also use it to numerically solve scientific problems that are difficult or impossible to solve analytically. Python is freely available and, due to its modular structure, has been expanded with an almost infinite number of modules for various purposes.\nThis course aims to introduce you to programming with Python. It is primarily aimed at beginners, but we hope it will also be interesting for advanced users. We begin the course with an introduction to the Jupyter Notebook environment, which we will use throughout the entire course. Afterward, we will provide an introduction to Python and show you some basic functions, such as plotting and analyzing data through curve fitting, reading and writing files, which are some of the tasks you will encounter during your physics studies. We will also show you some advanced topics such as animation in Jupyter and the simulation of physical processes in\n\nMechanics\nElectrostatics\nWaves\nOptics\n\nIf there is time left at the end of the course, we will also take a look at machine learning methods, which have become an important tool in physics as well.\nWe will not present a comprehensive list of numerical simulation schemes, but rather use the examples to spark your curiosity. Since there are slight differences in the syntax of the various Python versions, we will always refer to the Python 3 standard in the following.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CBPM 2025</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/00-lecture01.html",
    "href": "lectures/lecture01/00-lecture01.html",
    "title": "2  Programming Background Questionnaire",
    "section": "",
    "text": "Please complete this short questionnaire to help tailor the course to your needs. Your responses are anonymous and will be used only to adapt the teaching to your level of experience.\n\n  Loading…",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Programming Background Questionnaire</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html",
    "href": "lectures/lecture01/01-lecture01.html",
    "title": "3  Jupyter Notebooks",
    "section": "",
    "text": "3.1 What is a Jupyter Notebook?\nThroughout this course we will have to create and edit python code. We will primarily use this webpage for convenience, but for day-to-day work in the laboratory, it’s beneficial to utilize a code editor or a notebook environment like JupyterLab. JupyterLab is a robust platform that enables you to develop and modify notebooks within a web browser, while also offering comprehensive capabilities for analyzing and visualizing data.\nA Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#what-is-a-jupyter-notebook",
    "href": "lectures/lecture01/01-lecture01.html#what-is-a-jupyter-notebook",
    "title": "3  Jupyter Notebooks",
    "section": "",
    "text": "3.1.1 Key Components of a Notebook\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\n3.1.1.1 Notebook Editor\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It enables users to write and run code, add rich text, and multimedia content. When running Jupyter on a server, users typically use either the classic Jupyter Notebook interface or JupyterLab, an advanced version with more features.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\n3.1.2 Kernels\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\n3.1.3 JupyterLab Example\nThe following is an example of a JupyterLab interface with a notebook editor, code cells, markdown cells, and a kernel selector:\nFull Screen\n\n\n\n\n\n3.1.4 Notebook Documents\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "href": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "title": "3  Jupyter Notebooks",
    "section": "3.2 Using the Notebook Editor",
    "text": "3.2 Using the Notebook Editor\n\n\n\nJupyter Notebook Editor\n\n\nThe Jupyter Notebook editor provides an interactive environment for writing code, creating visualizations, and documenting computational workflows. It consists of a web-based interface that allows users to create and edit notebook documents containing code, text, equations, images, and interactive elements. A Jupyter Notebook provides an interface with essentially two modes of operation:\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab you can also have a presentation mode where you can present your notebook as a slideshow.\n\n3.2.1 Edit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area when a cell is selected. You can enter edit mode by pressing Enter or using the mouse to click on a cell’s editor area.\n\n\n\nEdit Mode\n\n\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor\n\n\n3.2.2 Command mode\nCommand mode is indicated by a grey cell border with a blue left margin. When you are in command mode, you are able to edit the notebook as a whole, but not type into individual cells. Most importantly, in command mode, the keyboard is mapped to a set of shortcuts that let you perform notebook and cell actions efficiently.\n\n\n\nCommand Mode\n\n\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\n3.2.3 Keyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor area. Thus, in edit mode there are relatively few shortcuts available. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\n3.2.4 Running code\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\n\n23752636\n\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "href": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "title": "3  Jupyter Notebooks",
    "section": "3.3 Managing the kernel",
    "text": "3.3 Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "href": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "title": "3  Jupyter Notebooks",
    "section": "3.4 Markdown in Notebooks",
    "text": "3.4 Markdown in Notebooks\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\n3.4.1 Markdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold. You can build nested itemized or enumerated lists:\n\n\n3.4.2 Markdown lists example\n\nFirst item\n\nFirst subitem\n\nFirst sub-subitem\n\nSecond subitem\n\nFirst subitem of second subitem\nSecond subitem of second subitem\n\n\nSecond item\n\nFirst subitem\n\nThird item\n\nFirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\n\n\n3.4.3 Blockquote example\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Namespaces are one honking great idea – let’s do more of those!\n\n\n\n3.4.4 Web links example\nJupyter’s website\n\n\n3.4.5 Headings\nYou can add headings by starting a line with one (or multiple) # followed by a space and the title of your section. The number of # you use will determine the size of the heading\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\n3.4.6 Embedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\n\n\n3.4.7 LaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\n3.4.8 Images\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\n\n3.4.9 Videos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/python_lecture01.html",
    "href": "lectures/lecture01/python_lecture01.html",
    "title": "4  Python & Anatomy of a Python Program",
    "section": "",
    "text": "4.1 What is Python?\nPython is a high-level, interpreted programming language known for its readability and simplicity. Created by Guido van Rossum in 1991, it emphasizes code readability with its clear syntax and use of indentation. Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming. It comes with a comprehensive standard library and has a vast ecosystem of third-party packages, making it suitable for various applications such as web development, data analysis, artificial intelligence, scientific computing, and automation. Python’s “batteries included” philosophy and gentle learning curve have contributed to its popularity among beginners and experienced developers alike.\nFor physics students specifically, Python has become the language of choice for data analysis, simulation, and visualization in scientific research. Libraries like NumPy, SciPy, and Matplotlib provide powerful tools for solving physics problems, from basic mechanics to quantum mechanics.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python & Anatomy of a Python Program</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/python_lecture01.html#anatomy-of-a-python-program",
    "href": "lectures/lecture01/python_lecture01.html#anatomy-of-a-python-program",
    "title": "4  Python & Anatomy of a Python Program",
    "section": "4.2 Anatomy of a Python Program",
    "text": "4.2 Anatomy of a Python Program\nUnderstanding the basic structure of a Python program is essential for beginners. Let’s break down the fundamental elements that make up a typical Python program.\n\n4.2.1 Basic Elements\n\n\n\n\n\n\n\n\nElement\nDescription\nExample\n\n\n\n\nStatements\nIndividual instructions that Python executes\nx = 10\n\n\nExpressions\nCombinations of values, variables, and operators that evaluate to a value\nx + 5\n\n\nBlocks\nGroups of statements indented at the same level\nFunction bodies, loops\n\n\nFunctions\nReusable blocks of code that perform specific tasks\ndef calculate_area(radius):\n\n\nComments\nNotes in the code that are ignored by the interpreter\n# This is a comment\n\n\nImports\nStatements that give access to external modules\nimport numpy as np\n\n\n\n\n\n4.2.2 Visual Structure of a Python Program\n# 1. Import statements (external libraries)\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint  # For solving differential equations\n\n# 2. Constants and global variables\nGRAVITY = 9.81  # m/s^2\nPLANCK_CONSTANT = 6.626e-34  # J·s\nELECTRON_MASS = 9.109e-31  # kg\n\n# 3. Function definitions\ndef calculate_kinetic_energy(mass, velocity):\n    \"\"\"\n    Calculate the kinetic energy of an object.\n\n    Parameters:\n        mass (float): Mass of the object in kg\n        velocity (float): Velocity of the object in m/s\n\n    Returns:\n        float: Kinetic energy in Joules\n    \"\"\"\n    return 0.5 * mass * velocity**2\n\ndef spring_force(k, displacement):\n    \"\"\"\n    Calculate the force exerted by a spring.\n\n    Parameters:\n        k (float): Spring constant in N/m\n        displacement (float): Displacement from equilibrium in m\n\n    Returns:\n        float: Force in Newtons (negative for restoring force)\n    \"\"\"\n    return -k * displacement\n\n# 4. Class definitions (if applicable)\nclass Particle:\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = position\n        self.velocity = velocity\n\n    def update_position(self, time_step):\n        # Simple Euler integration\n        self.position += self.velocity * time_step\n\n    def potential_energy(self, height, g=GRAVITY):\n        \"\"\"Calculate gravitational potential energy\"\"\"\n        return self.mass * g * height\n\n    def momentum(self):\n        \"\"\"Calculate momentum\"\"\"\n        return self.mass * self.velocity\n\n# 5. Main execution code\nif __name__ == \"__main__\":\n    # Create objects or variables\n    particle = Particle(1.0, np.array([0.0, 0.0]), np.array([1.0, 2.0]))\n\n    # Set up simulation parameters\n    time_step = 0.01  # seconds\n    total_time = 1.0  # seconds\n    n_steps = int(total_time / time_step)\n\n    # Arrays to store results\n    positions = np.zeros((n_steps, 2))\n    times = np.zeros(n_steps)\n\n    # Process data/perform calculations - simulate motion\n    for i in range(n_steps):\n        particle.update_position(time_step)\n        positions[i] = particle.position\n        times[i] = i * time_step\n\n    # Output results\n    print(f\"Final position: {particle.position}\")\n    print(f\"Final kinetic energy: {calculate_kinetic_energy(particle.mass, np.linalg.norm(particle.velocity))} J\")\n\n    # Visualize results (if applicable)\n    plt.figure(figsize=(10, 6))\n    plt.subplot(1, 2, 1)\n    plt.plot(positions[:, 0], positions[:, 1], 'r-')\n    plt.xlabel('X position (m)')\n    plt.ylabel('Y position (m)')\n    plt.title('Particle Trajectory')\n    plt.grid(True)\n\n    plt.subplot(1, 2, 2)\n    plt.plot(times, positions[:, 0], 'b-', label='x-position')\n    plt.plot(times, positions[:, 1], 'g-', label='y-position')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    plt.title('Position vs Time')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n\n4.2.3 Key Concepts\n\nModularity: Python programs are typically organized into functions and classes that encapsulate specific functionality.\nIndentation: Python uses indentation (typically 4 spaces) to define code blocks, unlike other languages that use braces {}.\nDocumentation: Good Python code includes docstrings (triple-quoted strings) that explain what functions and classes do.\nMain Block: The if __name__ == \"__main__\": block ensures code only runs when the file is executed directly, not when imported.\nReadability: Python emphasizes code readability with clear variable names and logical organization.\nPhysics Modeling: For physics problems, we typically model physical systems as objects with properties (mass, position, etc.) and behaviors (update_position, calculate_energy, etc.).\nNumerical Integration: Many physics problems require solving differential equations numerically using methods like Euler integration or Runge-Kutta.\nUnits: Always include appropriate SI units in your comments and documentation to ensure clarity in physics calculations.\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nKeep functions short and focused on a single task\nUse meaningful variable and function names\nInclude comments to explain why rather than what (the code should be self-explanatory)\nFollow PEP 8 style guidelines for consistent formatting\nStructure larger programs into multiple modules (files)\nFor physics simulations, validate your code against known analytical solutions when possible\nRemember to handle units consistently throughout your calculations\nConsider the appropriate numerical methods for the physical system you’re modeling\n\n\n\n\n\n\n\n\n\n\nPhysics-Specific Python Libraries\n\n\n\n\n\n\nNumPy: Provides array operations and mathematical functions\nSciPy: Scientific computing tools including optimization, integration, and differential equations\nMatplotlib: Plotting and visualization\nSymPy: Symbolic mathematics for analytical solutions\nPandas: Data manipulation and analysis\nastropy: Astronomy and astrophysics\nscikit-learn: Machine learning for data analysis\nPyMC: Probabilistic programming for statistical analysis",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python & Anatomy of a Python Program</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html",
    "href": "lectures/lecture01/02-lecture01.html",
    "title": "5  Variables & Numbers",
    "section": "",
    "text": "5.1 Variables in Python",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "href": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "title": "5  Variables & Numbers",
    "section": "",
    "text": "5.1.1 Symbol Names\nVariable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nPython has keywords that cannot be used as variable names. The most common ones you’ll encounter in physics programming are:\nif, else, for, while, return, and, or, lambda\nNote that lambda is particularly relevant as it could naturally appear in physics code, but since it’s reserved for anonymous functions in Python, it cannot be used as a variable name.\n\n\n\n\n5.1.2 Variable Assignment\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#number-types",
    "href": "lectures/lecture01/02-lecture01.html#number-types",
    "title": "5  Variables & Numbers",
    "section": "5.2 Number Types",
    "text": "5.2 Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers. These are some of the basic building blocks of doing arithmetic in any programming language. We will discuss each of these types in more detail.\n\n5.2.1 Comparison of Number Types\n\n\n\n\n\n\n\n\n\n\n\nType\nExample\nDescription\nLimits\nUse Cases\n\n\n\n\nint\n42\nWhole numbers\nUnlimited precision (bounded by available memory)\nCounting, indexing\n\n\nfloat\n3.14159\nDecimal numbers\nTypically ±1.8e308 with 15-17 digits of precision (64-bit)\nScientific calculations, prices\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts\nSame as float for both real and imaginary parts\nSignal processing, electrical engineering\n\n\nbool\nTrue / False\nLogical values\nOnly two values: True (1) and False (0)\nConditional operations, flags\n\n\n\n\n\n\n5.2.2 Examples\n\nIntegersFloating Point NumbersComplex Numbers\n\n\nInteger Representation: Integers are whole numbers without a decimal point.\n\n\n\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n\n\n\n\n\n\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\n\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n\n\n\n\n\n\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\n\n\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\n\n\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#operators",
    "href": "lectures/lecture01/02-lecture01.html#operators",
    "title": "5  Variables & Numbers",
    "section": "5.3 Operators",
    "text": "5.3 Operators\nPython provides a variety of operators for performing operations on variables and values. Here we’ll cover the most common operators used in scientific programming.\n\nArithmetic OperatorsComparison OperatorsLogical OperatorsAssignment Operators\n\n\nThese operators perform basic mathematical operations:\n\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n+\nAddition\n5 + 3\n8\n\n\n-\nSubtraction\n5 - 3\n2\n\n\n*\nMultiplication\n5 * 3\n15\n\n\n/\nDivision\n5 / 3\n1.6666…\n\n\n//\nFloor Division\n5 // 3\n1\n\n\n%\nModulus (remainder)\n5 % 3\n2\n\n\n**\nExponentiation\n5 ** 3\n125\n\n\n\n\n\n\n\n\n\n\n\nThese operators are used to compare values:\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n==\nEqual to\nx == y\n\n\n!=\nNot equal to\nx != y\n\n\n&gt;\nGreater than\nx &gt; y\n\n\n&lt;\nLess than\nx &lt; y\n\n\n&gt;=\nGreater than or equal to\nx &gt;= y\n\n\n&lt;=\nLess than or equal to\nx &lt;= y\n\n\n\n\n\n\n\n\n\n\n\nUsed to combine conditional statements:\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\n\n\n\n\nand\nReturns True if both statements are true\nx &gt; 0 and x &lt; 10\n\n\nor\nReturns True if one of the statements is true\nx &lt; 0 or x &gt; 10\n\n\nnot\nReverses the result, returns False if the result is true\nnot(x &gt; 0 and x &lt; 10)\n\n\n\n\n\n\n\n\n\n\n\nPython provides shorthand operators for updating variables:\n\n\n\nOperator\nExample\nEquivalent to\n\n\n\n\n=\nx = 5\nx = 5\n\n\n+=\nx += 3\nx = x + 3\n\n\n-=\nx -= 3\nx = x - 3\n\n\n*=\nx *= 3\nx = x * 3\n\n\n/=\nx /= 3\nx = x / 3\n\n\n//=\nx //= 3\nx = x // 3\n\n\n%=\nx %= 3\nx = x % 3\n\n\n**=\nx **= 3\nx = x ** 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperator Precedence\n\n\n\n\n\nPython follows the standard mathematical order of operations (PEMDAS):\n\nParentheses\nExponentiation (**)\nMultiplication and Division (*, /, //, %)\nAddition and Subtraction (+, -)\n\nWhen operators have the same precedence, they are evaluated from left to right.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html",
    "href": "lectures/lecture02/01-lecture02.html",
    "title": "6  Data Types",
    "section": "",
    "text": "6.1 Data Types\nIt’s time to look at different data types we may find useful in our course. Besides the number types mentioned previously, there are also other types like strings, lists, tuples, dictionaries and sets.\nEach of these data types has a number of connected methods (functions) which allow you to manipulate the data contained in a variable. If you want to know which methods are available for a certain object use the command dir, e.g.\nThe output would be:\nThe following few cells will give you a short introduction into each type.",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Types</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#data-types",
    "href": "lectures/lecture02/01-lecture02.html#data-types",
    "title": "6  Data Types",
    "section": "",
    "text": "Numeric TypesStringsListsTuplesDictionariesBooleanSets\n\n\nPython supports several numeric data types including integers, floats, and complex numbers.\n\n\n\n\n\n\nYou can perform various arithmetic operations with numeric types:\n\n\n\n\n\n\nType conversion works between numeric types:\n\n\n\n\n\n\n\n\nStrings are lists of keyboard characters as well as other characters not on your keyboard. They are useful for printing results on the screen, during reading and writing of data.\n\n\n\n\n\n\n\n\n\n\n\n\nString can be concatenated using the + operator.\n\n\n\n\n\n\n\n\n\n\n\n\nAs strings are lists, each character in a string can be accessed by addressing the position in the string (see Lists section)\n\n\n\n\n\n\nStrings can also be made out of numbers.\n\n\n\n\n\n\nIf you want to obtain a number of a string, you can use what is known as type casting. Using type casting you may convert the string or any other data type into a different type if this is possible. To find out if a string is a pure number you may use the str.isnumeric method. For the above string, we may want to do a conversion to the type int by typing:\n\n\n\n\n\n\n\n\n\n\n\n\nThere are a number of methods connected to the string data type. Usually the relate to formatting or finding sub-strings. Formatting will be a topic in our next lecture. Here we just refer to one simple find example.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLists are ordered, mutable collections that can store items of different data types.\n\n\n\n\n\n\nYou can access and modify list elements:\n\n\n\n\n\n\nCommon list methods:\n\n\n\n\n\n\n\n\nTuples are ordered, immutable sequences.\n\n\n\n\n\n\nTuples are immutable, meaning you cannot change their elements after creation:\n\n\n\n\n\n\n\n\nDictionaries store data as key-value pairs. They are mutable and unordered.\n\n\n\n\n\n\nAccessing and modifying dictionary elements:\n\n\n\n\n\n\nCommon dictionary methods:\n\n\n\n\n\n\n\n\nThe Boolean type has only two possible values: True and False.\n\n\n\n\n\n\nBoolean values are commonly used in conditional statements:\n\n\n\n\n\n\nBoolean operations:\n\n\n\n\n\n\n\n\nSets are unordered collections of unique elements.\n\n\n\n\n\n\nCommon set operations:\n\n\n\n\n\n\nAdding and removing elements:",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Types</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#type-casting",
    "href": "lectures/lecture02/01-lecture02.html#type-casting",
    "title": "6  Data Types",
    "section": "6.2 Type Casting",
    "text": "6.2 Type Casting\nType casting is the process of converting a value from one data type to another. Python provides built-in functions for type conversion.\nPython offers several built-in functions for type conversion: - int(): Converts to integer - float(): Converts to float - str(): Converts to string - bool(): Converts to boolean - list(): Converts to list - tuple(): Converts to tuple - set(): Converts to set - dict(): Converts from mappings or iterables of key-value pairs\nLet’s explore various type conversion examples with practical code demonstrations. These examples show how Python handles conversions between different data types.\nNumeric Conversions\nWhen converting between numeric types, it’s important to understand how precision and data may change. For example, converting floats to integers removes the decimal portion without rounding.\n\n\n\n\n\n\nString Conversions\nString conversions are commonly used when processing user input or preparing data for output. Python provides straightforward functions for converting between strings and numeric types.\n\n\n\n\n\n\nCollection Type Conversions\nPython allows for easy conversion between different collection types, which is useful for changing the properties of your data structure (like making elements unique with sets).\n\n\n\n\n\n\nBoolean Conversion\nBoolean conversion is essential for conditional logic. Python follows specific rules to determine truthiness of values, with certain “empty” or “zero” values converting to False.\nWhen converting to boolean with bool(), the following values are considered False: - 0 (integer) - 0.0 (float) - \"\" (empty string) - [] (empty list) - () (empty tuple) - {} (empty dictionary) - set() (empty set) - None\nEverything else converts to True.\n\n\n\n\n\n\nSpecial Cases and Errors\nType conversion can sometimes fail, especially when the source value cannot be logically converted to the target type. Understanding these limitations helps prevent runtime errors in your code.\nNot all type conversions are possible. Python will raise an error when the conversion is not possible.\n\n\n\n\n\n\nTo handle potential errors in type conversion, you can use exception handling with try/except blocks:",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Types</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html",
    "href": "lectures/lecture02/02-lecture02.html",
    "title": "7  Python Overview",
    "section": "",
    "text": "7.1 Control Structures and Functions\nBuilding on our understanding of Python’s basic data types and operations, we’ll now explore how to control program flow and create reusable code blocks. These structures allow us to write more sophisticated programs that can make decisions, repeat operations, and organize code efficiently.",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#control-structures-and-functions",
    "href": "lectures/lecture02/02-lecture02.html#control-structures-and-functions",
    "title": "7  Python Overview",
    "section": "",
    "text": "7.1.1 Functions\nFunctions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n7.1.2 Loops\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n\nFor LoopWhile Loop\n\n\nA for loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here’s an example:\n\n\n\n\n\n\n\n\nA while loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n7.1.3 Conditional Statements\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are if, else, and elif.\n\nIf StatementElse StatementElif Statement\n\n\nAn if statement in Python is used to execute a block of code if a certain condition is met. Here’s an example:\n\n\n\n\n\n\n\n\nAn else statement in Python is used to execute a block of code if the condition in an if statement is not met. Here’s an example:\n\n\n\n\n\n\n\n\nAn elif statement in Python is used to execute a block of code if the condition in an if statement is not met but under an extra condition. Here’s an example:",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#exercises",
    "href": "lectures/lecture02/02-lecture02.html#exercises",
    "title": "7  Python Overview",
    "section": "7.2 Exercises",
    "text": "7.2 Exercises\nThe following exercises will help you practice using functions with conditional logic.\n\n\n\n\n\n\nExercise 1: Temperature Conversion Function\n\n\n\nCreate a function that converts temperatures between Fahrenheit and Celsius scales. This exercise demonstrates how to define and use functions with conditional logic to perform different types of conversions based on user input.\nThe conversion formulas are: - Celsius to Fahrenheit: \\(F = (C \\times 9/5) + 32\\) - Fahrenheit to Celsius: \\(C = (F - 32) \\times 5/9\\)\nTime estimate: 15-20 minutes\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nUse an if-else statement to check the scale parameter. Depending on whether it’s ‘C’ or ‘F’, apply the appropriate conversion formula. Remember to return both the converted temperature value and the new scale designation (either ‘F’ or ‘C’).\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2: Prime Number Checker\n\n\n\nCreate a function that checks whether a given number is prime. This exercise demonstrates the use of loops, conditional statements, and early return to solve a common mathematical problem.\nA prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers.\nTime estimate: 15-20 minutes\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nFirst, check if the number is less than 2 (not prime). Then, use a loop to check if the number is divisible by any integer from 2 to the square root of the number. If you find a divisor, the number is not prime. If no divisors are found, the number is prime.\n\n\n\n\n\n\n\n\n\n\n\nNote",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html",
    "href": "lectures/lecture03/01-lecture03.html",
    "title": "8  Modules",
    "section": "",
    "text": "Most of the functionality in Python is provided by modules. The Python Standard Library is a large collection of modules that provides cross-platform implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\nTo use a module in a Python module it first has to be imported. A module can be imported using the import statement. For example, to import the module math, which contains many standard mathematical functions, we can do:\n\n\n\n\n\n\nThis includes the whole module and makes it available for use later in the program. Alternatively, we can chose to import all symbols (functions and variables) in a module so that we don’t need to use the prefix “math.” every time we use something from the math module:\n\n\n\n\n\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the import math pattern. This would eliminate potentially confusing problems.\n\n8.0.1 Namespaces\n\n\n\n\n\n\nNamespaces\n\n\n\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix math. we have used in the previous section is such a namespace. You may also create your own namespace for a module. This is done by using the import math as mymath pattern.\n\n\n\n\n\n\n\n\nYou may also only import specific functions of a module.\n\n\n\n\n\n\n\n\n8.0.2 Directory of a module\nOnce a module is imported, we can list the symbols it provides using the dir function:\n\n\n\n\n\n\nAnd using the function help we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also use the help function directly on modules: Try\nhelp(math)\nSome very useful modules form the Python standard library are os, sys, math, shutil, re, subprocess, multiprocessing, threading.\nA complete lists of standard modules for Python 3 is available at http://docs.python.org/3/library/ .\n\n\n8.0.3 Advanced topics\n\n\n\n\n\n\nCreate Your Own Modules\n\n\n\n\n\nCreating your own modules in Python is a great way to organize your code and make it reusable. A module is simply a file containing Python definitions and statements. Here’s how you can create and use your own module:\n\n8.0.3.1 Creating a Module\nTo create a module, you just need to save your Python code in a file with a .py extension. For example, let’s create a module named mymodule.py with the following content:\n# mymodule.py\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n\n8.0.3.2 Using Your Module\nOnce you have created your module, you can import it into other Python scripts using the import statement. Here’s an example of how to use the mymodule we just created:\n# main.py\n\nimport mymodule\n\n# Use the functions from mymodule\nprint(mymodule.greet(\"Alice\"))\nprint(mymodule.add(5, 3))\n\n\n8.0.3.3 Importing Specific Functions\nYou can also import specific functions from a module using the from ... import ... syntax:\n# main.py\n\nfrom mymodule import greet, add\n\n# Use the imported functions directly\nprint(greet(\"Bob\"))\nprint(add(10, 7))\n\n\n8.0.3.4 Module Search Path\nWhen you import a module, Python searches for the module in the following locations: 1. The directory containing the input script (or the current directory if no script is specified). 2. The directories listed in the PYTHONPATH environment variable. 3. The default directory where Python is installed.\nYou can view the module search path by printing the sys.path variable:\nimport sys\nprint(sys.path)\n\n\n8.0.3.5 Creating Packages\nA package is a way of organizing related modules into a directory hierarchy. A package is simply a directory that contains a special file named __init__.py, which can be empty. Here’s an example of how to create a package:\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\nYou can then import modules from the package using the dot notation:\n# main.py\n\nfrom mypackage import module1, module2\n\n# Use the functions from the modules\nprint(module1.some_function())\nprint(module2.another_function())\nCreating and using modules and packages in Python helps you organize your code better and makes it easier to maintain and reuse.\n\n\n8.0.3.6 Namespaces in Packages\nYou can also create sub-packages by adding more directories with __init__.py files. This allows you to create a hierarchical structure for your modules:\nmypackage/\n    __init__.py\n    subpackage/\n        __init__.py\n        submodule.py\nYou can then import submodules using the full package name:\n# main.py\n\nfrom mypackage.subpackage import submodule\n\n# Use the functions from the submodule\nprint(submodule.some_sub_function())",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html",
    "href": "lectures/lecture03/02-lecture03.html",
    "title": "9  NumPy Module",
    "section": "",
    "text": "9.1 Creating Numpy Arrays\nNumpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object and tools for working with these arrays. The NumPy array, formally called ndarray in NumPy documentation, is the real workhorse of data structures for scientific and engineering applications. The NumPy array is similar to a list but where all the elements of the list are of the same type. The elements of a NumPy array are usually numbers, but can also be booleans, strings, or other objects. When the elements are numbers, they must all be of the same type.\nFor physics applications, NumPy is essential because it enables efficient numerical calculations on large datasets, handling of vectors and matrices, and implementation of mathematical models that describe physical phenomena. Whether simulating particle motion, analyzing experimental data, or solving equations of motion, NumPy provides the computational foundation needed for modern physics.\nThere are a number of ways to initialize new numpy arrays, for example from",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#creating-numpy-arrays",
    "href": "lectures/lecture03/02-lecture03.html#creating-numpy-arrays",
    "title": "9  NumPy Module",
    "section": "",
    "text": "a Python list or tuples\nusing functions that are dedicated to generating numpy arrays, such as arange, linspace, etc.\nreading data from files which will be covered in the files section\n\n\nFrom listsUsing array-generating functions\n\n\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor larger arrays it is impractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in numpy that generate arrays of different forms. Some of the more common are:\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.1.0.1 linspace and logspace\nThe linspace function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50.\n\n\n\n\n\n\nlogspace is doing equivalent things with logarithmic spacing. Other types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n\n\n\n\n9.1.0.2 mgrid\nmgrid generates a multi-dimensional matrix with increasing value entries, for example in columns and rows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.1.0.3 diag\ndiag generates a diagonal matrix with the list supplied to it. The values can be also offset from the main diagonal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.1.0.4 zeros and ones\nzeros and ones creates a matrix with the dimensions given in the argument and filled with 0 or 1.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#array-attributes",
    "href": "lectures/lecture03/02-lecture03.html#array-attributes",
    "title": "9  NumPy Module",
    "section": "9.2 Array Attributes",
    "text": "9.2 Array Attributes\nNumPy arrays have several attributes that provide information about their size, shape, and data type. These attributes are essential for understanding and debugging your code.\n\nshapesizedtype\n\n\nThe shape attribute returns a tuple that gives the size of the array along each dimension.\n\n\n\n\n\n\n\n\nThe size attribute returns the total number of elements in the array.\n\n\n\n\n\n\n\n\nThe dtype attribute returns the data type of the array’s elements.\n\n\n\n\n\n\n\n\n\n\n\n\nThese attributes are particularly useful when debugging operations between arrays, as many NumPy functions require arrays of specific shapes or compatible data types.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#manipulating-numpy-arrays",
    "href": "lectures/lecture03/02-lecture03.html#manipulating-numpy-arrays",
    "title": "9  NumPy Module",
    "section": "9.3 Manipulating NumPy arrays",
    "text": "9.3 Manipulating NumPy arrays\n\nSlicingReshapingAdding a new dimension: newaxisStacking and repeating arrays\n\n\nSlicing is the name for extracting part of an array by the syntax M[lower:upper:step]\n\n\n\n\n\n\n\n\n\n\n\n\nAny of the three parameters in M[lower:upper:step] can be ommited.\n\n\n\n\n\n\n\n\n\n\n\n\nNegative indices counts from the end of the array (positive index from the begining):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex slicing works exactly the same way for multidimensional arrays:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifferences\n\n\n\nSlicing can be effectively used to calculate differences for example for the calculation of derivatives. Here the position \\(y_i\\) of an object has been measured at times \\(t_i\\) and stored in an array each. We wish to calculate the average velocity at the times \\(t_{i}\\) from the arrays by\n\\[\\begin{equation}\nv_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n\\end{equation}\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArrays can be reshaped into any form, which contains the same number of elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith newaxis, we can insert new dimensions in an array, for example converting a vector to a column or row matrix.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing function repeat, tile, vstack, hstack, and concatenate we can create larger vectors and matrices from smaller ones. Please try the individual functions yourself in your notebook. We wont discuss them in detail.\n\n9.3.0.1 Tile and repeat\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3.0.2 Concatenate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3.0.3 Hstack and vstack",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#applying-mathematical-functions",
    "href": "lectures/lecture03/02-lecture03.html#applying-mathematical-functions",
    "title": "9  NumPy Module",
    "section": "9.4 Applying mathematical functions",
    "text": "9.4 Applying mathematical functions\nAll kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below.\n\nOperation involving one arrayOperations involving multiple arraysRandom Numbers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVector operations enable efficient element-wise calculations where corresponding elements at matching positions are processed simultaneously. Instead of handling elements one by one, these operations work on entire arrays at once, making them particularly fast. When multiplying two vectors using these operations, the result is not a single number (as in a dot product) but rather a new array where each element is the product of the corresponding elements from the input vectors. This element-wise multiplication is just one example of vector operations, which can include addition, subtraction, and other mathematical functions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumPy provides powerful tools for generating random numbers, which are essential for simulations in statistical physics, quantum mechanics, and other fields:\n\n\n\n\n\n\nThese random number generators are particularly useful for Monte Carlo simulations, modeling thermal noise, or simulating quantum mechanical systems.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#broadcasting",
    "href": "lectures/lecture03/02-lecture03.html#broadcasting",
    "title": "9  NumPy Module",
    "section": "9.5 Broadcasting",
    "text": "9.5 Broadcasting\nBroadcasting is a powerful mechanism that allows NumPy to work with arrays of different shapes when performing arithmetic operations. The smaller array is “broadcast” across the larger array so that they have compatible shapes.\nThe rules for broadcasting are:\n\nIf the arrays don’t have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length.\nThe size in each dimension of the output shape is the maximum of the sizes of the input arrays along that dimension.\nAn input can be used in the calculation if its size in a particular dimension matches the output size or if its value is exactly 1.\nIf an input has a dimension size of 1, the first element is used for all calculations along that dimension.\n\nLet’s see some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBroadcasting enables efficient computation without the need to create copies of arrays, saving memory and computation time.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#physics-example-force-calculations",
    "href": "lectures/lecture03/02-lecture03.html#physics-example-force-calculations",
    "title": "9  NumPy Module",
    "section": "9.6 Physics Example: Force Calculations",
    "text": "9.6 Physics Example: Force Calculations\nBroadcasting is particularly useful in physics when applying the same operation to multiple objects. For example, when calculating the gravitational force between one massive object and multiple other objects using Newton’s law of universal gravitation:\n\\[\\begin{equation}\nF = \\frac{G M m}{r^2}\n\\end{equation}\\]\nwhere \\(F\\) is the gravitational force, \\(G\\) is the gravitational constant, \\(M\\) and \\(m\\) are the masses of the two objects, and \\(r\\) is the distance between them.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html",
    "href": "lectures/lecture03/03-lecture03.html",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "",
    "text": "10.1 Basic Plotting\nData visualization is an essential skill for analyzing and presenting scientific data effectively. Python itself doesn’t include plotting capabilities in its core language, but Matplotlib provides powerful and flexible tools for creating visualizations. Matplotlib is the most widely used plotting library in Python and serves as an excellent starting point for creating basic plots.\nMatplotlib works well with NumPy, Python’s numerical computing library, to create a variety of plot types including line plots, scatter plots, bar charts, and more. For this document, we’ve already imported both libraries as you can see in the code below:\nWe’ve also set up some default styling parameters to make our plots more readable and professional-looking:\nThese settings configure the appearance of our plots with appropriate font sizes, line widths, and tick marks. The get_size() function helps us convert dimensions from centimeters to inches, which is useful when specifying figure sizes. With these preparations complete, we’re ready to create various types of visualizations to effectively display our data.\nMatplotlib offers multiple levels of functionality for creating plots. Throughout this section, we’ll primarily focus on using commands that leverage default settings. This approach simplifies the process, as Matplotlib automatically handles much of the graph layout. These high-level commands are ideal for quickly creating effective visualizations without delving into intricate details. Later in this course, we’ll briefly touch upon more advanced techniques that provide greater control over plot elements and layout.\nTo create a basic line plot, use the following command:\nBy default, this generates a line plot. However, you can customize the appearance by adjusting various parameters within the plot() function. For instance, you can modify it to resemble a scatter plot by changing certain arguments. The versatility of this command allows for a range of visual representations beyond simple line plots.\nLet’s create a simple line plot of the sine function over the interval [0, 4π]. We’ll use NumPy to generate the x-values and calculate the corresponding y-values. The following code snippet demonstrates this process:\nHere is the code in a Python cell:\nTry to change the values of the x and y arrays and see how the plot changes.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html#basic-plotting",
    "href": "lectures/lecture03/03-lecture03.html#basic-plotting",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "",
    "text": "plt.plot(x, y)\n\n\n1x = np.linspace(0, 4.*np.pi, 100)\n2y = np.sin(x)\n\n3plt.figure(figsize=get_size(8,6))\n4plt.plot(x, y)\n5plt.tight_layout()\n6plt.show()\n\n1\n\nCreate an array of 100 values between 0 and 4π.\n\n2\n\nCalculate the sine of each value in the array.\n\n3\n\ncreate a new figure with a size of (8,6) cm\n\n4\n\nplot the data\n\n5\n\nautomatically adjust the layout\n\n6\n\nshow the figure\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy use plt.tight_layout()\n\n\n\n\n\nplt.tight_layout() is a very useful function in Matplotlib that automatically adjusts the spacing between plot elements to prevent overlapping and ensure that all elements fit within the figure area. Here’s what it does:\n\nPadding Adjustment: It adjusts the padding between and around subplots to prevent overlapping of axis labels, titles, and other elements.\nSubplot Spacing: It optimizes the space between multiple subplots in a figure.\nText Accommodation: It ensures that all text elements (like titles, labels, and legends) fit within the figure without being cut off.\nMargin Adjustment: It adjusts the margins around the entire figure to make sure everything fits neatly.\nAutomatic Resizing: If necessary, it can slightly resize subplot areas to accommodate all elements.\nLegend Positioning: It takes into account the presence and position of legends when adjusting layouts.\n\nKey benefits of using plt.tight_layout():\n\nIt saves time in manual adjustment of plot elements.\nIt helps create more professional-looking and readable plots.\nIt’s particularly useful when creating figures with multiple subplots or when saving figures to files.\n\nYou typically call plt.tight_layout() just before plt.show() or plt.savefig(). For example:\nplt.figure()\n# ... (your plotting code here)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html#customizing-plots",
    "href": "lectures/lecture03/03-lecture03.html#customizing-plots",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "10.2 Customizing Plots",
    "text": "10.2 Customizing Plots\n\nAxis LabelsLegendsPlotting Multiple LinesCustomizing Line AppearancePlots with Error BarsVisualizing NumPy Arrays\n\n\nTo enhance the clarity and interpretability of our plots, it’s crucial to provide context through proper labeling. The following commands add descriptive axis labels to our diagram:\nplt.xlabel('x-label')\nplt.ylabel('y-label')\nHere’s an example of adding labels to our sine plot:\n\n\n\n\n\n\n\n\nWhen plotting multiple datasets, it’s important to include a legend to identify each line. Use these commands:\nplt.plot(..., label='Label name')\nplt.legend(loc='lower left')\nHere’s an example with a legend:\n\n\n\n\n\n\n\n\nYou can add multiple lines to the same plot:\n\n\n\n\n\n\n\n\nYou can customize the appearance of lines with additional parameters:\n\n\n\n\n\n\n\n\nWhen plotting experimental data, it’s customary to include error bars that graphically indicate measurement uncertainty. The errorbar function can be used to display both vertical and horizontal error bars:\nplt.errorbar(x, y, xerr=x_errors, yerr=y_errors, fmt='format', label='label')\nHere’s an example of a plot with error bars:\n\n\n\n\n\n\n\n\nWe can visualize 2D arrays created with NumPy:",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html#saving-figures",
    "href": "lectures/lecture03/03-lecture03.html#saving-figures",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "10.3 Saving Figures",
    "text": "10.3 Saving Figures\nTo save a figure to a file, use the savefig method. Matplotlib supports multiple formats including PNG, JPG, EPS, SVG, PGF and PDF:\nplt.savefig('filename.extension')\nHere’s an example of creating and saving a figure:\n\n\n\n\n\n\nFor scientific papers, PDF format is recommended whenever possible. LaTeX documents compiled with pdflatex can include PDFs using the includegraphics command. PGF can also be a good alternative in some cases.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html#numpy-with-visualization",
    "href": "lectures/lecture03/03-lecture03.html#numpy-with-visualization",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "10.4 NumPy with Visualization",
    "text": "10.4 NumPy with Visualization\nThe arrays and calculations we’ve learned in NumPy form the foundation for scientific data visualization. In the next section, we’ll explore how to use Matplotlib to create visual representations of NumPy arrays, allowing us to interpret and communicate our physics results more effectively.\nFor example, we can visualize the planetary force calculations from our broadcasting example:",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "seminars/seminar02/md1.html",
    "href": "seminars/seminar02/md1.html",
    "title": "11  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "11.1 Molecular Dynamics Simulations\nReal molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\nBefore we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation. The Jupyter Notebook below will help you to copy and paste the code to test the snippets presented.",
    "crumbs": [
      "Seminar 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar02/md1.html#molecular-dynamics-simulations",
    "href": "seminars/seminar02/md1.html#molecular-dynamics-simulations",
    "title": "11  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "Open in New Window",
    "crumbs": [
      "Seminar 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar02/md1.html#basic-physical-concepts",
    "href": "seminars/seminar02/md1.html#basic-physical-concepts",
    "title": "11  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "11.2 Basic Physical Concepts",
    "text": "11.2 Basic Physical Concepts\n\n11.2.1 Newton’s Equations of Motion\nThe motion of particles in a molecular dynamics simulation is governed by Newton’s equations of motion:\n\\[m_i \\frac{d^2\\vec{r}_i}{dt^2} = \\vec{F}_i\\]\nwhere \\(m_i\\) is the mass of particle \\(i\\), \\(\\vec{r}_i\\) is the position of particle \\(i\\), and \\(\\vec{F}_i\\) is the force acting on particle \\(i\\).\nThe force acting on a particle is the sum of all forces acting on it:\n\\[\\vec{F}_i = \\sum_{j \\neq i} \\vec{F}_{ij}\\]\nwhere \\(\\vec{F}_{ij}\\) is the force acting on particle \\(i\\) due to particle \\(j\\).\n\n\n11.2.2 Potential Energy Functions and Forces\nThe force \\(\\vec{F}_{ij}\\) is usually derived from a potential energy function and may result from a variety of interactions, such as:\n\n\n\n\n\n\n\n\nInteraction Type\nSubtype\nIllustration\n\n\n\n\nBonded interactions\nBond stretching\n\n\n\n\nBond angle bending\n\n\n\n\nTorsional interactions\n\n\n\nNon-bonded interactions\nElectrostatic interactions\n\n\n\n\nVan der Waals interactions\n\n\n\nExternal forces\n\n\n\n\n\nWe will implement some of them but not all of them.\n\n11.2.2.1 Lennard-Jones Potential\nThe most common potential energy function used in MD simulations is the Lennard-Jones potential. It is belonging to the class of non-bonded interactions. The force and the potential energy of the Lennard-Jones potential are given by:\n\\[V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]\nand\n\\[F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}\\]\nwhere \\(\\frac{\\vec{r}}{r^2}\\) represents the direction of the force (the unit vector \\(\\hat{r} = \\frac{\\vec{r}}{r}\\)) multiplied by \\(\\frac{1}{r}\\), and \\(\\epsilon\\) is the depth of the potential well, \\(\\sigma\\) is the distance at which the potential is zero, and \\(r\\) is the distance between particles.\nThe Lenard Jones potential is good for describing the interaction of non-bonded atoms in a molecular system e.g. in a gas or a liquid and is therefore well suited if we first want to simulate a gas or a liquid.\n\n\n\n\n\n\n\n\n\nThe figure above shows the Lennard-Jones potential as a function of the distance between particles. The potential energy is zero at the equilibrium distance \\(r = \\sigma\\) and has a minimum at \\(r = 2^{1/6}\\sigma\\). The potential energy is positive for \\(r &lt; \\sigma\\) and negative for \\(r &gt; \\sigma\\).\n\n\n\n\n\n\nValues for atomic hydrogen\n\n\n\nFor atomic hydrogen (H), typical Lennard-Jones parameters are:\n\n\\(\\sigma \\approx 2.38\\) Å = \\(2.38 \\times 10^{-10}\\) meters\n\\(\\epsilon \\approx 0.0167\\) kcal/mol = \\(1.16 \\times 10^{-21}\\) joules\n\n\n\nLater, if we manage to advance to some more complicated systems, we may want to introduce:\n\nforce in bonds between two atoms\nforce in bond angles between three atoms\nforce in dihedral angles between four atoms\n\nBut for now, we will stick to the Lennard-Jones potential.",
    "crumbs": [
      "Seminar 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar02/md1.html#integrating-newtons-equation-of-motion",
    "href": "seminars/seminar02/md1.html#integrating-newtons-equation-of-motion",
    "title": "11  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "11.3 Integrating Newton’s Equation of Motion",
    "text": "11.3 Integrating Newton’s Equation of Motion\nWhen we have the forces on a particle we have in principle its acceleration. To get the velocity and the position of the particle we need to integrate the equations of motion. There are several methods to do this, but we will start with the simplest one, the Euler method.\n\n11.3.1 Euler Method\nTo obtain this one first needs to know about the Taylor expansion of a function in general. The Taylor expansion of a function \\(f(x)\\) around a point \\(x_0\\) is providing an approximation of the function in the vicinity of \\(x_0\\). It is given by:\n\\[f(x) = f(x_0) + f'(x_0)(x - x_0) + \\frac{1}{2}f''(x_0)(x - x_0)^2 + \\cdots\\]\nwhere \\(f'(x_0)\\) is the first derivative of \\(f(x)\\) at \\(x_0\\), \\(f''(x_0)\\) is the second derivative of \\(f(x)\\) at \\(x_0\\), and so on. We can demonstrate that by expanding a sine function around \\(x_0 = 0\\):\n\\[\\sin(x) = \\sin(0) + \\cos(0)x - \\frac{1}{2}\\sin(0)x^2 + \\cdots = x - \\frac{1}{6}x^3 + \\cdots\\]\nPlotting this yields:\n\n\n\n\n\n\n\n\n\nThe expansion is therefore a good approximation in a region close to \\(x_0\\).\n\n\n11.3.2 Velocity Verlet Algorithm\nThe velocity Verlet algorithm is a second-order algorithm that offers greater accuracy than the Euler method. It can be derived from the Taylor expansion of the position and velocity vectors:\n\\[\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2+ O(\\Delta t^3)\\]\nThe higher order terms in the Taylor expansion are neglected, which results in an error of order \\(\\Delta t^3\\). In contrast, the Euler method is obtained by neglecting the higher order terms in the Taylor expansion of the velocity vector:\n\\[\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m}\\Delta t + O(\\Delta t^2)\\]\nThis makes the Euler method only first order accurate with an error of order \\(\\Delta t^2\\).\nThe Velocity Verlet algorithm is particularly valuable for molecular dynamics simulations because it offers several advantages over the Euler method. It does a much better job preserving the total energy of the system over long simulation times. The algorithm is also time-reversible, which is a property of the exact equations of motion. Furthermore, it provides symplectic integration, preserving the phase space volume, another important property for physical simulations. These properties make the Velocity Verlet algorithm much more stable for long simulations, which is crucial when modeling molecular systems over meaningful timescales.\nThe velocity Verlet algorithm provides a stable and accurate way to integrate the equations of motion through a three-stage process. First, we update positions using current velocities and forces: \\[\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2\\]\nNext, we calculate new forces based on these updated positions: \\[\\mathbf{F}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))\\]\nFinally, we update velocities using an average of old and new forces: \\[\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\frac{\\mathbf{F}(t) + \\mathbf{F}(t + \\Delta t)}{m}\\Delta t\\]\nIn these equations, \\(\\mathbf{r}\\) represents the position vector, \\(\\mathbf{v}\\) is the velocity vector, \\(\\mathbf{F}\\) is the force vector, \\(m\\) stands for mass, and \\(\\Delta t\\) is the timestep. This approach ensures greater accuracy and stability in our molecular dynamics simulations compared to simpler methods.\n\n\n11.3.3 Simple Integration Example: Free Fall\nLet’s start by integrating the equation of motion for a particle in free fall using the Velocity Verlet algorithm. This is an ideal starting example since the physics is straightforward, with gravity being the only force acting on the particle, and we can compare our numerical solution to the well-known analytical one.\nNewton’s equation of motion: \\[\\mathbf{F} = m\\mathbf{a}\\]\nFor gravity, the only force acting on our particle is the gravitational force pointing downward: \\[\\mathbf{F} = -mg\\hat{\\mathbf{y}}\\]\nTherefore, the acceleration in the y-direction is constant: \\[\\ddot{y} = -g\\]\nThe analytical solution to this differential equation gives us the position and velocity at any time \\(t\\). The position is given by \\[y(t) = y_0 + v_0t - \\frac{1}{2}gt^2\\], and the velocity is expressed as \\[v(t) = v_0 - gt\\]. Here, \\(y_0\\) is the initial height, \\(v_0\\) is the initial velocity, and \\(g\\) is the acceleration due to gravity. We can use this exact solution to verify our numerical integration method.",
    "crumbs": [
      "Seminar 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  }
]