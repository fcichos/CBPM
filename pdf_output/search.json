[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Computer-based Physical Modeling",
    "section": "",
    "text": "1 Welcome to Computer-Based Physical Modelling!\nThe programming language Python is useful for all kinds of scientific and technical tasks. You can use it to analyze and visualize data. You can also use it to numerically solve scientific problems that are difficult or impossible to solve analytically. Python is freely available and, due to its modular structure, has been expanded with an almost infinite number of modules for various purposes.\nThis course aims to introduce you to programming with Python. It is primarily aimed at beginners, but we hope it will also be interesting for advanced users. We begin the course with an introduction to the Jupyter Notebook environment, which we will use throughout the entire course. Afterward, we will provide an introduction to Python and show you some basic functions, such as plotting and analyzing data through curve fitting, reading and writing files, which are some of the tasks you will encounter during your physics studies. We will also show you some advanced topics such as animation in Jupyter and the simulation of physical processes in\n\nMechanics\nElectrostatics\nWaves\nOptics\n\nIf there is time left at the end of the course, we will also take a look at machine learning methods, which have become an important tool in physics as well.\nWe will not present a comprehensive list of numerical simulation schemes, but rather use the examples to spark your curiosity. Since there are slight differences in the syntax of the various Python versions, we will always refer to the Python 3 standard in the following.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CBPM 2025</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/00-lecture01.html",
    "href": "lectures/lecture01/00-lecture01.html",
    "title": "2  Programming Background Questionnaire",
    "section": "",
    "text": "Please complete this short questionnaire to help tailor the course to your needs. Your responses are anonymous and will be used only to adapt the teaching to your level of experience.\n\n  Loading…",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Programming Background Questionnaire</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html",
    "href": "lectures/lecture01/01-lecture01.html",
    "title": "3  Jupyter Notebooks",
    "section": "",
    "text": "3.1 What is a Jupyter Notebook?\nThroughout this course we will have to create and edit python code. We will primarily use this webpage for convenience, but for day-to-day work in the laboratory, it’s beneficial to utilize a code editor or a notebook environment like JupyterLab. JupyterLab is a robust platform that enables you to develop and modify notebooks within a web browser, while also offering comprehensive capabilities for analyzing and visualizing data.\nA Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#what-is-a-jupyter-notebook",
    "href": "lectures/lecture01/01-lecture01.html#what-is-a-jupyter-notebook",
    "title": "3  Jupyter Notebooks",
    "section": "",
    "text": "3.1.1 Key Components of a Notebook\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\n3.1.1.1 Notebook Editor\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It enables users to write and run code, add rich text, and multimedia content. When running Jupyter on a server, users typically use either the classic Jupyter Notebook interface or JupyterLab, an advanced version with more features.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\n3.1.2 Kernels\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\n3.1.3 JupyterLab Example\nThe following is an example of a JupyterLab interface with a notebook editor, code cells, markdown cells, and a kernel selector:\nFull Screen\n\n\n\n\n\n3.1.4 Notebook Documents\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "href": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "title": "3  Jupyter Notebooks",
    "section": "3.2 Using the Notebook Editor",
    "text": "3.2 Using the Notebook Editor\n\n\n\nJupyter Notebook Editor\n\n\nThe Jupyter Notebook editor provides an interactive environment for writing code, creating visualizations, and documenting computational workflows. It consists of a web-based interface that allows users to create and edit notebook documents containing code, text, equations, images, and interactive elements. A Jupyter Notebook provides an interface with essentially two modes of operation:\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab you can also have a presentation mode where you can present your notebook as a slideshow.\n\n3.2.1 Edit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area when a cell is selected. You can enter edit mode by pressing Enter or using the mouse to click on a cell’s editor area.\n\n\n\nEdit Mode\n\n\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor\n\n\n3.2.2 Command mode\nCommand mode is indicated by a grey cell border with a blue left margin. When you are in command mode, you are able to edit the notebook as a whole, but not type into individual cells. Most importantly, in command mode, the keyboard is mapped to a set of shortcuts that let you perform notebook and cell actions efficiently.\n\n\n\nCommand Mode\n\n\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\n3.2.3 Keyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor area. Thus, in edit mode there are relatively few shortcuts available. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\n3.2.4 Running code\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\n\n23752636\n\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "href": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "title": "3  Jupyter Notebooks",
    "section": "3.3 Managing the kernel",
    "text": "3.3 Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "href": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "title": "3  Jupyter Notebooks",
    "section": "3.4 Markdown in Notebooks",
    "text": "3.4 Markdown in Notebooks\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\n3.4.1 Markdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold. You can build nested itemized or enumerated lists:\n\n\n3.4.2 Markdown lists example\n\nFirst item\n\nFirst subitem\n\nFirst sub-subitem\n\nSecond subitem\n\nFirst subitem of second subitem\nSecond subitem of second subitem\n\n\nSecond item\n\nFirst subitem\n\nThird item\n\nFirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\n\n\n3.4.3 Blockquote example\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Namespaces are one honking great idea – let’s do more of those!\n\n\n\n3.4.4 Web links example\nJupyter’s website\n\n\n3.4.5 Headings\nYou can add headings by starting a line with one (or multiple) # followed by a space and the title of your section. The number of # you use will determine the size of the heading\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\n3.4.6 Embedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\n\n\n3.4.7 LaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\n3.4.8 Images\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\n\n3.4.9 Videos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/python_lecture01.html",
    "href": "lectures/lecture01/python_lecture01.html",
    "title": "4  Python & Anatomy of a Python Program",
    "section": "",
    "text": "4.1 What is Python?\nPython is a high-level, interpreted programming language known for its readability and simplicity. Created by Guido van Rossum in 1991, it emphasizes code readability with its clear syntax and use of indentation. Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming. It comes with a comprehensive standard library and has a vast ecosystem of third-party packages, making it suitable for various applications such as web development, data analysis, artificial intelligence, scientific computing, and automation. Python’s “batteries included” philosophy and gentle learning curve have contributed to its popularity among beginners and experienced developers alike.\nFor physics students specifically, Python has become the language of choice for data analysis, simulation, and visualization in scientific research. Libraries like NumPy, SciPy, and Matplotlib provide powerful tools for solving physics problems, from basic mechanics to quantum mechanics.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python & Anatomy of a Python Program</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/python_lecture01.html#anatomy-of-a-python-program",
    "href": "lectures/lecture01/python_lecture01.html#anatomy-of-a-python-program",
    "title": "4  Python & Anatomy of a Python Program",
    "section": "4.2 Anatomy of a Python Program",
    "text": "4.2 Anatomy of a Python Program\nUnderstanding the basic structure of a Python program is essential for beginners. Let’s break down the fundamental elements that make up a typical Python program.\n\n4.2.1 Basic Elements\n\n\n\n\n\n\n\n\nElement\nDescription\nExample\n\n\n\n\nStatements\nIndividual instructions that Python executes\nx = 10\n\n\nExpressions\nCombinations of values, variables, and operators that evaluate to a value\nx + 5\n\n\nBlocks\nGroups of statements indented at the same level\nFunction bodies, loops\n\n\nFunctions\nReusable blocks of code that perform specific tasks\ndef calculate_area(radius):\n\n\nComments\nNotes in the code that are ignored by the interpreter\n# This is a comment\n\n\nImports\nStatements that give access to external modules\nimport numpy as np\n\n\n\n\n\n4.2.2 Visual Structure of a Python Program\n# 1. Import statements (external libraries)\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint  # For solving differential equations\n\n# 2. Constants and global variables\nGRAVITY = 9.81  # m/s^2\nPLANCK_CONSTANT = 6.626e-34  # J·s\nELECTRON_MASS = 9.109e-31  # kg\n\n# 3. Function definitions\ndef calculate_kinetic_energy(mass, velocity):\n    \"\"\"\n    Calculate the kinetic energy of an object.\n\n    Parameters:\n        mass (float): Mass of the object in kg\n        velocity (float): Velocity of the object in m/s\n\n    Returns:\n        float: Kinetic energy in Joules\n    \"\"\"\n    return 0.5 * mass * velocity**2\n\ndef spring_force(k, displacement):\n    \"\"\"\n    Calculate the force exerted by a spring.\n\n    Parameters:\n        k (float): Spring constant in N/m\n        displacement (float): Displacement from equilibrium in m\n\n    Returns:\n        float: Force in Newtons (negative for restoring force)\n    \"\"\"\n    return -k * displacement\n\n# 4. Class definitions (if applicable)\nclass Particle:\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = position\n        self.velocity = velocity\n\n    def update_position(self, time_step):\n        # Simple Euler integration\n        self.position += self.velocity * time_step\n\n    def potential_energy(self, height, g=GRAVITY):\n        \"\"\"Calculate gravitational potential energy\"\"\"\n        return self.mass * g * height\n\n    def momentum(self):\n        \"\"\"Calculate momentum\"\"\"\n        return self.mass * self.velocity\n\n# 5. Main execution code\nif __name__ == \"__main__\":\n    # Create objects or variables\n    particle = Particle(1.0, np.array([0.0, 0.0]), np.array([1.0, 2.0]))\n\n    # Set up simulation parameters\n    time_step = 0.01  # seconds\n    total_time = 1.0  # seconds\n    n_steps = int(total_time / time_step)\n\n    # Arrays to store results\n    positions = np.zeros((n_steps, 2))\n    times = np.zeros(n_steps)\n\n    # Process data/perform calculations - simulate motion\n    for i in range(n_steps):\n        particle.update_position(time_step)\n        positions[i] = particle.position\n        times[i] = i * time_step\n\n    # Output results\n    print(f\"Final position: {particle.position}\")\n    print(f\"Final kinetic energy: {calculate_kinetic_energy(particle.mass, np.linalg.norm(particle.velocity))} J\")\n\n    # Visualize results (if applicable)\n    plt.figure(figsize=(10, 6))\n    plt.subplot(1, 2, 1)\n    plt.plot(positions[:, 0], positions[:, 1], 'r-')\n    plt.xlabel('X position (m)')\n    plt.ylabel('Y position (m)')\n    plt.title('Particle Trajectory')\n    plt.grid(True)\n\n    plt.subplot(1, 2, 2)\n    plt.plot(times, positions[:, 0], 'b-', label='x-position')\n    plt.plot(times, positions[:, 1], 'g-', label='y-position')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    plt.title('Position vs Time')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n\n4.2.3 Key Concepts\n\nModularity: Python programs are typically organized into functions and classes that encapsulate specific functionality.\nIndentation: Python uses indentation (typically 4 spaces) to define code blocks, unlike other languages that use braces {}.\nDocumentation: Good Python code includes docstrings (triple-quoted strings) that explain what functions and classes do.\nMain Block: The if __name__ == \"__main__\": block ensures code only runs when the file is executed directly, not when imported.\nReadability: Python emphasizes code readability with clear variable names and logical organization.\nPhysics Modeling: For physics problems, we typically model physical systems as objects with properties (mass, position, etc.) and behaviors (update_position, calculate_energy, etc.).\nNumerical Integration: Many physics problems require solving differential equations numerically using methods like Euler integration or Runge-Kutta.\nUnits: Always include appropriate SI units in your comments and documentation to ensure clarity in physics calculations.\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nKeep functions short and focused on a single task\nUse meaningful variable and function names\nInclude comments to explain why rather than what (the code should be self-explanatory)\nFollow PEP 8 style guidelines for consistent formatting\nStructure larger programs into multiple modules (files)\nFor physics simulations, validate your code against known analytical solutions when possible\nRemember to handle units consistently throughout your calculations\nConsider the appropriate numerical methods for the physical system you’re modeling\n\n\n\n\n\n\n\n\n\n\nPhysics-Specific Python Libraries\n\n\n\n\n\n\nNumPy: Provides array operations and mathematical functions\nSciPy: Scientific computing tools including optimization, integration, and differential equations\nMatplotlib: Plotting and visualization\nSymPy: Symbolic mathematics for analytical solutions\nPandas: Data manipulation and analysis\nastropy: Astronomy and astrophysics\nscikit-learn: Machine learning for data analysis\nPyMC: Probabilistic programming for statistical analysis",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python & Anatomy of a Python Program</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html",
    "href": "lectures/lecture01/02-lecture01.html",
    "title": "5  Variables & Numbers",
    "section": "",
    "text": "5.1 Variables in Python",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "href": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "title": "5  Variables & Numbers",
    "section": "",
    "text": "5.1.1 Symbol Names\nVariable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nPython has keywords that cannot be used as variable names. The most common ones you’ll encounter in physics programming are:\nif, else, for, while, return, and, or, lambda\nNote that lambda is particularly relevant as it could naturally appear in physics code, but since it’s reserved for anonymous functions in Python, it cannot be used as a variable name.\n\n\n\n\n5.1.2 Variable Assignment\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#number-types",
    "href": "lectures/lecture01/02-lecture01.html#number-types",
    "title": "5  Variables & Numbers",
    "section": "5.2 Number Types",
    "text": "5.2 Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers. These are some of the basic building blocks of doing arithmetic in any programming language. We will discuss each of these types in more detail.\n\n5.2.1 Comparison of Number Types\n\n\n\n\n\n\n\n\n\n\n\nType\nExample\nDescription\nLimits\nUse Cases\n\n\n\n\nint\n42\nWhole numbers\nUnlimited precision (bounded by available memory)\nCounting, indexing\n\n\nfloat\n3.14159\nDecimal numbers\nTypically ±1.8e308 with 15-17 digits of precision (64-bit)\nScientific calculations, prices\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts\nSame as float for both real and imaginary parts\nSignal processing, electrical engineering\n\n\nbool\nTrue / False\nLogical values\nOnly two values: True (1) and False (0)\nConditional operations, flags\n\n\n\n\n\n\n5.2.2 Examples\n\nIntegersFloating Point NumbersComplex Numbers\n\n\nInteger Representation: Integers are whole numbers without a decimal point.\n\n\n\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n\n\n\n\n\n\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\n\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n\n\n\n\n\n\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\n\n\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\n\n\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#operators",
    "href": "lectures/lecture01/02-lecture01.html#operators",
    "title": "5  Variables & Numbers",
    "section": "5.3 Operators",
    "text": "5.3 Operators\nPython provides a variety of operators for performing operations on variables and values. Here we’ll cover the most common operators used in scientific programming.\n\nArithmetic OperatorsComparison OperatorsLogical OperatorsAssignment Operators\n\n\nThese operators perform basic mathematical operations:\n\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n+\nAddition\n5 + 3\n8\n\n\n-\nSubtraction\n5 - 3\n2\n\n\n*\nMultiplication\n5 * 3\n15\n\n\n/\nDivision\n5 / 3\n1.6666…\n\n\n//\nFloor Division\n5 // 3\n1\n\n\n%\nModulus (remainder)\n5 % 3\n2\n\n\n**\nExponentiation\n5 ** 3\n125\n\n\n\n\n\n\n\n\n\n\n\nThese operators are used to compare values:\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n==\nEqual to\nx == y\n\n\n!=\nNot equal to\nx != y\n\n\n&gt;\nGreater than\nx &gt; y\n\n\n&lt;\nLess than\nx &lt; y\n\n\n&gt;=\nGreater than or equal to\nx &gt;= y\n\n\n&lt;=\nLess than or equal to\nx &lt;= y\n\n\n\n\n\n\n\n\n\n\n\nUsed to combine conditional statements:\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\n\n\n\n\nand\nReturns True if both statements are true\nx &gt; 0 and x &lt; 10\n\n\nor\nReturns True if one of the statements is true\nx &lt; 0 or x &gt; 10\n\n\nnot\nReverses the result, returns False if the result is true\nnot(x &gt; 0 and x &lt; 10)\n\n\n\n\n\n\n\n\n\n\n\nPython provides shorthand operators for updating variables:\n\n\n\nOperator\nExample\nEquivalent to\n\n\n\n\n=\nx = 5\nx = 5\n\n\n+=\nx += 3\nx = x + 3\n\n\n-=\nx -= 3\nx = x - 3\n\n\n*=\nx *= 3\nx = x * 3\n\n\n/=\nx /= 3\nx = x / 3\n\n\n//=\nx //= 3\nx = x // 3\n\n\n%=\nx %= 3\nx = x % 3\n\n\n**=\nx **= 3\nx = x ** 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperator Precedence\n\n\n\n\n\nPython follows the standard mathematical order of operations (PEMDAS):\n\nParentheses\nExponentiation (**)\nMultiplication and Division (*, /, //, %)\nAddition and Subtraction (+, -)\n\nWhen operators have the same precedence, they are evaluated from left to right.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html",
    "href": "lectures/lecture02/01-lecture02.html",
    "title": "6  Data Types",
    "section": "",
    "text": "6.1 Data Types\nIt’s time to look at different data types we may find useful in our course. Besides the number types mentioned previously, there are also other types like strings, lists, tuples, dictionaries and sets.\nEach of these data types has a number of connected methods (functions) which allow you to manipulate the data contained in a variable. If you want to know which methods are available for a certain object use the command dir, e.g.\nThe output would be:\nThe following few cells will give you a short introduction into each type.",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Types</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#data-types",
    "href": "lectures/lecture02/01-lecture02.html#data-types",
    "title": "6  Data Types",
    "section": "",
    "text": "Numeric TypesStringsListsTuplesDictionariesBooleanSets\n\n\nPython supports several numeric data types including integers, floats, and complex numbers.\n\n\n\n\n\n\nYou can perform various arithmetic operations with numeric types:\n\n\n\n\n\n\nType conversion works between numeric types:\n\n\n\n\n\n\n\n\nStrings are lists of keyboard characters as well as other characters not on your keyboard. They are useful for printing results on the screen, during reading and writing of data.\n\n\n\n\n\n\n\n\n\n\n\n\nString can be concatenated using the + operator.\n\n\n\n\n\n\n\n\n\n\n\n\nAs strings are lists, each character in a string can be accessed by addressing the position in the string (see Lists section)\n\n\n\n\n\n\nStrings can also be made out of numbers.\n\n\n\n\n\n\nIf you want to obtain a number of a string, you can use what is known as type casting. Using type casting you may convert the string or any other data type into a different type if this is possible. To find out if a string is a pure number you may use the str.isnumeric method. For the above string, we may want to do a conversion to the type int by typing:\n\n\n\n\n\n\n\n\n\n\n\n\nThere are a number of methods connected to the string data type. Usually the relate to formatting or finding sub-strings. Formatting will be a topic in our next lecture. Here we just refer to one simple find example.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLists are ordered, mutable collections that can store items of different data types.\n\n\n\n\n\n\nYou can access and modify list elements:\n\n\n\n\n\n\nCommon list methods:\n\n\n\n\n\n\n\n\nTuples are ordered, immutable sequences.\n\n\n\n\n\n\nTuples are immutable, meaning you cannot change their elements after creation:\n\n\n\n\n\n\n\n\nDictionaries store data as key-value pairs. They are mutable and unordered.\n\n\n\n\n\n\nAccessing and modifying dictionary elements:\n\n\n\n\n\n\nCommon dictionary methods:\n\n\n\n\n\n\n\n\nThe Boolean type has only two possible values: True and False.\n\n\n\n\n\n\nBoolean values are commonly used in conditional statements:\n\n\n\n\n\n\nBoolean operations:\n\n\n\n\n\n\n\n\nSets are unordered collections of unique elements.\n\n\n\n\n\n\nCommon set operations:\n\n\n\n\n\n\nAdding and removing elements:",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Types</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#type-casting",
    "href": "lectures/lecture02/01-lecture02.html#type-casting",
    "title": "6  Data Types",
    "section": "6.2 Type Casting",
    "text": "6.2 Type Casting\nType casting is the process of converting a value from one data type to another. Python provides built-in functions for type conversion.\nPython offers several built-in functions for type conversion: - int(): Converts to integer - float(): Converts to float - str(): Converts to string - bool(): Converts to boolean - list(): Converts to list - tuple(): Converts to tuple - set(): Converts to set - dict(): Converts from mappings or iterables of key-value pairs\nLet’s explore various type conversion examples with practical code demonstrations. These examples show how Python handles conversions between different data types.\nNumeric Conversions\nWhen converting between numeric types, it’s important to understand how precision and data may change. For example, converting floats to integers removes the decimal portion without rounding.\n\n\n\n\n\n\nString Conversions\nString conversions are commonly used when processing user input or preparing data for output. Python provides straightforward functions for converting between strings and numeric types.\n\n\n\n\n\n\nCollection Type Conversions\nPython allows for easy conversion between different collection types, which is useful for changing the properties of your data structure (like making elements unique with sets).\n\n\n\n\n\n\nBoolean Conversion\nBoolean conversion is essential for conditional logic. Python follows specific rules to determine truthiness of values, with certain “empty” or “zero” values converting to False.\nWhen converting to boolean with bool(), the following values are considered False: - 0 (integer) - 0.0 (float) - \"\" (empty string) - [] (empty list) - () (empty tuple) - {} (empty dictionary) - set() (empty set) - None\nEverything else converts to True.\n\n\n\n\n\n\nSpecial Cases and Errors\nType conversion can sometimes fail, especially when the source value cannot be logically converted to the target type. Understanding these limitations helps prevent runtime errors in your code.\nNot all type conversions are possible. Python will raise an error when the conversion is not possible.\n\n\n\n\n\n\nTo handle potential errors in type conversion, you can use exception handling with try/except blocks:",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Types</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html",
    "href": "lectures/lecture02/02-lecture02.html",
    "title": "7  Python Overview",
    "section": "",
    "text": "7.1 Control Structures and Functions\nBuilding on our understanding of Python’s basic data types and operations, we’ll now explore how to control program flow and create reusable code blocks. These structures allow us to write more sophisticated programs that can make decisions, repeat operations, and organize code efficiently.",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#control-structures-and-functions",
    "href": "lectures/lecture02/02-lecture02.html#control-structures-and-functions",
    "title": "7  Python Overview",
    "section": "",
    "text": "7.1.1 Functions\nFunctions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n7.1.2 Loops\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n\nFor LoopWhile Loop\n\n\nA for loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here’s an example:\n\n\n\n\n\n\n\n\nA while loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n7.1.3 Conditional Statements\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are if, else, and elif.\n\nIf StatementElse StatementElif Statement\n\n\nAn if statement in Python is used to execute a block of code if a certain condition is met. Here’s an example:\n\n\n\n\n\n\n\n\nAn else statement in Python is used to execute a block of code if the condition in an if statement is not met. Here’s an example:\n\n\n\n\n\n\n\n\nAn elif statement in Python is used to execute a block of code if the condition in an if statement is not met but under an extra condition. Here’s an example:",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#exercises",
    "href": "lectures/lecture02/02-lecture02.html#exercises",
    "title": "7  Python Overview",
    "section": "7.2 Exercises",
    "text": "7.2 Exercises\nThe following exercises will help you practice using functions with conditional logic.\n\n\n\n\n\n\nExercise 1: Temperature Conversion Function\n\n\n\nCreate a function that converts temperatures between Fahrenheit and Celsius scales. This exercise demonstrates how to define and use functions with conditional logic to perform different types of conversions based on user input.\nThe conversion formulas are: - Celsius to Fahrenheit: \\(F = (C \\times 9/5) + 32\\) - Fahrenheit to Celsius: \\(C = (F - 32) \\times 5/9\\)\nTime estimate: 15-20 minutes\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nUse an if-else statement to check the scale parameter. Depending on whether it’s ‘C’ or ‘F’, apply the appropriate conversion formula. Remember to return both the converted temperature value and the new scale designation (either ‘F’ or ‘C’).\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2: Prime Number Checker\n\n\n\nCreate a function that checks whether a given number is prime. This exercise demonstrates the use of loops, conditional statements, and early return to solve a common mathematical problem.\nA prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers.\nTime estimate: 15-20 minutes\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nFirst, check if the number is less than 2 (not prime). Then, use a loop to check if the number is divisible by any integer from 2 to the square root of the number. If you find a divisor, the number is not prime. If no divisors are found, the number is prime.\n\n\n\n\n\n\n\n\n\n\n\nNote",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/01-lecture03.html",
    "href": "lectures/lecture03/01-lecture03.html",
    "title": "8  Modules",
    "section": "",
    "text": "Most of the functionality in Python is provided by modules. The Python Standard Library is a large collection of modules that provides cross-platform implementations of common facilities such as access to the operating system, file I/O, string management, network communication, math, web-scraping, text manipulation, machine learning and much more.\nTo use a module in a Python program it first has to be imported. A module can be imported using the import statement. For example, to import the module math, which contains many standard mathematical functions, we can do:\n\n\n\n\n\n\nThis includes the whole module and makes it available for use later in the program. Note that the functions of the module are accessed using the prefix math., which is the namespace for the module.\nAlternatively, we can chose to import all symbols (functions and variables) in a module so that we don’t need to use the prefix “math.” every time we use something from the math module:\n\n\n\n\n\n\nThis pattern can be very convenient, but in large programs that include many modules it is often a good idea to keep the symbols from each module in their own namespaces, by using the import math pattern. This would eliminate potentially confusing problems.\n\n8.0.1 Namespaces\n\n\n\n\n\n\nNamespaces\n\n\n\nA namespace is an identifier used to organize objects, e.g. the methods and variables of a module. The prefix math. we have used in the previous section is such a namespace. You may also create your own namespace for a module. This is done by using the import math as mymath pattern.\n\n\n\n\n\n\n\n\nYou may also only import specific functions of a module.\n\n\n\n\n\n\n\n\n8.0.2 Directory of a module\nOnce a module is imported, we can list the symbols it provides using the dir function:\n\n\n\n\n\n\nAnd using the function help we can get a description of each function (almost .. not all functions have docstrings, as they are technically called, but the vast majority of functions are documented this way).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also use the help function directly on modules: Try\nhelp(math)\nSome very useful modules from the Python standard library are os, sys, math, shutil, re, subprocess, multiprocessing, threading.\nA complete lists of standard modules for Python 3 is available at the python website .\n\n\n8.0.3 Advanced topics\n\n\n\n\n\n\nCreate Your Own Modules\n\n\n\n\n\nCreating your own modules in Python is a great way to organize your code and make it reusable. A module is simply a file containing Python definitions and statements. Here’s how you can create and use your own module:\n\n8.0.3.1 Creating a Module\nTo create a module, you just need to save your Python code in a file with a .py extension. For example, let’s create a module named mymodule.py with the following content:\n# mymodule.py\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n\n8.0.3.2 Using Your Module\nOnce you have created your module, you can import it into other Python scripts using the import statement. Here’s an example of how to use the mymodule we just created:\n# main.py\n\nimport mymodule\n\n# Use the functions from mymodule\nprint(mymodule.greet(\"Alice\"))\nprint(mymodule.add(5, 3))\n\n\n8.0.3.3 Importing Specific Functions\nYou can also import specific functions from a module using the from ... import ... syntax:\n# main.py\n\nfrom mymodule import greet, add\n\n# Use the imported functions directly\nprint(greet(\"Bob\"))\nprint(add(10, 7))\n\n\n8.0.3.4 Module Search Path\nWhen you import a module, Python searches for the module in the following locations: 1. The directory containing the input script (or the current directory if no script is specified). 2. The directories listed in the PYTHONPATH environment variable. 3. The default directory where Python is installed.\nYou can view the module search path by printing the sys.path variable:\nimport sys\nprint(sys.path)\n\n\n8.0.3.5 Creating Packages\nA package is a way of organizing related modules into a directory hierarchy. A package is simply a directory that contains a special file named __init__.py, which can be empty. Here’s an example of how to create a package:\nmypackage/\n    __init__.py\n    module1.py\n    module2.py\nYou can then import modules from the package using the dot notation:\n# main.py\n\nfrom mypackage import module1, module2\n\n# Use the functions from the modules\nprint(module1.some_function())\nprint(module2.another_function())\nCreating and using modules and packages in Python helps you organize your code better and makes it easier to maintain and reuse.\n\n\n8.0.3.6 Namespaces in Packages\nYou can also create sub-packages by adding more directories with __init__.py files. This allows you to create a hierarchical structure for your modules:\nmypackage/\n    __init__.py\n    subpackage/\n        __init__.py\n        submodule.py\nYou can then import submodules using the full package name:\n# main.py\n\nfrom mypackage.subpackage import submodule\n\n# Use the functions from the submodule\nprint(submodule.some_sub_function())",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html",
    "href": "lectures/lecture03/02-lecture03.html",
    "title": "9  NumPy Module",
    "section": "",
    "text": "9.1 Creating Numpy Arrays\nNumpy is, besides SciPy, the core library for scientific computing in Python. It provides a high-performance multidimensional array object and tools for working with these arrays. The NumPy array, formally called ndarray in NumPy documentation, is the real workhorse of data structures for scientific and engineering applications. The NumPy array is similar to a list but where all the elements of the list are of the same type. The elements of a NumPy array are usually numbers, but can also be booleans, strings, or other objects. When the elements are numbers, they must all be of the same type.\nFor physics applications, NumPy is essential because it enables efficient numerical calculations on large datasets, handling of vectors and matrices, and implementation of mathematical models that describe physical phenomena. Whether simulating particle motion, analyzing experimental data, or solving equations of motion, NumPy provides the computational foundation needed for modern physics.\nThere are a number of ways to initialize new numpy arrays, for example from",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#creating-numpy-arrays",
    "href": "lectures/lecture03/02-lecture03.html#creating-numpy-arrays",
    "title": "9  NumPy Module",
    "section": "",
    "text": "a Python list or tuples\nusing functions that are dedicated to generating numpy arrays, such as arange, linspace, etc.\nreading data from files which will be covered in the files section\n\n\nFrom listsUsing array-generating functions\n\n\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor larger arrays it is impractical to initialize the data manually, using explicit python lists. Instead we can use one of the many functions in numpy that generate arrays of different forms. Some of the more common are:\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.1.0.1 linspace and logspace\nThe linspace function creates an array of N evenly spaced points between a starting point and an ending point. The form of the function is linspace(start, stop, N).If the third argument N is omitted,then N=50.\n\n\n\n\n\n\nlogspace is doing equivalent things with logarithmic spacing. Other types of array creation techniques are listed below. Try around with these commands to get a feeling what they do.\n\n\n\n\n\n\n\n\n9.1.0.2 mgrid\nmgrid generates a multi-dimensional matrix with increasing value entries, for example in columns and rows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.1.0.3 diag\ndiag generates a diagonal matrix with the list supplied to it. The values can be also offset from the main diagonal.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.1.0.4 zeros and ones\nzeros and ones creates a matrix with the dimensions given in the argument and filled with 0 or 1.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#array-attributes",
    "href": "lectures/lecture03/02-lecture03.html#array-attributes",
    "title": "9  NumPy Module",
    "section": "9.2 Array Attributes",
    "text": "9.2 Array Attributes\nNumPy arrays have several attributes that provide information about their size, shape, and data type. These attributes are essential for understanding and debugging your code.\n\nshapesizedtype\n\n\nThe shape attribute returns a tuple that gives the size of the array along each dimension.\n\n\n\n\n\n\n\n\nThe size attribute returns the total number of elements in the array.\n\n\n\n\n\n\n\n\nThe dtype attribute returns the data type of the array’s elements.\n\n\n\n\n\n\n\n\n\n\n\n\nThese attributes are particularly useful when debugging operations between arrays, as many NumPy functions require arrays of specific shapes or compatible data types.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#manipulating-numpy-arrays",
    "href": "lectures/lecture03/02-lecture03.html#manipulating-numpy-arrays",
    "title": "9  NumPy Module",
    "section": "9.3 Manipulating NumPy arrays",
    "text": "9.3 Manipulating NumPy arrays\n\nSlicingReshapingAdding a new dimension: newaxisStacking and repeating arrays\n\n\nSlicing is the name for extracting part of an array by the syntax M[lower:upper:step]\n\n\n\n\n\n\n\n\n\n\n\n\nAny of the three parameters in M[lower:upper:step] can be ommited.\n\n\n\n\n\n\n\n\n\n\n\n\nNegative indices counts from the end of the array (positive index from the begining):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex slicing works exactly the same way for multidimensional arrays:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDifferences\n\n\n\nSlicing can be effectively used to calculate differences for example for the calculation of derivatives. Here the position \\(y_i\\) of an object has been measured at times \\(t_i\\) and stored in an array each. We wish to calculate the average velocity at the times \\(t_{i}\\) from the arrays by\n\\[\\begin{equation}\nv_{i}=\\frac{y_i-y_{i-1}}{t_{i}-t_{i-1}}\n\\end{equation}\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArrays can be reshaped into any form, which contains the same number of elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith newaxis, we can insert new dimensions in an array, for example converting a vector to a column or row matrix.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing function repeat, tile, vstack, hstack, and concatenate we can create larger vectors and matrices from smaller ones. Please try the individual functions yourself in your notebook. We wont discuss them in detail.\n\n9.3.0.1 Tile and repeat\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3.0.2 Concatenate\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3.0.3 Hstack and vstack",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#applying-mathematical-functions",
    "href": "lectures/lecture03/02-lecture03.html#applying-mathematical-functions",
    "title": "9  NumPy Module",
    "section": "9.4 Applying mathematical functions",
    "text": "9.4 Applying mathematical functions\nAll kinds of mathematical operations can be carried out on arrays. Typically these operation act element wise as seen from the examples below.\n\nOperation involving one arrayOperations involving multiple arraysRandom Numbers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVector operations enable efficient element-wise calculations where corresponding elements at matching positions are processed simultaneously. Instead of handling elements one by one, these operations work on entire arrays at once, making them particularly fast. When multiplying two vectors using these operations, the result is not a single number (as in a dot product) but rather a new array where each element is the product of the corresponding elements from the input vectors. This element-wise multiplication is just one example of vector operations, which can include addition, subtraction, and other mathematical functions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumPy provides powerful tools for generating random numbers, which are essential for simulations in statistical physics, quantum mechanics, and other fields:\n\n\n\n\n\n\nThese random number generators are particularly useful for Monte Carlo simulations, modeling thermal noise, or simulating quantum mechanical systems.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#broadcasting",
    "href": "lectures/lecture03/02-lecture03.html#broadcasting",
    "title": "9  NumPy Module",
    "section": "9.5 Broadcasting",
    "text": "9.5 Broadcasting\nBroadcasting is a powerful mechanism that allows NumPy to work with arrays of different shapes when performing arithmetic operations. The smaller array is “broadcast” across the larger array so that they have compatible shapes.\nThe rules for broadcasting are:\n\nIf the arrays don’t have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length.\nThe size in each dimension of the output shape is the maximum of the sizes of the input arrays along that dimension.\nAn input can be used in the calculation if its size in a particular dimension matches the output size or if its value is exactly 1.\nIf an input has a dimension size of 1, the first element is used for all calculations along that dimension.\n\nLet’s see some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBroadcasting enables efficient computation without the need to create copies of arrays, saving memory and computation time.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/02-lecture03.html#physics-example-force-calculations",
    "href": "lectures/lecture03/02-lecture03.html#physics-example-force-calculations",
    "title": "9  NumPy Module",
    "section": "9.6 Physics Example: Force Calculations",
    "text": "9.6 Physics Example: Force Calculations\nBroadcasting is particularly useful in physics when applying the same operation to multiple objects. For example, when calculating the gravitational force between one massive object and multiple other objects using Newton’s law of universal gravitation:\n\\[\\begin{equation}\nF = \\frac{G M m}{r^2}\n\\end{equation}\\]\nwhere \\(F\\) is the gravitational force, \\(G\\) is the gravitational constant, \\(M\\) and \\(m\\) are the masses of the two objects, and \\(r\\) is the distance between them.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>NumPy Module</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html",
    "href": "lectures/lecture03/03-lecture03.html",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "",
    "text": "10.1 Basic Plotting\nData visualization is an essential skill for analyzing and presenting scientific data effectively. Python itself doesn’t include plotting capabilities in its core language, but Matplotlib provides powerful and flexible tools for creating visualizations. Matplotlib is the most widely used plotting library in Python and serves as an excellent starting point for creating basic plots.\nMatplotlib works well with NumPy, Python’s numerical computing library, to create a variety of plot types including line plots, scatter plots, bar charts, and more. For this document, we’ve already imported both libraries as you can see in the code below:\nWe’ve also set up some default styling parameters to make our plots more readable and professional-looking:\nThese settings configure the appearance of our plots with appropriate font sizes, line widths, and tick marks. The get_size() function helps us convert dimensions from centimeters to inches, which is useful when specifying figure sizes. With these preparations complete, we’re ready to create various types of visualizations to effectively display our data.\nMatplotlib offers multiple levels of functionality for creating plots. Throughout this section, we’ll primarily focus on using commands that leverage default settings. This approach simplifies the process, as Matplotlib automatically handles much of the graph layout. These high-level commands are ideal for quickly creating effective visualizations without delving into intricate details. Later in this course, we’ll briefly touch upon more advanced techniques that provide greater control over plot elements and layout.\nTo create a basic line plot, use the following command:\nBy default, this generates a line plot. However, you can customize the appearance by adjusting various parameters within the plot() function. For instance, you can modify it to resemble a scatter plot by changing certain arguments. The versatility of this command allows for a range of visual representations beyond simple line plots.\nLet’s create a simple line plot of the sine function over the interval \\([0, 4\\pi]\\). We’ll use NumPy to generate the x-values and calculate the corresponding y-values. The following code snippet demonstrates this process:\nHere is the code in a Python cell:\nTry to change the values of the x and y arrays and see how the plot changes.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html#basic-plotting",
    "href": "lectures/lecture03/03-lecture03.html#basic-plotting",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "",
    "text": "plt.plot(x, y)\n\n\n1x = np.linspace(0, 4.*np.pi, 100)\n2y = np.sin(x)\n\n3plt.figure(figsize=get_size(8,6))\n4plt.plot(x, y)\n5plt.tight_layout()\n6plt.show()\n\n1\n\nCreate an array of 100 values between 0 and 4\\(\\pi\\).\n\n2\n\nCalculate the sine of each value in the array.\n\n3\n\ncreate a new figure with a size of (8,6) cm\n\n4\n\nplot the data\n\n5\n\nautomatically adjust the layout\n\n6\n\nshow the figure\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy use plt.tight_layout()\n\n\n\n\n\nplt.tight_layout() is a very useful function in Matplotlib that automatically adjusts the spacing between plot elements to prevent overlapping and ensure that all elements fit within the figure area. Here’s what it does:\n\nPadding Adjustment: It adjusts the padding between and around subplots to prevent overlapping of axis labels, titles, and other elements.\nSubplot Spacing: It optimizes the space between multiple subplots in a figure.\nText Accommodation: It ensures that all text elements (like titles, labels, and legends) fit within the figure without being cut off.\nMargin Adjustment: It adjusts the margins around the entire figure to make sure everything fits neatly.\nAutomatic Resizing: If necessary, it can slightly resize subplot areas to accommodate all elements.\nLegend Positioning: It takes into account the presence and position of legends when adjusting layouts.\n\nKey benefits of using plt.tight_layout():\n\nIt saves time in manual adjustment of plot elements.\nIt helps create more professional-looking and readable plots.\nIt’s particularly useful when creating figures with multiple subplots or when saving figures to files.\n\nYou typically call plt.tight_layout() just before plt.show() or plt.savefig(). For example:\nplt.figure()\n# ... (your plotting code here)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html#customizing-plots",
    "href": "lectures/lecture03/03-lecture03.html#customizing-plots",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "10.2 Customizing Plots",
    "text": "10.2 Customizing Plots\n\nAxis LabelsLegendsPlotting Multiple LinesCustomizing Line AppearancePlots with Error BarsVisualizing NumPy Arrays\n\n\nTo enhance the clarity and interpretability of our plots, it’s crucial to provide context through proper labeling. The following commands add descriptive axis labels to our diagram:\nplt.xlabel('x-label')\nplt.ylabel('y-label')\nHere’s an example of adding labels to our sine plot:\n\n\n\n\n\n\n\n\nWhen plotting multiple datasets, it’s important to include a legend to identify each line. Use these commands:\nplt.plot(..., label='Label name')\nplt.legend(loc='lower left')\nHere’s an example with a legend:\n\n\n\n\n\n\n\n\nYou can add multiple lines to the same plot:\n\n\n\n\n\n\n\n\nYou can customize the appearance of lines with additional parameters:\n\n\n\n\n\n\n\n\nWhen plotting experimental data, it’s customary to include error bars that graphically indicate measurement uncertainty. The errorbar function can be used to display both vertical and horizontal error bars:\nplt.errorbar(x, y, xerr=x_errors, yerr=y_errors, fmt='format', label='label')\nHere’s an example of a plot with error bars:\n\n\n\n\n\n\n\n\nWe can visualize 2D arrays created with NumPy:",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html#saving-figures",
    "href": "lectures/lecture03/03-lecture03.html#saving-figures",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "10.3 Saving Figures",
    "text": "10.3 Saving Figures\nTo save a figure to a file, use the savefig method. Matplotlib supports multiple formats including PNG, JPG, EPS, SVG, PGF and PDF:\nplt.savefig('filename.extension')\nHere’s an example of creating and saving a figure:\n\n\n\n\n\n\nFor scientific papers, PDF format is recommended whenever possible. LaTeX documents compiled with pdflatex can include PDFs using the includegraphics command. PGF can also be a good alternative in some cases.",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture03/03-lecture03.html#numpy-with-visualization",
    "href": "lectures/lecture03/03-lecture03.html#numpy-with-visualization",
    "title": "10  Basic Plotting with Matplotlib",
    "section": "10.4 NumPy with Visualization",
    "text": "10.4 NumPy with Visualization\nThe arrays and calculations we’ve learned in NumPy form the foundation for scientific data visualization. In the next section, we’ll explore how to use Matplotlib to create visual representations of NumPy arrays, allowing us to interpret and communicate our physics results more effectively.\nFor example, we can visualize the planetary force calculations from our broadcasting example:",
    "crumbs": [
      "Lecture 3",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html",
    "href": "lectures/lecture04/01-lecture04.html",
    "title": "11  Classes and Objects",
    "section": "",
    "text": "11.1 Introduction to Object Oriented Programming\nImagine you’re simulating a complex physical system—perhaps a collection of interacting particles or cells. Each entity in your simulation has both properties (position, velocity, size) and behaviors (move, interact, divide). How do you organize this complexity in your code?",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Classes and Objects</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html#introduction-to-object-oriented-programming",
    "href": "lectures/lecture04/01-lecture04.html#introduction-to-object-oriented-programming",
    "title": "11  Classes and Objects",
    "section": "",
    "text": "11.1.1 From Procedural to Object-Oriented Thinking\nIn previous lectures, we’ve designed programs using a procedural approach—organizing code around functions that operate on separate data structures. While this works for simpler problems, it can become unwieldy as systems grow more complex.\nObject-oriented programming (OOP) offers a more intuitive paradigm: it combines data and functionality together into self-contained units called objects. Instead of having separate variables and functions, each object maintains its own state and defines its own behaviors.\nFor computational modeling, this is particularly powerful because:\n\nObjects can directly represent the entities you’re modeling (particles, cells, molecules)\nCode organization mirrors the structure of the real-world system\nComplex systems become easier to build incrementally and modify later",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Classes and Objects</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html#the-building-blocks-classes-and-objects",
    "href": "lectures/lecture04/01-lecture04.html#the-building-blocks-classes-and-objects",
    "title": "11  Classes and Objects",
    "section": "11.2 The Building Blocks: Classes and Objects",
    "text": "11.2 The Building Blocks: Classes and Objects\nObject-oriented programming is built upon two fundamental concepts: classes and objects.\n\n\n\n\n\n\nFigure 11.1: Sketch of the relation of classes and objects\n\n\n\n\nClasses: Creating BlueprintsObjects: Creating InstancesProperties: Storing Data\n\n\nA class serves as a blueprint or template that defines a new type of object. Think of it as a mold that creates objects with specific characteristics and behaviors. It specifies:\n\nWhat data the object will store (properties)\nWhat operations the object can perform (methods)\n\n\n\nAn object is a specific instance of a class—a concrete realization of that blueprint. When you create an object, you’re essentially saying “make me a new thing based on this class design.”\nObjects have two main components:\n\nProperties (also called attributes or fields): Variables that store data within the object\nMethods: Functions that define what the object can do and how it manipulates its data\n\n\n\nProperties come in two varieties:\n\nInstance variables: Unique to each object instance (each object has its own copy)\nClass variables: Shared among all instances of the class (one copy for the entire class)\n\nFor example, if you had a Colloid class for a particle simulation:\n\nInstance variables might include radius and position (unique to each particle)\nClass variables might include material_density (same for all colloids of that type)\nMethods might include move() or calculate_volume()",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Classes and Objects</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html#working-with-classes-in-python",
    "href": "lectures/lecture04/01-lecture04.html#working-with-classes-in-python",
    "title": "11  Classes and Objects",
    "section": "11.3 Working with Classes in Python",
    "text": "11.3 Working with Classes in Python\n\n11.3.1 Creating a Class\nTo define a class in Python, we use this basic syntax:\nclass ClassName:\n    # Class content goes here\nThe definition starts with the class keyword, followed by the class name, and a colon. The class content is indented and contains all properties and methods of the class.\nLet’s start with a minimal example that represents a colloidal particle:\n\n\n\n\n\n\nEven this empty class is a valid class definition, though it doesn’t do anything useful yet. Let’s start adding functionality to make it more practical.\n\n\n11.3.2 Creating Methods\nMethods are functions that belong to a class. They define the behaviors and capabilities of your objects.\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding self in Python Classes\n\n\n\nEvery method in a Python class automatically receives a special first parameter, conventionally named self. This parameter represents the specific instance of the class that calls the method.\nKey points about self: - It’s automatically passed by Python when you call a method - It gives the method access to the instance’s properties and other methods - By convention, we name it self (though technically you could use any valid name) - You don’t include it when calling the method\nExample:\nclass Colloid:\n    def type(self):  # self is automatically provided\n        print('I am a plastic colloid')\n\n# Usage:\nparticle = Colloid()\nparticle.type()  # Notice: no argument needed for self\nIn this example, even though type() appears to take no arguments when called, Python automatically passes particle as the self parameter.\n\n\n\n\n11.3.3 The Constructor Method: __init__\nThe __init__ method is a special method called when a new object is created. It lets you initialize the object’s properties with specific values.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nPython also provides a __del__ method (destructor) that’s called when an object is deleted. This can be useful for cleanup operations or tracking object lifecycles.\n\n\n\n\n11.3.4 String Representation: The __str__ Method\nThe __str__ method defines how an object should be represented as a string. It’s automatically called when: - You use print(object) - You convert the object to a string using str(object)\nThis method helps make your objects more readable and informative:\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe .1f format specification means the radius will be displayed with one decimal place. This helps make your output more readable. You can customize this string representation to show whatever information about your object is most relevant.",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Classes and Objects</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/01-lecture04.html#managing-data-in-classes",
    "href": "lectures/lecture04/01-lecture04.html#managing-data-in-classes",
    "title": "11  Classes and Objects",
    "section": "11.4 Managing Data in Classes",
    "text": "11.4 Managing Data in Classes\n\n11.4.1 Class Variables vs. Instance Variables\nOne of the core features of OOP is how it manages data. Python classes offer two distinct types of variables:\n\n11.4.1.1 Class Variables: Shared Among All Objects\n\nDefinition: Variables defined directly inside the class but outside any method\nBehavior: All instances of the class share the same copy of these variables\nUsage: For properties that should be the same across all instances\nAccess pattern: Typically accessed as ClassName.variable_name\n\n\n\n11.4.1.2 Instance Variables: Unique to Each Object\n\nDefinition: Variables defined within methods, typically in __init__\nBehavior: Each object has its own separate copy of these variables\nUsage: For properties that can vary between different instances\nAccess pattern: Typically accessed as self.variable_name within methods\n\nHere’s a practical example showing both types of variables in action:\n\n\n\n\n\n\n\n\n\n11.4.2 When to Use Each Type of Variable\n\n11.4.2.1 Use Class Variables When:\n\nA property should be the same for all instances (like physical constants)\nYou need to track information about the class as a whole (like counters)\nYou want to save memory by not duplicating unchanging values\n\n\n\n11.4.2.2 Use Instance Variables When:\n\nObjects need their own independent state\nProperties vary between instances (position, size, etc.)\nYou’re representing unique characteristics of individual objects\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful when modifying class variables! Since they’re shared, changes will affect all instances of the class. This can lead to unexpected behavior if not managed carefully.",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Classes and Objects</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/02-lecture04.html",
    "href": "lectures/lecture04/02-lecture04.html",
    "title": "12  Brownian Motion",
    "section": "",
    "text": "12.1 Introduction\nBrownian motion is a fundamental physical phenomenon that describes the random movement of particles suspended in a fluid. This lecture explores both the physical understanding and computational modeling of Brownian motion using object-oriented programming techniques.\nWe will apply our newly acquired knowledge about classes to simulate Brownian motion. This task aligns perfectly with the principles of object-oriented programming, as each Brownian particle (or colloid) can be represented as an object instantiated from the same class, albeit with different properties. For instance, some particles might be larger while others are smaller. We have already touched on some aspects of this in previous lectures.",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/02-lecture04.html#brownian-motion",
    "href": "lectures/lecture04/02-lecture04.html#brownian-motion",
    "title": "12  Brownian Motion",
    "section": "12.2 Brownian Motion",
    "text": "12.2 Brownian Motion\n\n12.2.1 What is Brownian Motion?\nImagine a dust particle floating in water. If you look at it under a microscope, you’ll see it moving in a random, zigzag pattern. This is Brownian motion!\n\n\n12.2.2 Why Does This Happen?\nWhen we observe Brownian motion, we’re seeing the effects of countless molecular collisions. Water isn’t just a smooth, continuous fluid - it’s made up of countless tiny molecules that are in constant motion. These water molecules are continuously colliding with our particle from all directions. Each individual collision causes the particle to move just a tiny bit, barely noticeable on its own. However, when millions of these tiny collisions happen every second from random directions, they create the distinctive zigzag motion we observe.\n\nbrownianMotion = {\n  const width = 400;\n  const height = 400;\n\n  // Create SVG container\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Add a border for clarity\n  svg.append(\"rect\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"black\");\n\n  // Parameters for our simulation - adjusted for better physical representation\n  const numSmallParticles = 400;\n  const largeParticleRadius = 10;\n  const smallParticleRadius = 5;  // Increased scale separation\n  const largeParticleColor = \"blue\";\n  const smallParticleColor = \"red\";\n  const trailLength = 300;\n\n  // Physical parameters\n  const temperature = 10.0;  // Normalized temperature\n  const gamma = 0.1;        // Drag coefficient for large particle\n\n  // Calculate masses based on radius^3 (proportional to volume)\n  const largeMass = Math.pow(largeParticleRadius, 3);\n  const smallMass = Math.pow(smallParticleRadius, 3);\n\n  // Maxwell-Boltzmann distribution helper\n  function maxwellBoltzmannVelocity() {\n    // Box-Muller transform for normal distribution\n    const u1 = Math.random();\n    const u2 = Math.random();\n    const mag = Math.sqrt(-2.0 * Math.log(u1)) * Math.sqrt(temperature / smallMass);\n    const theta = 2 * Math.PI * u2;\n    return {\n      vx: mag * Math.cos(theta),\n      vy: mag * Math.sin(theta)\n    };\n  }\n\n  // Initialize large particle in the center\n  let largeParticle = {\n    x: width / 2,\n    y: height / 2,\n    vx: 0,\n    vy: 0,\n    radius: largeParticleRadius,\n    mass: largeMass,\n    // Store previous positions for trail\n    trail: Array(trailLength).fill().map(() =&gt; ({\n      x: width / 2,\n      y: height / 2\n    }))\n  };\n\n  // Initialize small particles with random positions and thermal velocities\n  const smallParticles = Array(numSmallParticles).fill().map(() =&gt; {\n    const vel = maxwellBoltzmannVelocity();\n    return {\n      x: Math.random() * width,\n      y: Math.random() * height,\n      vx: vel.vx * 8,  // Scale for visibility\n      vy: vel.vy * 8,  // Scale for visibility\n      radius: smallParticleRadius,\n      mass: smallMass\n    };\n  });\n\n  // Create the large particle\n  const largeParticleElement = svg.append(\"circle\")\n    .attr(\"cx\", largeParticle.x)\n    .attr(\"cy\", largeParticle.y)\n    .attr(\"r\", largeParticle.radius)\n    .attr(\"fill\", largeParticleColor);\n\n  // Create the trail for the large particle\n  const trailElements = svg.append(\"g\")\n    .selectAll(\"circle\")\n    .data(largeParticle.trail)\n    .join(\"circle\")\n    .attr(\"cx\", d =&gt; d.x)\n    .attr(\"cy\", d =&gt; d.y)\n    .attr(\"r\", (_, i) =&gt; 1)\n    .attr(\"fill\", \"rgba(0, 0, 255, 0.2)\");\n\n  // Create the small particles\n  const smallParticleElements = svg.append(\"g\")\n    .selectAll(\"circle\")\n    .data(smallParticles)\n    .join(\"circle\")\n    .attr(\"cx\", d =&gt; d.x)\n    .attr(\"cy\", d =&gt; d.y)\n    .attr(\"r\", d =&gt; d.radius)\n    .attr(\"fill\", smallParticleColor);\n\n  // Function to update particle positions\n  function updateParticles() {\n    // Apply drag to large particle (Stokes' law)\n    largeParticle.vx *= (1 - gamma);\n    largeParticle.vy *= (1 - gamma);\n\n    // Update small particles\n    smallParticles.forEach((particle, i) =&gt; {\n      // Move according to velocity\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n\n      // Bounce off walls\n      if (particle.x &lt; particle.radius || particle.x &gt; width - particle.radius) {\n        particle.vx *= -1;\n        particle.x = Math.max(particle.radius, Math.min(width - particle.radius, particle.x));\n      }\n      if (particle.y &lt; particle.radius || particle.y &gt; height - particle.radius) {\n        particle.vy *= -1;\n        particle.y = Math.max(particle.radius, Math.min(height - particle.radius, particle.y));\n      }\n\n      // Check for collision with large particle\n      const dx = largeParticle.x - particle.x;\n      const dy = largeParticle.y - particle.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance &lt; largeParticle.radius + particle.radius) {\n        // Physically correct elastic collision\n\n        // Calculate unit normal vector (collision axis)\n        const nx = dx / distance;\n        const ny = dy / distance;\n\n        // Calculate unit tangent vector (perpendicular to collision)\n        const tx = -ny;\n        const ty = nx;\n\n        // Project velocities onto normal and tangential axes\n        const v1n = largeParticle.vx * nx + largeParticle.vy * ny;\n        const v1t = largeParticle.vx * tx + largeParticle.vy * ty;\n        const v2n = particle.vx * nx + particle.vy * ny;\n        const v2t = particle.vx * tx + particle.vy * ty;\n\n        // Calculate new normal velocities using conservation of momentum and energy\n        // Tangential velocities remain unchanged in elastic collision\n        const m1 = largeParticle.mass;\n        const m2 = particle.mass;\n\n        // One-dimensional elastic collision formula\n        const v1nAfter = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2);\n        const v2nAfter = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2);\n\n        // Convert back to x,y velocities\n        largeParticle.vx = v1nAfter * nx + v1t * tx;\n        largeParticle.vy = v1nAfter * ny + v1t * ty;\n        particle.vx = v2nAfter * nx + v2t * tx;\n        particle.vy = v2nAfter * ny + v2t * ty;\n\n        // Move particles apart to prevent overlap\n        const overlap = largeParticle.radius + particle.radius - distance;\n        const massRatio = m2 / (m1 + m2);\n        const largeMoveRatio = massRatio;\n        const smallMoveRatio = 1 - massRatio;\n\n        // Move particles apart proportional to their masses\n        largeParticle.x += overlap * nx * largeMoveRatio;\n        largeParticle.y += overlap * ny * largeMoveRatio;\n        particle.x -= overlap * nx * smallMoveRatio;\n        particle.y -= overlap * ny * smallMoveRatio;\n      }\n\n      // Occasionally thermostat small particles to maintain temperature\n      if (Math.random() &lt; 0.01) {\n        const vel = maxwellBoltzmannVelocity();\n        particle.vx = vel.vx * 8;  // Scale for visibility\n        particle.vy = vel.vy * 8;  // Scale for visibility\n      }\n\n      // Update small particle display\n      smallParticleElements.filter((_, j) =&gt; i === j)\n        .attr(\"cx\", particle.x)\n        .attr(\"cy\", particle.y);\n    });\n\n    // Update large particle position\n    largeParticle.x += largeParticle.vx;\n    largeParticle.y += largeParticle.vy;\n\n    // Bounce large particle off walls\n    if (largeParticle.x &lt; largeParticle.radius || largeParticle.x &gt; width - largeParticle.radius) {\n      largeParticle.vx *= -1;\n      largeParticle.x = Math.max(largeParticle.radius, Math.min(width - largeParticle.radius, largeParticle.x));\n    }\n    if (largeParticle.y &lt; largeParticle.radius || largeParticle.y &gt; height - largeParticle.radius) {\n      largeParticle.vy *= -1;\n      largeParticle.y = Math.max(largeParticle.radius, Math.min(height - largeParticle.radius, largeParticle.y));\n    }\n\n    // Update trail\n    largeParticle.trail.pop();\n    largeParticle.trail.unshift({x: largeParticle.x, y: largeParticle.y});\n\n    // Update large particle display\n    largeParticleElement\n      .attr(\"cx\", largeParticle.x)\n      .attr(\"cy\", largeParticle.y);\n\n    // Update trail display\n    trailElements.data(largeParticle.trail)\n      .attr(\"cx\", d =&gt; d.x)\n      .attr(\"cy\", d =&gt; d.y);\n  }\n\n  // Start animation\n  const interval = d3.interval(() =&gt; {\n    updateParticles();\n  }, 30);\n\n  // Clean up on invalidation\n  invalidation.then(() =&gt; interval.stop());\n\n  return svg.node();\n}\n\n\n\n\n\n\n\n\nFigure 12.1: Interactive simulation of Brownian motion. The blue circle represents a larger colloid, which moves randomly due to collisions with the smaller red particles. The fading blue trail shows the random path of the colloid.\n\n\n\n\n\n\n12.2.3 The Mathematical Model of Brownian Motion\nMathematically, Brownian motion is governed by the Langevin equation, which describes the basic equation of motion:\n\\[m\\frac{d^2\\mathbf{r}}{dt^2} = -\\gamma\\frac{d\\mathbf{r}}{dt} + \\mathbf{F}_\\text{random}(t)\\]\nwhere:\n\n\\(m\\) is the particle mass\n\\(\\mathbf{r}\\) is the position vector\n\\(\\gamma\\) is the drag coefficient\n\\(\\mathbf{F}_\\text{random}(t)\\) represents random forces from molecular collisions\n\nIn the overdamped limit (\\(m=0\\) which applies to colloidal particles), inertia becomes negligible and the equation simplifies to:\n\\[\\frac{d\\mathbf{r}}{dt} = \\sqrt{2D}\\,\\boldsymbol{\\xi}(t)\\]\nWhere \\(\\boldsymbol{\\xi}(t)\\) is Gaussian white noise and \\(D\\) is the diffusion coefficient.\nA key observable in Brownian motion is the mean squared displacement (MSD):\n\\[\\langle (\\Delta r)^2 \\rangle = 2dDt\\]\nwith:\n\n\\(\\langle (\\Delta r)^2 \\rangle\\) is the mean squared displacement\n\\(d\\) is the number of dimensions (2 in our simulation)\n\\(D\\) is the diffusion coefficient\n\\(t\\) is the time elapsed\n\nThe diffusion coefficient \\(D\\) depends on physical properties according to the Einstein-Stokes relation:\n\\[D = \\frac{k_B T}{6\\pi\\eta R}\\]\nWhere \\(k_B\\) is Boltzmann’s constant, \\(T\\) is temperature, \\(\\eta\\) is fluid viscosity, and \\(R\\) is the particle radius.\n\n\n12.2.4 Numerical Implementation\nIn our Colloid class simulation, we implement the discretized version of the overdamped Langevin equation. For each time step \\(\\Delta t\\), the position update is:\n\\[\\Delta x = \\sqrt{2D\\Delta t} \\times \\xi\\]\nWhere \\(\\Delta x\\) is the displacement in one direction, and \\(\\xi\\) is a random number drawn from a normal distribution with mean 0 and variance 1.\nThis is implemented directly in the update() method of our Colloid class:\ndef update(self, dt):\n    self.x.append(self.x[-1] + np.random.normal(0.0, np.sqrt(2*self.D*dt)))\n    self.y.append(self.y[-1] + np.random.normal(0.0, np.sqrt(2*self.D*dt)))\n    return(self.x[-1], self.y[-1])\nIn this implementation: - D is the diffusion coefficient stored as an instance variable - dt is the time step parameter - np.random.normal generates the Gaussian random numbers required for the stochastic process\n\n\n\n\n\n\nTip\n\n\n\nThe choice of time step dt is important in our simulation. If too large, it fails to capture the fine details of the motion. If too small, the simulation becomes computationally expensive. The class design allows us to adjust this parameter easily when calling sim_trajectory() or update().\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvanced Mathematical Details\n\n\n\n\n\nThe Brownian motion of a colloidal particle results from collisions with surrounding solvent molecules. These collisions lead to a probability distribution described by:\n\\[\np(x,\\Delta t)=\\frac{1}{\\sqrt{4\\pi D \\Delta t}}e^{-\\frac{x^2}{4D \\Delta t}}\n\\]\nwith:\n\n\\(D\\) is the diffusion coefficient\n\\(\\Delta t\\) is the time step\nThe variance is \\(\\sigma^2=2D \\Delta t\\)\n\nThis distribution emerges from the central limit theorem, as shown by Lindenberg and Lévy, when considering many infinitesimally small random steps.\nThe evolution of the probability density function \\(p(x,t)\\) is governed by the diffusion equation:\n\\[\n\\frac{\\partial p}{\\partial t}=D\\frac{\\partial^2 p}{\\partial x^2}\n\\]\nThis partial differential equation, also known as Fick’s second law, describes how the concentration of particles evolves over time due to diffusive processes. The Gaussian distribution above is the fundamental solution (Green’s function) of this diffusion equation, representing how an initially localized distribution spreads out over time.\nThe connection between the microscopic random motion and the macroscopic diffusion equation was first established by Einstein in his 1905 paper on Brownian motion, providing one of the earliest quantitative links between statistical mechanics and thermodynamics.",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/02-lecture04.html#object-oriented-implementation",
    "href": "lectures/lecture04/02-lecture04.html#object-oriented-implementation",
    "title": "12  Brownian Motion",
    "section": "12.3 Object-Oriented Implementation",
    "text": "12.3 Object-Oriented Implementation\n\n12.3.1 Why Use a Class?\nA class is perfect for this physics simulation because each colloidal particle:\n\nHas specific properties\n\nSize (radius)\nCurrent position\nMovement history\nDiffusion coefficient\n\nFollows certain behaviors\n\nMoves randomly (Brownian motion)\nUpdates its position over time\nKeeps track of where it’s been\n\nCan exist alongside other particles\n\nMany particles can move independently\nEach particle keeps track of its own properties\nParticles can have different sizes\n\nNeeds to track its state over time\n\nRemember previous positions\nCalculate distances moved\nMaintain its own trajectory\n\n\nThis natural mapping between real particles and code objects makes classes an ideal choice for our simulation.\n\n\n12.3.2 Class Design\nWe design a Colloid class to simulate particles undergoing Brownian motion. Using object-oriented programming makes physical sense here - in the real world, each colloidal particle is an independent object with its own properties that follows the same physical laws as other particles.\n\n12.3.2.1 Class-Level Properties (Shared by All Particles)\nOur Colloid class will store information common to all particles:\n\nnumber: A counter tracking how many particles we’ve created\nf = 2.2×10^{-19}: The physical constant \\(k_B T/(6\\pi\\eta)\\) in m³/s\n\nThis combines Boltzmann’s constant (\\(k_B\\)), temperature (\\(T\\)), and fluid viscosity (\\(\\eta\\))\nUsing this constant simplifies our diffusion calculations\n\n\n\n\n12.3.2.2 Class Methods (Functions Shared by All Particles)\nThe class provides these shared behaviors:\n\nhow_many(): Returns the total count of particles created\n\nUseful for tracking how many particles exist in our simulation\n\n__str__(): Returns a human-readable description when we print a particle\n\nShows the particle’s radius and current position\n\n\n\n\n12.3.2.3 Instance Properties (Unique to Each Particle)\nEach individual particle will have its own:\n\nR: Radius in meters\nx, y: Lists storing position history (starting with initial position)\nindex: Unique ID number for each particle\nD: Diffusion coefficient calculated as \\(D = f/R\\)\n\nFrom Einstein-Stokes relation: \\(D = \\frac{k_B T}{6\\pi\\eta R}\\)\nSmaller particles diffuse faster (larger D)\n\n\n\n\n12.3.2.4 Instance Methods (What Each Particle Can Do)\nEach particle object will have these behaviors:\n\nupdate(dt): Performs a single timestep of Brownian motion\n\nTakes a timestep dt in seconds\nAdds random displacement based on diffusion coefficient\nReturns the new position\n\nsim_trajectory(N, dt): Simulates a complete trajectory\n\nGenerates N steps with timestep dt\nCalls update() repeatedly to build the trajectory\n\nget_trajectory(): Returns the particle’s movement history as a DataFrame\n\nConvenient for analysis and plotting\n\nget_D(): Returns the particle’s diffusion coefficient\n\nUseful for calculations and verification\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that the function sim_trajectory is actually calling the function update of the same object to generate the whole trajectory at once.",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/02-lecture04.html#simulation-and-analysis",
    "href": "lectures/lecture04/02-lecture04.html#simulation-and-analysis",
    "title": "12  Brownian Motion",
    "section": "12.4 Simulation and Analysis",
    "text": "12.4 Simulation and Analysis\n\n12.4.1 Simulating\nWith the help of this Colloid class, we would like to carry out simulations of Brownian motion of multiple particles. The simulations shall\n\ntake n=200 particles\nhave N=200 trajectory points each\nstart all at 0,0\nparticle objects should be stored in a list p_list\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n12.4.2 Plotting the trajectories\nThe next step is to plot all the trajectories.\n\n\n\n\n\n\n\n\n12.4.3 Characterizing the Brownian motion\nNow that we have a number of trajectories, we can analyze the motion of our Brownian particles.\n\n12.4.3.1 Calculate the particle speed\nOne way is to calculate its speed by measuring how far it traveled within a certain time \\(n\\, dt\\), where \\(dt\\) is the timestep of out simulation. We can do that as\n\\[\\begin{equation}\nv(n dt) = \\frac{&lt;\\sqrt{(x_{i+n}-x_{i})^2+(y_{i+n}-y_{i})^2}&gt;}{n\\,dt}\n\\end{equation}\\]\nThe angular brackets on the top take care of the fact that we can measure the distance traveled within a certain time \\(n\\, dt\\) several times along a trajectory.\nThese values can be used to calculate a mean speed. Note that there is not an equal amount of data pairs for all separations available. For \\(n=1\\) there are 5 distances available. For \\(n=5\\), however, only 1. This changes the statistical accuracy of the mean.\n\n\n\n\n\n\nThe result of this analysis shows, that each particle has an apparent speed which seems to increase with decreasing time of observation or which decreases with increasing time. This would mean that there is some friction at work, which slows down the particle in time, but this is apparently not true. Also an infinite speed at zero time appears to be unphysical. The correct answer is just that the speed is no good measure to characterize the motion of a Brownian particle.\n\n\n12.4.3.2 Calculate the particle mean squared displacement\nA better way to characterize the motion of a Brownian particle is the mean squared displacement, as we have already mentioned it in previous lectures. We may compare our simulation now to the theoretical prediction, which is\n\\[\\begin{equation}\n\\langle \\Delta r^{2}(t)\\rangle=2 d D t\n\\end{equation}\\]\nwhere \\(d\\) is the dimension of the random walk, which is \\(d=2\\) in our case.\n\n\n\n\n\n\nThe results show that the mean squared displacement of the individual particles follows on average the theoretical predictions of a linear growth in time. That means, we are able to read the diffusion coefficient from the slope of the MSD of the individual particles if recorded in a simulation or an experiment.\nYet, each individual MSD is deviating strongly from the theoretical prediction especially at large times. This is due to the fact mentioned earlier that our simulation (or experimental) data only has a limited number of data points, while the theoretical prediction is made for the limit of infinite data points.\n\n\n\n\n\n\nAnalysis of MSD data\n\n\n\nSingle particle tracking, either in the experiment or in numerical simulations can therefore only deliver an estimate of the diffusion coefficient and care should be taken when using the whole MSD to obtain the diffusion coefficient. One typically uses only a short fraction of the whole MSD data at short times.",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/02-lecture04.html#summary",
    "href": "lectures/lecture04/02-lecture04.html#summary",
    "title": "12  Brownian Motion",
    "section": "12.5 Summary",
    "text": "12.5 Summary\nIn this lecture, we have:\n\nExplored the physical principles behind Brownian motion and its mathematical description\nImplemented a computational model using object-oriented programming principles\nCreated a Colloid class with properties and methods that simulate realistic particle behavior\nGenerated and visualized multiple particle trajectories\nAnalyzed the simulation results using mean squared displacement calculations\nCompared our numerical results with theoretical predictions\n\nThis exercise demonstrates how object-oriented programming provides an elegant framework for physics simulations, where the objects in our code naturally represent physical entities in the real world.",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "lectures/lecture04/02-lecture04.html#further-reading",
    "href": "lectures/lecture04/02-lecture04.html#further-reading",
    "title": "12  Brownian Motion",
    "section": "12.6 Further Reading",
    "text": "12.6 Further Reading\n\nEinstein, A. (1905). “On the Movement of Small Particles Suspended in Stationary Liquids Required by the Molecular-Kinetic Theory of Heat”\nBerg, H.C. (1993). “Random Walks in Biology”\nChandrasekhar, S. (1943). “Stochastic Problems in Physics and Astronomy”\nNelson, E. (2001). “Dynamical Theories of Brownian Motion”",
    "crumbs": [
      "Lecture 4",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "seminars/seminar02/md1.html",
    "href": "seminars/seminar02/md1.html",
    "title": "13  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "13.1 Molecular Dynamics Simulations\nReal molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\nBefore we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation. The Jupyter Notebook below will help you to copy and paste the code to test the snippets presented.",
    "crumbs": [
      "Seminar 2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar02/md1.html#molecular-dynamics-simulations",
    "href": "seminars/seminar02/md1.html#molecular-dynamics-simulations",
    "title": "13  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "Open in New Window",
    "crumbs": [
      "Seminar 2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar02/md1.html#basic-physical-concepts",
    "href": "seminars/seminar02/md1.html#basic-physical-concepts",
    "title": "13  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "13.2 Basic Physical Concepts",
    "text": "13.2 Basic Physical Concepts\n\n13.2.1 Newton’s Equations of Motion\nThe motion of particles in a molecular dynamics simulation is governed by Newton’s equations of motion:\n\\[m_i \\frac{d^2\\vec{r}_i}{dt^2} = \\vec{F}_i\\]\nwhere \\(m_i\\) is the mass of particle \\(i\\), \\(\\vec{r}_i\\) is the position of particle \\(i\\), and \\(\\vec{F}_i\\) is the force acting on particle \\(i\\).\nThe force acting on a particle is the sum of all forces acting on it:\n\\[\\vec{F}_i = \\sum_{j \\neq i} \\vec{F}_{ij}\\]\nwhere \\(\\vec{F}_{ij}\\) is the force acting on particle \\(i\\) due to particle \\(j\\).\n\n\n13.2.2 Potential Energy Functions and Forces\nThe force \\(\\vec{F}_{ij}\\) is usually derived from a potential energy function and may result from a variety of interactions, such as:\n\n\n\n\n\n\n\n\nInteraction Type\nSubtype\nIllustration\n\n\n\n\nBonded interactions\nBond stretching\n\n\n\n\nBond angle bending\n\n\n\n\nTorsional interactions\n\n\n\nNon-bonded interactions\nElectrostatic interactions\n\n\n\n\nVan der Waals interactions\n\n\n\nExternal forces\n\n\n\n\n\nWe will implement some of them but not all of them.\n\n13.2.2.1 Lennard-Jones Potential\nThe most common potential energy function used in MD simulations is the Lennard-Jones potential. It is belonging to the class of non-bonded interactions. The force and the potential energy of the Lennard-Jones potential are given by:\n\\[V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]\nand\n\\[F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}\\]\nwhere \\(\\frac{\\vec{r}}{r^2}\\) represents the direction of the force (the unit vector \\(\\hat{r} = \\frac{\\vec{r}}{r}\\)) multiplied by \\(\\frac{1}{r}\\), and \\(\\epsilon\\) is the depth of the potential well, \\(\\sigma\\) is the distance at which the potential is zero, and \\(r\\) is the distance between particles.\nThe Lenard Jones potential is good for describing the interaction of non-bonded atoms in a molecular system e.g. in a gas or a liquid and is therefore well suited if we first want to simulate a gas or a liquid.\n\n\n\n\n\n\n\n\n\nThe figure above shows the Lennard-Jones potential as a function of the distance between particles. The potential energy is zero at the equilibrium distance \\(r = \\sigma\\) and has a minimum at \\(r = 2^{1/6}\\sigma\\). The potential energy is positive for \\(r &lt; \\sigma\\) and negative for \\(r &gt; \\sigma\\).\n\n\n\n\n\n\nValues for atomic hydrogen\n\n\n\nFor atomic hydrogen (H), typical Lennard-Jones parameters are:\n\n\\(\\sigma \\approx 2.38\\) Å = \\(2.38 \\times 10^{-10}\\) meters\n\\(\\epsilon \\approx 0.0167\\) kcal/mol = \\(1.16 \\times 10^{-21}\\) joules\n\n\n\nLater, if we manage to advance to some more complicated systems, we may want to introduce:\n\nforce in bonds between two atoms\nforce in bond angles between three atoms\nforce in dihedral angles between four atoms\n\nBut for now, we will stick to the Lennard-Jones potential.",
    "crumbs": [
      "Seminar 2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar02/md1.html#integrating-newtons-equation-of-motion",
    "href": "seminars/seminar02/md1.html#integrating-newtons-equation-of-motion",
    "title": "13  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "13.3 Integrating Newton’s Equation of Motion",
    "text": "13.3 Integrating Newton’s Equation of Motion\nWhen we have the forces on a particle we have in principle its acceleration. To get the velocity and the position of the particle we need to integrate the equations of motion. There are several methods to do this, but we will start with the simplest one, the Euler method.\n\n13.3.1 Euler Method\nTo obtain this one first needs to know about the Taylor expansion of a function in general. The Taylor expansion of a function \\(f(x)\\) around a point \\(x_0\\) is providing an approximation of the function in the vicinity of \\(x_0\\). It is given by:\n\\[f(x) = f(x_0) + f'(x_0)(x - x_0) + \\frac{1}{2}f''(x_0)(x - x_0)^2 + \\cdots\\]\nwhere \\(f'(x_0)\\) is the first derivative of \\(f(x)\\) at \\(x_0\\), \\(f''(x_0)\\) is the second derivative of \\(f(x)\\) at \\(x_0\\), and so on. We can demonstrate that by expanding a sine function around \\(x_0 = 0\\):\n\\[\\sin(x) = \\sin(0) + \\cos(0)x - \\frac{1}{2}\\sin(0)x^2 + \\cdots = x - \\frac{1}{6}x^3 + \\cdots\\]\nPlotting this yields:\n\n\n\n\n\n\n\n\n\nThe expansion is therefore a good approximation in a region close to \\(x_0\\).\n\n\n13.3.2 Velocity Verlet Algorithm\nThe velocity Verlet algorithm is a second-order algorithm that offers greater accuracy than the Euler method. It can be derived from the Taylor expansion of the position and velocity vectors:\n\\[\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2+ O(\\Delta t^3)\\]\nThe higher order terms in the Taylor expansion are neglected, which results in an error of order \\(\\Delta t^3\\). In contrast, the Euler method is obtained by neglecting the higher order terms in the Taylor expansion of the velocity vector:\n\\[\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m}\\Delta t + O(\\Delta t^2)\\]\nThis makes the Euler method only first order accurate with an error of order \\(\\Delta t^2\\).\nThe Velocity Verlet algorithm is particularly valuable for molecular dynamics simulations because it offers several advantages over the Euler method. It does a much better job preserving the total energy of the system over long simulation times. The algorithm is also time-reversible, which is a property of the exact equations of motion. Furthermore, it provides symplectic integration, preserving the phase space volume, another important property for physical simulations. These properties make the Velocity Verlet algorithm much more stable for long simulations, which is crucial when modeling molecular systems over meaningful timescales.\nThe velocity Verlet algorithm provides a stable and accurate way to integrate the equations of motion through a three-stage process. First, we update positions using current velocities and forces: \\[\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2\\]\nNext, we calculate new forces based on these updated positions: \\[\\mathbf{F}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))\\]\nFinally, we update velocities using an average of old and new forces: \\[\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\frac{\\mathbf{F}(t) + \\mathbf{F}(t + \\Delta t)}{m}\\Delta t\\]\nIn these equations, \\(\\mathbf{r}\\) represents the position vector, \\(\\mathbf{v}\\) is the velocity vector, \\(\\mathbf{F}\\) is the force vector, \\(m\\) stands for mass, and \\(\\Delta t\\) is the timestep. This approach ensures greater accuracy and stability in our molecular dynamics simulations compared to simpler methods.\n\n\n13.3.3 Simple Integration Example: Free Fall\nLet’s start by integrating the equation of motion for a particle in free fall using the Velocity Verlet algorithm. This is an ideal starting example since the physics is straightforward, with gravity being the only force acting on the particle, and we can compare our numerical solution to the well-known analytical one.\nNewton’s equation of motion: \\[\\mathbf{F} = m\\mathbf{a}\\]\nFor gravity, the only force acting on our particle is the gravitational force pointing downward: \\[\\mathbf{F} = -mg\\hat{\\mathbf{y}}\\]\nTherefore, the acceleration in the y-direction is constant: \\[\\ddot{y} = -g\\]\nThe analytical solution to this differential equation gives us the position and velocity at any time \\(t\\). The position is given by \\[y(t) = y_0 + v_0t - \\frac{1}{2}gt^2\\], and the velocity is expressed as \\[v(t) = v_0 - gt\\]. Here, \\(y_0\\) is the initial height, \\(v_0\\) is the initial velocity, and \\(g\\) is the acceleration due to gravity. We can use this exact solution to verify our numerical integration method.",
    "crumbs": [
      "Seminar 2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar03/md2.html",
    "href": "seminars/seminar03/md2.html",
    "title": "14  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "14.1 From Theory to Code\nIn the previous seminar, we learned about the key components of a molecular dynamics simulation:\nNow we’ll implement these concepts in code. To organize our simulation, we’ll have to think about some issues:",
    "crumbs": [
      "Seminar 3",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar03/md2.html#from-theory-to-code",
    "href": "seminars/seminar03/md2.html#from-theory-to-code",
    "title": "14  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "The Lennard-Jones potential describing forces between atoms\nThe Velocity Verlet algorithm for updating positions and velocities\n\n\n\n14.1.1 What to do at the boundary: Boundary Conditions\nIn the previous example, we have assumed that the particle is in free fall. That means eventually it would bounce against the floor. In a real simulation, we need to consider boundary conditions as well. For example, if the particle hits the ground we could implement a simple reflection rule. This is called reflecting boundary conditions and would introduce some additional effects to the simulation. On the other side, one could make the system “kind of” infinitely large by introducing periodic boundary conditions. This means that if a particle leaves the simulation box on one side, it re-enters on the opposite side. This is a common approach in molecular dynamics simulations.\n\n\n\nPerdiodic Boundary Conditions\n\n\n\n\n\n\n\n\nThe Minimum Image Convention in Molecular Dynamics\n\n\n\n\n\nWhen we simulate particles in a box with periodic boundary conditions (meaning particles that leave on one side reappear on the opposite side), we need to calculate the forces between them correctly. Imagine two particles near opposite edges of the box: one at position x=1 and another at x=9 in a box of length 10. Without the minimum image convention, we would calculate their distance as 8 units (9-1). However, due to the periodic boundaries, these particles could actually interact across the boundary, with a shorter distance of just 2 units! The minimum image convention automatically finds this shortest distance, ensuring that we calculate the forces between particles correctly. It’s like taking a shortcut across the periodic boundary instead of walking the longer path through the box.\n\n\n\n\n\n14.1.2 How to represent atoms\nThe question we have to think about now is how to implement these formulas in a numerical simulation. The goal is to simulate the motion of many atoms in a box. Each atom is different and has its own position, velocity, and force. Consequently we need to store these quantities for each atom, though the structure in which we store them is the same for each atom. All atoms with their properties actually belong to the same class of objects. We can therefore use a very suitable concept of object-oriented programming, the class.\nA class in object-oriented programming is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods). The class is a template for objects, and an object is an instance of a class. The class defines the properties and behavior common to all objects of the class. The objects are the instances of the class that contain the actual data.\nThink of the Atom class as a container for everything we need to know about a single atom:\n\nIts position (where is it?)\nIts velocity (how fast is it moving?)\nThe forces acting on it (what’s pushing or pulling it?)\nIts type (is it hydrogen, oxygen, etc.?)\nIts mass (how heavy is it?)\n\n\n\n14.1.3 How to represent forces\nWe also have a set of forces, that is acting between the atoms. These forces are calculated based on the positions of the atoms. The force fields are all the same for the atoms only the parameters are different. We can represent the force field as a class as well. We will first implement the Lennard-Jones potential in the class. Later we will implement more complex force fields. We will realize that we will later have to introduce different parameters for the Lenard Jones potential for different atom types. We will store these parameters in a dictionary. This dictionary will be part of the force field class and actually represent the Force Field.\nIf atoms are of the same type, they will have the same parameters. However, if they are of different types we will have to mix the parameters. This is done by the mixing rules. We will implement the Lorentz-Berthelot mixing rules. These rules are used to calculate the parameters for the interaction between two different atom types.\n\n14.1.3.1 Lorentz-Berthelot Mixing Rules\nFor two different atoms (A and B), the Lennard-Jones parameters \\(\\sigma\\) and \\(\\epsilon\\) are calculated using:\n\nArithmetic mean for \\(\\sigma\\) (Lorentz rule):\n\\[\\sigma_{AB} = \\frac{\\sigma_A + \\sigma_B}{2}\\]\nGeometric mean for \\(\\epsilon\\) (Berthelot rule):\n\\[\\epsilon_{AB} = \\sqrt{\\epsilon_A \\epsilon_B}\\]\n\nThese parameters are then used in the Lennard-Jones potential:\n\\[V_{LJ}(r) = 4\\epsilon_{AB}\\left[\\left(\\frac{\\sigma_{AB}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{AB}}{r}\\right)^6\\right]\\]\n\n\n\n14.1.4 How do we introduce temperature\nIn the previous example, we have started with a particle at rest. In a real simulation, we would like to start with a certain temperature. This means that the particles have a certain velocity distribution. We can introduce this by assigning random velocities to the particles. The velocities should be drawn from a Maxwell-Boltzmann distribution. This is a distribution that describes the velocity distribution of particles in at a certain temperature. The distribution is given by:\n\\[\nf_v\\left(v_x\\right)=\\sqrt{\\frac{m}{2 \\pi k_B T}} \\exp \\left[\\frac{-m v_x^2}{2 k_B T}\\right]\n\\]\nwhere \\(m\\) is the mass of the particle, \\(k_B\\) is Boltzmann’s constant, and \\(T\\) is the temperature. \\(v_x\\) is the velocity in the x-direction. The velocities in the y and z directions are drawn in the same way. The temperature of the system is related to the kinetic energy of the particles.\n\n\n\n\n\n\nMaxwell-Boltzmann Velocities in 3D\n\n\n\n\n\nThe probability distribution for the velocity magnitude in 3D is:\n\\[f(v) = 4\\pi v^2 \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\exp\\left(-\\frac{mv^2}{2k_BT}\\right)\\]\n\nMean velocity magnitude:\n\\[\\langle v \\rangle = \\sqrt{\\frac{8k_BT}{\\pi m}}\\]\nMost probable velocity (peak of distribution):\n\\[v_{mp} = \\sqrt{\\frac{2k_BT}{m}}\\]\nRoot mean square velocity:\n\\[v_{rms} = \\sqrt{\\frac{3k_BT}{m}}\\]\n\nThese velocities can also be expressed in terms of the kinetic energy of the particles. The average kinetic energy per particle is:\n\\[\\langle E_{kin} \\rangle = \\frac{3}{2}k_BT\\]\nThen we can express the velocities as:\n\nMean velocity magnitude:\n\\[\\langle v \\rangle = \\sqrt{\\frac{8\\langle E_{kin} \\rangle}{3\\pi m}}\\]\nMost probable velocity:\n\\[v_{mp} = \\sqrt{\\frac{4\\langle E_{kin} \\rangle}{3m}}\\]\nRoot mean square velocity:\n\\[v_{rms} = \\sqrt{\\frac{2\\langle E_{kin} \\rangle}{m}}\\]\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14.1: Maxwell Boltzmann distribution of speeds for one component of the velocity and the magnitude of the velocity vector.\n\n\n\n\n\nMost probable velocity magnitude in 2D: 1573.2 m/s\nMean velocity magnitude in 2D: 2224.8 m/s\n\n\nThe temperature T in a 2D system is related to the kinetic energy by:\n\\[T = \\frac{2K}{N_f k_B}\\]\nwhere:\n\nK is the total kinetic energy: \\(K = \\sum_i \\frac{1}{2}m_i v_i^2\\)\n\\(N_f\\) is the number of degrees of freedom (2N in 2D, where N is number of particles)\n\\(k_B\\) is Boltzmann’s constant (often set to 1 in reduced units)\n\nTo scale to a target temperature \\(T_{target}\\), we multiply velocities by \\(\\sqrt{\\frac{T_{target}}{T_{current}}}\\)\n\n\n14.1.5 Who is controlling our simulation: Controller Class\nFinally, we need a class that controls the simulation. This class will contain the main loop of the simulation, where the integration algorithm is called in each time step. It will also contain the methods to calculate the forces between the atoms.\n\n\n14.1.6 How do we visualize our simulation\nBefore we implement all classes, we will first visualize the particles moving in a 2D box. We will use the matplotlib library to create an animation of the particles moving in the box. We will also implement periodic boundary conditions, so that particles that leave the box on one side re-enter on the opposite side.\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom IPython.display import clear_output\nfrom scipy.spatial.distance import cdist\n\nn_side =2\n\n1x = np.linspace(0.05, 0.95, n_side)\ny = np.linspace(0.05, 0.95, n_side)\n2xx, yy = np.meshgrid(x, y)\n3particles = np.vstack([xx.ravel(), yy.ravel()]).T\n\nvelocities = np.random.normal(scale=0.005, size=(n_side**2, 2))\n\nradius = 0.0177\nfig, ax = plt.subplots(figsize=(9,9))\n\nn_steps = 200\n\n4for _ in range(n_steps):\n5    clear_output(wait=True)\n\n    # Update particle positions based on their velocities\n    particles += velocities\n    # Apply periodic boundary conditions in x direction (wrap around at 0 and 1)\n    particles[:, 0] = particles[:, 0] % 1\n    # Apply periodic boundary conditions in y direction (wrap around at 0 and 1)\n    particles[:, 1] = particles[:, 1] % 1\n    # Calculate distances between all pairs of particles\n    distances = cdist(particles, particles)\n\n    # Calculate collisions using the upper triangle of the distance matrix\n    # distances &lt; 2*radius gives a boolean matrix where True means collision\n    # np.triu takes only the upper triangle to avoid counting collisions twice\n    collisions = np.triu(distances &lt; 2*radius, 1)\n\n    # Handle collisions between particles\n    for i, j in zip(*np.nonzero(collisions)):\n        # Exchange velocities between colliding particles (elastic collision)\n6        velocities[i], velocities[j] = velocities[j], velocities[i].copy()\n\n        # Calculate how much particles overlap\n        overlap = 2*radius - distances[i, j]\n\n        # Calculate unit vector pointing from j to i\n        direction = particles[i] - particles[j]\n        direction /= np.linalg.norm(direction)\n\n        # Move particles apart to prevent overlap\n        particles[i] += 0.5 * overlap * direction\n        particles[j] -= 0.5 * overlap * direction\n\n    ax.scatter(particles[:, 0], particles[:, 1], s=100, edgecolors='r', facecolors='none')\n\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.axis(\"off\")\n\n    display(fig)\n    plt.pause(0.01)\n\n    # Clear the current plot to prepare for next frame\n    ax.clear()\n\n1\n\nCreate a 1D array of x and y-coordinates for the particles.\n\n2\n\nCreate a meshgrid of x and y-coordinates.\n\n3\n\nFlatten the meshgrid to get a 2D array of particle positions.\n\n4\n\nSimulation loop\n\n5\n\nClear the output to display the animation in a single cell.\n\n6\n\nHandle collisions between particles by exchanging velocities and moving particles apart to prevent overlap. The exchange of velocities in your code works because of the conservation of momentum and energy:\n\n\n\nFor two particles of equal mass m in a head-on elastic collision: Before collision:\n\nMomentum: \\(p = mv_1 + mv_2\\)\nEnergy: \\(E = \\frac{1}{2}mv_1^2 + \\frac{1}{2}mv_2^2\\)\n\nAfter collision (with velocity exchange): - Momentum: \\(p = mv_2 + mv_1\\) (same as before!) - Energy: \\(E = \\frac{1}{2}mv_2^2 + \\frac{1}{2}mv_1^2\\) (same as before!)\n\n\nfrom IPython.display import clear_output\nfrom scipy.spatial.distance import cdist\nfrom scipy.stats import maxwell\n\n# Increase number of particles for better statistics\nn_side = 10  # Creates 100 particles\nx = np.linspace(0.05, 0.95, n_side)\ny = np.linspace(0.05, 0.95, n_side)\nxx, yy = np.meshgrid(x, y)\nparticles = np.vstack([xx.ravel(), yy.ravel()]).T\n\n# Initialize with normal distribution\nvelocities = np.random.normal(scale=0.005, size=(n_side**2, 2))\nradius = 0.0177\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(15, 8))\nn_steps = 500\n\n# Store velocity magnitudes for analysis\nvelocity_history = []\n\nfor step in range(n_steps):\n    clear_output(wait=True)\n    # Update particle positions based on their velocities\n    particles += velocities\n\n    # Apply periodic boundary conditions\n    particles = particles % 1\n\n    # Calculate distances between all pairs of particles\n    distances = cdist(particles, particles)\n\n    # Calculate collisions using the upper triangle of the distance matrix\n    collisions = np.triu(distances &lt; 2*radius, 1)\n\n    # Handle collisions between particles\n    for i, j in zip(*np.nonzero(collisions)):\n        # Get particle positions and velocities\n        pos_i, pos_j = particles[i], particles[j]\n        vel_i, vel_j = velocities[i], velocities[j]\n\n        # Calculate relative position vector (line of centers)\n        r_ij = pos_i - pos_j\n        dist = np.linalg.norm(r_ij)\n        r_ij_normalized = r_ij / dist if dist &gt; 0 else np.array([1, 0])\n\n        # *** CORRECTED COLLISION PHYSICS ***\n        # Split velocities into components parallel and perpendicular to collision axis\n        v_i_parallel = np.dot(vel_i, r_ij_normalized) * r_ij_normalized\n        v_i_perp = vel_i - v_i_parallel\n\n        v_j_parallel = np.dot(vel_j, r_ij_normalized) * r_ij_normalized\n        v_j_perp = vel_j - v_j_parallel\n\n        # Exchange parallel components (proper elastic collision)\n        velocities[i] = v_i_perp + v_j_parallel\n        velocities[j] = v_j_perp + v_i_parallel\n\n        # Move particles apart to prevent overlap\n        overlap = 2*radius - dist\n        particles[i] += 0.5 * overlap * r_ij_normalized\n        particles[j] -= 0.5 * overlap * r_ij_normalized\n\n    # Every 5 steps, record velocity magnitudes\n    if step % 5 == 0:\n        speeds = np.sqrt(np.sum(velocities**2, axis=1))\n        velocity_history.extend(speeds)\n\n    # Every 20 steps, update the visualization\n    if step % 20 == 0:\n        # Clear the current plot to prepare for next frame\n        ax1.clear()\n        ax2.clear()\n\n        # Plot particles\n        ax1.scatter(particles[:, 0], particles[:, 1], s=100, edgecolors='r', facecolors='none')\n        ax1.set_xlim(0, 1)\n        ax1.set_ylim(0, 1)\n        ax1.set_title(f\"Step {step}\")\n        ax1.axis(\"off\")\n\n        # Plot velocity distribution\n        if velocity_history:\n            # Plot histogram of speeds\n            hist, bins = np.histogram(velocity_history, bins=30, density=True)\n            bin_centers = 0.5 * (bins[1:] + bins[:-1])\n            ax2.bar(bin_centers, hist, width=bins[1]-bins[0], alpha=0.7, label='Simulation')\n\n            # Plot Maxwell-Boltzmann distribution for comparison\n            # For 2D Maxwell-Boltzmann, use Rayleigh distribution parameters\n            scale = np.std(velocity_history) / np.sqrt(1 - 2/np.pi)\n            x = np.linspace(0, max(velocity_history), 100)\n\n            # In 2D, speed follows Rayleigh distribution\n            rayleigh_pdf = (x/scale**2) * np.exp(-x**2/(2*scale**2))\n            ax2.plot(x, rayleigh_pdf, 'r-', lw=2, label='Maxwell-Boltzmann (2D)')\n\n            ax2.set_title(\"Speed Distribution\")\n            ax2.set_xlabel(\"Speed\")\n            ax2.set_ylabel(\"Probability Density\")\n            ax2.legend()\n\n        display(fig)\n        plt.pause(0.01)\n\n# Final velocity distribution\nplt.figure(figsize=get_size(12, 8))\nhist, bins = np.histogram(velocity_history, bins=30, density=True)\nbin_centers = 0.5 * (bins[1:] + bins[:-1])\nplt.bar(bin_centers, hist, width=bins[1]-bins[0], alpha=0.7, label='Simulation')\n\n# Plot ideal Maxwell-Boltzmann distribution for 2D (Rayleigh)\nscale = np.std(velocity_history) / np.sqrt(1 - 2/np.pi)\nx = np.linspace(0, max(velocity_history), 100)\nrayleigh_pdf = (x/scale**2) * np.exp(-x**2/(2*scale**2))\nplt.plot(x, rayleigh_pdf, 'r-', lw=2, label='MB (2D)')\n\n\nplt.xlabel(r\"speed $v$\")\nplt.ylabel(\"probability density\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\nFigure 14.2: Simulated and analytica for the Maxwell-Boltzmann distribution.",
    "crumbs": [
      "Seminar 3",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar04/md3.html",
    "href": "seminars/seminar04/md3.html",
    "title": "15  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "15.1 Implementations",
    "crumbs": [
      "Seminar 4",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  },
  {
    "objectID": "seminars/seminar04/md3.html#implementations",
    "href": "seminars/seminar04/md3.html#implementations",
    "title": "15  Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "15.1.1 The Atom Class\nWe define a class Atom that contains the properties of an atom. The class Atom has the following attributes:\nclass Atom:\n    dimension = 2\n\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.zeros(dimension)\n        self.mass = mass\n        self.force = np.zeros(dimension)\nThe class Atom has the following attributes:\n\nid: The unique identifier of the atom\ntype: The type of the atom (hydrogen or oxygen or …)\nposition: The position of the atom in 3D space (x, y, z)\nvelocity: The velocity of the atom in 3D space (vx, vy, vz)\nmass: The mass of the atom\nforce: The force acting on the atom in 3D space (fx, fy, fz)\n\nIn addition, we will need some information on the other atoms that are bound to the atom. We will store this information later in a list of atoms called boundto. Since we start with a monoatomic gas, we will not need this information for now. Note that position, velocity, and force are 3D vectors and we store them in numpy arrays. This is a very convenient way to handle vectors and matrices in Python.\nThe class Atom should further implement a number of functions, called methods in object-oriented programming, that allow us to interact with the atom. The following methods are implemented in the Atom class:\n\n15.1.1.1 add_force(force): Adds a force acting on the atom\ndef add_force(self, force):\n    \"\"\"Add force contribution to total force on atom\"\"\"\n    self.force += force\n\n\n15.1.1.2 reset_force(): Resets the force acting on the atom\ndef reset_force(self):\n    \"\"\"Reset force to zero at start of each step\"\"\"\n    self.force = np.zeros(dimension)\n\n\n15.1.1.3 update_position(dt): Updates the position of the atom\ndef update_position(self, dt):\n    \"\"\"First step of velocity Verlet: update position\"\"\"\n    self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n\n15.1.1.4 update_velocity(dt): Updates the velocity of the atom\ndef update_velocity(self, dt, new_force):\n    \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n    self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n    self.force = new_force\n\n\n15.1.1.5 apply_periodic_boundaries(box_size): Applies periodic boundary conditions to the atom\ndef apply_periodic_boundaries(self, box_size):\n        \"\"\"Apply periodic boundary conditions\"\"\"\n        self.position = self.position % box_size\n\n\n\n\n\n\nComplete Atom class\n\n\n\n\n\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.random.randn(2)*20\n        self.mass = mass\n        self.force = np.zeros(2)\n\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(2)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\n    def apply_periodic_boundaries(self, box_size):\n            \"\"\"Apply periodic boundary conditions\"\"\"\n            self.position = self.position % box_size\n\n\n\nThis would be a good time to do something simple with the atom class. Let’s create a bunch of atoms and plot them in a 2D space.",
    "crumbs": [
      "Seminar 4",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Step-by-Step Development of a Molecular Dynamics Simulation</span>"
    ]
  }
]