[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Computer-based Physical Modeling",
    "section": "",
    "text": "1 Welcome to Computer-Based Physical Modelling!\nThe programming language Python is useful for all kinds of scientific and technical tasks. You can use it to analyze and visualize data. You can also use it to numerically solve scientific problems that are difficult or impossible to solve analytically. Python is freely available and, due to its modular structure, has been expanded with an almost infinite number of modules for various purposes.\nThis course aims to introduce you to programming with Python. It is primarily aimed at beginners, but we hope it will also be interesting for advanced users. We begin the course with an introduction to the Jupyter Notebook environment, which we will use throughout the entire course. Afterward, we will provide an introduction to Python and show you some basic functions, such as plotting and analyzing data through curve fitting, reading and writing files, which are some of the tasks you will encounter during your physics studies. We will also show you some advanced topics such as animation in Jupyter and the simulation of physical processes in\n\nMechanics\nElectrostatics\nWaves\nOptics\n\nIf there is time left at the end of the course, we will also take a look at machine learning methods, which have become an important tool in physics as well.\nWe will not present a comprehensive list of numerical simulation schemes, but rather use the examples to spark your curiosity. Since there are slight differences in the syntax of the various Python versions, we will always refer to the Python 3 standard in the following.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CBPM 2025</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/00-lecture01.html",
    "href": "lectures/lecture01/00-lecture01.html",
    "title": "2  Programming Background Questionnaire",
    "section": "",
    "text": "Please complete this short questionnaire to help tailor the course to your needs. Your responses are anonymous and will be used only to adapt the teaching to your level of experience.\n\n  Loading…",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Programming Background Questionnaire</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html",
    "href": "lectures/lecture01/01-lecture01.html",
    "title": "3  Jupyter Notebooks",
    "section": "",
    "text": "3.1 What is a Jupyter Notebook?\nThroughout this course we will have to create and edit python code. We will primarily use this webpage for convenience, but for day-to-day work in the laboratory, it’s beneficial to utilize a code editor or a notebook environment like JupyterLab. JupyterLab is a robust platform that enables you to develop and modify notebooks within a web browser, while also offering comprehensive capabilities for analyzing and visualizing data.\nA Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#what-is-a-jupyter-notebook",
    "href": "lectures/lecture01/01-lecture01.html#what-is-a-jupyter-notebook",
    "title": "3  Jupyter Notebooks",
    "section": "",
    "text": "3.1.1 Key Components of a Notebook\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\n3.1.1.1 Notebook Editor\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It enables users to write and run code, add rich text, and multimedia content. When running Jupyter on a server, users typically use either the classic Jupyter Notebook interface or JupyterLab, an advanced version with more features.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\n3.1.2 Kernels\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\n3.1.3 JupyterLab Example\nThe following is an example of a JupyterLab interface with a notebook editor, code cells, markdown cells, and a kernel selector:\nFull Screen\n\n\n\n\n\n3.1.4 Notebook Documents\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "href": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "title": "3  Jupyter Notebooks",
    "section": "3.2 Using the Notebook Editor",
    "text": "3.2 Using the Notebook Editor\n\n\n\nJupyter Notebook Editor\n\n\nThe Jupyter Notebook editor provides an interactive environment for writing code, creating visualizations, and documenting computational workflows. It consists of a web-based interface that allows users to create and edit notebook documents containing code, text, equations, images, and interactive elements. A Jupyter Notebook provides an interface with essentially two modes of operation:\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab you can also have a presentation mode where you can present your notebook as a slideshow.\n\n3.2.1 Edit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area when a cell is selected. You can enter edit mode by pressing Enter or using the mouse to click on a cell’s editor area.\n\n\n\nEdit Mode\n\n\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor\n\n\n3.2.2 Command mode\nCommand mode is indicated by a grey cell border with a blue left margin. When you are in command mode, you are able to edit the notebook as a whole, but not type into individual cells. Most importantly, in command mode, the keyboard is mapped to a set of shortcuts that let you perform notebook and cell actions efficiently.\n\n\n\nCommand Mode\n\n\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\n3.2.3 Keyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor area. Thus, in edit mode there are relatively few shortcuts available. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\n3.2.4 Running code\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\n\n23752636\n\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "href": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "title": "3  Jupyter Notebooks",
    "section": "3.3 Managing the kernel",
    "text": "3.3 Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "href": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "title": "3  Jupyter Notebooks",
    "section": "3.4 Markdown in Notebooks",
    "text": "3.4 Markdown in Notebooks\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\n3.4.1 Markdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold. You can build nested itemized or enumerated lists:\n\n\n3.4.2 Markdown lists example\n\nFirst item\n\nFirst subitem\n\nFirst sub-subitem\n\nSecond subitem\n\nFirst subitem of second subitem\nSecond subitem of second subitem\n\n\nSecond item\n\nFirst subitem\n\nThird item\n\nFirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\n\n\n3.4.3 Blockquote example\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Namespaces are one honking great idea – let’s do more of those!\n\n\n\n3.4.4 Web links example\nJupyter’s website\n\n\n3.4.5 Headings\nYou can add headings by starting a line with one (or multiple) # followed by a space and the title of your section. The number of # you use will determine the size of the heading\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\n3.4.6 Embedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\n\n\n3.4.7 LaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\n3.4.8 Images\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\n\n3.4.9 Videos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/python_lecture01.html",
    "href": "lectures/lecture01/python_lecture01.html",
    "title": "4  Python & Anatomy of a Python Program",
    "section": "",
    "text": "4.1 What is Python?\nPython is a high-level, interpreted programming language known for its readability and simplicity. Created by Guido van Rossum in 1991, it emphasizes code readability with its clear syntax and use of indentation. Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming. It comes with a comprehensive standard library and has a vast ecosystem of third-party packages, making it suitable for various applications such as web development, data analysis, artificial intelligence, scientific computing, and automation. Python’s “batteries included” philosophy and gentle learning curve have contributed to its popularity among beginners and experienced developers alike.\nFor physics students specifically, Python has become the language of choice for data analysis, simulation, and visualization in scientific research. Libraries like NumPy, SciPy, and Matplotlib provide powerful tools for solving physics problems, from basic mechanics to quantum mechanics.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python & Anatomy of a Python Program</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/python_lecture01.html#anatomy-of-a-python-program",
    "href": "lectures/lecture01/python_lecture01.html#anatomy-of-a-python-program",
    "title": "4  Python & Anatomy of a Python Program",
    "section": "4.2 Anatomy of a Python Program",
    "text": "4.2 Anatomy of a Python Program\nUnderstanding the basic structure of a Python program is essential for beginners. Let’s break down the fundamental elements that make up a typical Python program.\n\n4.2.1 Basic Elements\n\n\n\n\n\n\n\n\nElement\nDescription\nExample\n\n\n\n\nStatements\nIndividual instructions that Python executes\nx = 10\n\n\nExpressions\nCombinations of values, variables, and operators that evaluate to a value\nx + 5\n\n\nBlocks\nGroups of statements indented at the same level\nFunction bodies, loops\n\n\nFunctions\nReusable blocks of code that perform specific tasks\ndef calculate_area(radius):\n\n\nComments\nNotes in the code that are ignored by the interpreter\n# This is a comment\n\n\nImports\nStatements that give access to external modules\nimport numpy as np\n\n\n\n\n\n4.2.2 Visual Structure of a Python Program\n# 1. Import statements (external libraries)\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint  # For solving differential equations\n\n# 2. Constants and global variables\nGRAVITY = 9.81  # m/s^2\nPLANCK_CONSTANT = 6.626e-34  # J·s\nELECTRON_MASS = 9.109e-31  # kg\n\n# 3. Function definitions\ndef calculate_kinetic_energy(mass, velocity):\n    \"\"\"\n    Calculate the kinetic energy of an object.\n\n    Parameters:\n        mass (float): Mass of the object in kg\n        velocity (float): Velocity of the object in m/s\n\n    Returns:\n        float: Kinetic energy in Joules\n    \"\"\"\n    return 0.5 * mass * velocity**2\n\ndef spring_force(k, displacement):\n    \"\"\"\n    Calculate the force exerted by a spring.\n\n    Parameters:\n        k (float): Spring constant in N/m\n        displacement (float): Displacement from equilibrium in m\n\n    Returns:\n        float: Force in Newtons (negative for restoring force)\n    \"\"\"\n    return -k * displacement\n\n# 4. Class definitions (if applicable)\nclass Particle:\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = position\n        self.velocity = velocity\n\n    def update_position(self, time_step):\n        # Simple Euler integration\n        self.position += self.velocity * time_step\n\n    def potential_energy(self, height, g=GRAVITY):\n        \"\"\"Calculate gravitational potential energy\"\"\"\n        return self.mass * g * height\n\n    def momentum(self):\n        \"\"\"Calculate momentum\"\"\"\n        return self.mass * self.velocity\n\n# 5. Main execution code\nif __name__ == \"__main__\":\n    # Create objects or variables\n    particle = Particle(1.0, np.array([0.0, 0.0]), np.array([1.0, 2.0]))\n\n    # Set up simulation parameters\n    time_step = 0.01  # seconds\n    total_time = 1.0  # seconds\n    n_steps = int(total_time / time_step)\n\n    # Arrays to store results\n    positions = np.zeros((n_steps, 2))\n    times = np.zeros(n_steps)\n\n    # Process data/perform calculations - simulate motion\n    for i in range(n_steps):\n        particle.update_position(time_step)\n        positions[i] = particle.position\n        times[i] = i * time_step\n\n    # Output results\n    print(f\"Final position: {particle.position}\")\n    print(f\"Final kinetic energy: {calculate_kinetic_energy(particle.mass, np.linalg.norm(particle.velocity))} J\")\n\n    # Visualize results (if applicable)\n    plt.figure(figsize=(10, 6))\n    plt.subplot(1, 2, 1)\n    plt.plot(positions[:, 0], positions[:, 1], 'r-')\n    plt.xlabel('X position (m)')\n    plt.ylabel('Y position (m)')\n    plt.title('Particle Trajectory')\n    plt.grid(True)\n\n    plt.subplot(1, 2, 2)\n    plt.plot(times, positions[:, 0], 'b-', label='x-position')\n    plt.plot(times, positions[:, 1], 'g-', label='y-position')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    plt.title('Position vs Time')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n\n4.2.3 Key Concepts\n\nModularity: Python programs are typically organized into functions and classes that encapsulate specific functionality.\nIndentation: Python uses indentation (typically 4 spaces) to define code blocks, unlike other languages that use braces {}.\nDocumentation: Good Python code includes docstrings (triple-quoted strings) that explain what functions and classes do.\nMain Block: The if __name__ == \"__main__\": block ensures code only runs when the file is executed directly, not when imported.\nReadability: Python emphasizes code readability with clear variable names and logical organization.\nPhysics Modeling: For physics problems, we typically model physical systems as objects with properties (mass, position, etc.) and behaviors (update_position, calculate_energy, etc.).\nNumerical Integration: Many physics problems require solving differential equations numerically using methods like Euler integration or Runge-Kutta.\nUnits: Always include appropriate SI units in your comments and documentation to ensure clarity in physics calculations.\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nKeep functions short and focused on a single task\nUse meaningful variable and function names\nInclude comments to explain why rather than what (the code should be self-explanatory)\nFollow PEP 8 style guidelines for consistent formatting\nStructure larger programs into multiple modules (files)\nFor physics simulations, validate your code against known analytical solutions when possible\nRemember to handle units consistently throughout your calculations\nConsider the appropriate numerical methods for the physical system you’re modeling\n\n\n\n\n\n\n\n\n\n\nPhysics-Specific Python Libraries\n\n\n\n\n\n\nNumPy: Provides array operations and mathematical functions\nSciPy: Scientific computing tools including optimization, integration, and differential equations\nMatplotlib: Plotting and visualization\nSymPy: Symbolic mathematics for analytical solutions\nPandas: Data manipulation and analysis\nastropy: Astronomy and astrophysics\nscikit-learn: Machine learning for data analysis\nPyMC: Probabilistic programming for statistical analysis",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python & Anatomy of a Python Program</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html",
    "href": "lectures/lecture01/02-lecture01.html",
    "title": "5  Variables & Numbers",
    "section": "",
    "text": "5.1 Variables in Python",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "href": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "title": "5  Variables & Numbers",
    "section": "",
    "text": "5.1.1 Symbol Names\nVariable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nPython has keywords that cannot be used as variable names. The most common ones you’ll encounter in physics programming are:\nif, else, for, while, return, and, or, lambda\nNote that lambda is particularly relevant as it could naturally appear in physics code, but since it’s reserved for anonymous functions in Python, it cannot be used as a variable name.\n\n\n\n\n5.1.2 Variable Assignment\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#number-types",
    "href": "lectures/lecture01/02-lecture01.html#number-types",
    "title": "5  Variables & Numbers",
    "section": "5.2 Number Types",
    "text": "5.2 Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers. These are some of the basic building blocks of doing arithmetic in any programming language. We will discuss each of these types in more detail.\n\n5.2.1 Comparison of Number Types\n\n\n\n\n\n\n\n\n\n\n\nType\nExample\nDescription\nLimits\nUse Cases\n\n\n\n\nint\n42\nWhole numbers\nUnlimited precision (bounded by available memory)\nCounting, indexing\n\n\nfloat\n3.14159\nDecimal numbers\nTypically ±1.8e308 with 15-17 digits of precision (64-bit)\nScientific calculations, prices\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts\nSame as float for both real and imaginary parts\nSignal processing, electrical engineering\n\n\nbool\nTrue / False\nLogical values\nOnly two values: True (1) and False (0)\nConditional operations, flags\n\n\n\n\n\n\n5.2.2 Examples\n\nIntegersFloating Point NumbersComplex Numbers\n\n\nInteger Representation: Integers are whole numbers without a decimal point.\n\n\n\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n\n\n\n\n\n\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\n\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n\n\n\n\n\n\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\n\n\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\n\n\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#operators",
    "href": "lectures/lecture01/02-lecture01.html#operators",
    "title": "5  Variables & Numbers",
    "section": "5.3 Operators",
    "text": "5.3 Operators\nPython provides a variety of operators for performing operations on variables and values. Here we’ll cover the most common operators used in scientific programming.\n\nArithmetic OperatorsComparison OperatorsLogical OperatorsAssignment Operators\n\n\nThese operators perform basic mathematical operations:\n\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n+\nAddition\n5 + 3\n8\n\n\n-\nSubtraction\n5 - 3\n2\n\n\n*\nMultiplication\n5 * 3\n15\n\n\n/\nDivision\n5 / 3\n1.6666…\n\n\n//\nFloor Division\n5 // 3\n1\n\n\n%\nModulus (remainder)\n5 % 3\n2\n\n\n**\nExponentiation\n5 ** 3\n125\n\n\n\n\n\n\n\n\n\n\n\nThese operators are used to compare values:\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n==\nEqual to\nx == y\n\n\n!=\nNot equal to\nx != y\n\n\n&gt;\nGreater than\nx &gt; y\n\n\n&lt;\nLess than\nx &lt; y\n\n\n&gt;=\nGreater than or equal to\nx &gt;= y\n\n\n&lt;=\nLess than or equal to\nx &lt;= y\n\n\n\n\n\n\n\n\n\n\n\nUsed to combine conditional statements:\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\n\n\n\n\nand\nReturns True if both statements are true\nx &gt; 0 and x &lt; 10\n\n\nor\nReturns True if one of the statements is true\nx &lt; 0 or x &gt; 10\n\n\nnot\nReverses the result, returns False if the result is true\nnot(x &gt; 0 and x &lt; 10)\n\n\n\n\n\n\n\n\n\n\n\nPython provides shorthand operators for updating variables:\n\n\n\nOperator\nExample\nEquivalent to\n\n\n\n\n=\nx = 5\nx = 5\n\n\n+=\nx += 3\nx = x + 3\n\n\n-=\nx -= 3\nx = x - 3\n\n\n*=\nx *= 3\nx = x * 3\n\n\n/=\nx /= 3\nx = x / 3\n\n\n//=\nx //= 3\nx = x // 3\n\n\n%=\nx %= 3\nx = x % 3\n\n\n**=\nx **= 3\nx = x ** 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperator Precedence\n\n\n\n\n\nPython follows the standard mathematical order of operations (PEMDAS):\n\nParentheses\nExponentiation (**)\nMultiplication and Division (*, /, //, %)\nAddition and Subtraction (+, -)\n\nWhen operators have the same precedence, they are evaluated from left to right.",
    "crumbs": [
      "Lecture 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Variables & Numbers</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html",
    "href": "lectures/lecture02/01-lecture02.html",
    "title": "6  Data Types",
    "section": "",
    "text": "6.1 Data Types\nIt’s time to look at different data types we may find useful in our course. Besides the number types mentioned previously, there are also other types like strings, lists, tuples, dictionaries and sets.\nEach of these data types has a number of connected methods (functions) which allow you to manipulate the data contained in a variable. If you want to know which methods are available for a certain object use the command dir, e.g.\nThe output would be:\nThe following few cells will give you a short introduction into each type.",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Types</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#data-types",
    "href": "lectures/lecture02/01-lecture02.html#data-types",
    "title": "6  Data Types",
    "section": "",
    "text": "Numeric TypesStringsListsTuplesDictionariesBooleanSets\n\n\nPython supports several numeric data types including integers, floats, and complex numbers.\n\n\n\n\n\n\nYou can perform various arithmetic operations with numeric types:\n\n\n\n\n\n\nType conversion works between numeric types:\n\n\n\n\n\n\n\n\nStrings are lists of keyboard characters as well as other characters not on your keyboard. They are useful for printing results on the screen, during reading and writing of data.\n\n\n\n\n\n\n\n\n\n\n\n\nString can be concatenated using the + operator.\n\n\n\n\n\n\n\n\n\n\n\n\nAs strings are lists, each character in a string can be accessed by addressing the position in the string (see Lists section)\n\n\n\n\n\n\nStrings can also be made out of numbers.\n\n\n\n\n\n\nIf you want to obtain a number of a string, you can use what is known as type casting. Using type casting you may convert the string or any other data type into a different type if this is possible. To find out if a string is a pure number you may use the str.isnumeric method. For the above string, we may want to do a conversion to the type int by typing:\n\n\n\n\n\n\n\n\n\n\n\n\nThere are a number of methods connected to the string data type. Usually the relate to formatting or finding sub-strings. Formatting will be a topic in our next lecture. Here we just refer to one simple find example.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLists are ordered, mutable collections that can store items of different data types.\n\n\n\n\n\n\nYou can access and modify list elements:\n\n\n\n\n\n\nCommon list methods:\n\n\n\n\n\n\n\n\nTuples are ordered, immutable sequences.\n\n\n\n\n\n\nTuples are immutable, meaning you cannot change their elements after creation:\n\n\n\n\n\n\n\n\nDictionaries store data as key-value pairs. They are mutable and unordered.\n\n\n\n\n\n\nAccessing and modifying dictionary elements:\n\n\n\n\n\n\nCommon dictionary methods:\n\n\n\n\n\n\n\n\nThe Boolean type has only two possible values: True and False.\n\n\n\n\n\n\nBoolean values are commonly used in conditional statements:\n\n\n\n\n\n\nBoolean operations:\n\n\n\n\n\n\n\n\nSets are unordered collections of unique elements.\n\n\n\n\n\n\nCommon set operations:\n\n\n\n\n\n\nAdding and removing elements:",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Types</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html",
    "href": "lectures/lecture02/02-lecture02.html",
    "title": "7  Python Overview",
    "section": "",
    "text": "7.1 Control Structures and Functions\nBuilding on our understanding of Python’s basic data types and operations, we’ll now explore how to control program flow and create reusable code blocks. These structures allow us to write more sophisticated programs that can make decisions, repeat operations, and organize code efficiently.",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#control-structures-and-functions",
    "href": "lectures/lecture02/02-lecture02.html#control-structures-and-functions",
    "title": "7  Python Overview",
    "section": "",
    "text": "7.1.1 Functions\nFunctions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n7.1.2 Loops\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n\nFor LoopWhile Loop\n\n\nA for loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here’s an example:\n\n\n\n\n\n\n\n\nA while loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n7.1.3 Conditional Statements\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are if, else, and elif.\n\nIf StatementElse StatementElif Statement\n\n\nAn if statement in Python is used to execute a block of code if a certain condition is met. Here’s an example:\n\n\n\n\n\n\n\n\nAn else statement in Python is used to execute a block of code if the condition in an if statement is not met. Here’s an example:\n\n\n\n\n\n\n\n\nAn elif statement in Python is used to execute a block of code if the condition in an if statement is not met but under an extra condition. Here’s an example:",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#exercises",
    "href": "lectures/lecture02/02-lecture02.html#exercises",
    "title": "7  Python Overview",
    "section": "7.2 Exercises",
    "text": "7.2 Exercises\nThe following exercises will help you practice using functions with conditional logic.\n\n\n\n\n\n\nExercise 1: Temperature Conversion Function\n\n\n\nCreate a function that converts temperatures between Fahrenheit and Celsius scales. This exercise demonstrates how to define and use functions with conditional logic to perform different types of conversions based on user input.\nThe conversion formulas are: - Celsius to Fahrenheit: \\(F = (C \\times 9/5) + 32\\) - Fahrenheit to Celsius: \\(C = (F - 32) \\times 5/9\\)\nTime estimate: 15-20 minutes\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nUse an if-else statement to check the scale parameter. Depending on whether it’s ‘C’ or ‘F’, apply the appropriate conversion formula. Remember to return both the converted temperature value and the new scale designation (either ‘F’ or ‘C’).\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2: Prime Number Checker\n\n\n\nCreate a function that checks whether a given number is prime. This exercise demonstrates the use of loops, conditional statements, and early return to solve a common mathematical problem.\nA prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers.\nTime estimate: 15-20 minutes\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nFirst, check if the number is less than 2 (not prime). Then, use a loop to check if the number is divisible by any integer from 2 to the square root of the number. If you find a divisor, the number is not prime. If no divisors are found, the number is prime.\n\n\n\n\n\n\n\n\n\n\n\nNote",
    "crumbs": [
      "Lecture 2",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Python Overview</span>"
    ]
  }
]