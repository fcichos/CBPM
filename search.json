[
  {
    "objectID": "lectures/lecture01/python_lecture01.html",
    "href": "lectures/lecture01/python_lecture01.html",
    "title": "Python & Anatomy of a Python Program",
    "section": "",
    "text": "Python is a high-level, interpreted programming language known for its readability and simplicity. Created by Guido van Rossum in 1991, it emphasizes code readability with its clear syntax and use of indentation. Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming. It comes with a comprehensive standard library and has a vast ecosystem of third-party packages, making it suitable for various applications such as web development, data analysis, artificial intelligence, scientific computing, and automation. Python’s “batteries included” philosophy and gentle learning curve have contributed to its popularity among beginners and experienced developers alike.\nFor physics students specifically, Python has become the language of choice for data analysis, simulation, and visualization in scientific research. Libraries like NumPy, SciPy, and Matplotlib provide powerful tools for solving physics problems, from basic mechanics to quantum mechanics.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Python & Anatomy of a Program"
    ]
  },
  {
    "objectID": "lectures/lecture01/python_lecture01.html#what-is-python",
    "href": "lectures/lecture01/python_lecture01.html#what-is-python",
    "title": "Python & Anatomy of a Python Program",
    "section": "",
    "text": "Python is a high-level, interpreted programming language known for its readability and simplicity. Created by Guido van Rossum in 1991, it emphasizes code readability with its clear syntax and use of indentation. Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming. It comes with a comprehensive standard library and has a vast ecosystem of third-party packages, making it suitable for various applications such as web development, data analysis, artificial intelligence, scientific computing, and automation. Python’s “batteries included” philosophy and gentle learning curve have contributed to its popularity among beginners and experienced developers alike.\nFor physics students specifically, Python has become the language of choice for data analysis, simulation, and visualization in scientific research. Libraries like NumPy, SciPy, and Matplotlib provide powerful tools for solving physics problems, from basic mechanics to quantum mechanics.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Python & Anatomy of a Program"
    ]
  },
  {
    "objectID": "lectures/lecture01/python_lecture01.html#anatomy-of-a-python-program",
    "href": "lectures/lecture01/python_lecture01.html#anatomy-of-a-python-program",
    "title": "Python & Anatomy of a Python Program",
    "section": "Anatomy of a Python Program",
    "text": "Anatomy of a Python Program\nUnderstanding the basic structure of a Python program is essential for beginners. Let’s break down the fundamental elements that make up a typical Python program.\n\nBasic Elements\n\n\n\n\n\n\n\n\nElement\nDescription\nExample\n\n\n\n\nStatements\nIndividual instructions that Python executes\nx = 10\n\n\nExpressions\nCombinations of values, variables, and operators that evaluate to a value\nx + 5\n\n\nBlocks\nGroups of statements indented at the same level\nFunction bodies, loops\n\n\nFunctions\nReusable blocks of code that perform specific tasks\ndef calculate_area(radius):\n\n\nComments\nNotes in the code that are ignored by the interpreter\n# This is a comment\n\n\nImports\nStatements that give access to external modules\nimport numpy as np\n\n\n\n\n\nVisual Structure of a Python Program\n# 1. Import statements (external libraries)\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint  # For solving differential equations\n\n# 2. Constants and global variables\nGRAVITY = 9.81  # m/s^2\nPLANCK_CONSTANT = 6.626e-34  # J·s\nELECTRON_MASS = 9.109e-31  # kg\n\n# 3. Function definitions\ndef calculate_kinetic_energy(mass, velocity):\n    \"\"\"\n    Calculate the kinetic energy of an object.\n\n    Parameters:\n        mass (float): Mass of the object in kg\n        velocity (float): Velocity of the object in m/s\n\n    Returns:\n        float: Kinetic energy in Joules\n    \"\"\"\n    return 0.5 * mass * velocity**2\n\ndef spring_force(k, displacement):\n    \"\"\"\n    Calculate the force exerted by a spring.\n\n    Parameters:\n        k (float): Spring constant in N/m\n        displacement (float): Displacement from equilibrium in m\n\n    Returns:\n        float: Force in Newtons (negative for restoring force)\n    \"\"\"\n    return -k * displacement\n\n# 4. Class definitions (if applicable)\nclass Particle:\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = position\n        self.velocity = velocity\n\n    def update_position(self, time_step):\n        # Simple Euler integration\n        self.position += self.velocity * time_step\n\n    def potential_energy(self, height, g=GRAVITY):\n        \"\"\"Calculate gravitational potential energy\"\"\"\n        return self.mass * g * height\n\n    def momentum(self):\n        \"\"\"Calculate momentum\"\"\"\n        return self.mass * self.velocity\n\n# 5. Main execution code\nif __name__ == \"__main__\":\n    # Create objects or variables\n    particle = Particle(1.0, np.array([0.0, 0.0]), np.array([1.0, 2.0]))\n\n    # Set up simulation parameters\n    time_step = 0.01  # seconds\n    total_time = 1.0  # seconds\n    n_steps = int(total_time / time_step)\n\n    # Arrays to store results\n    positions = np.zeros((n_steps, 2))\n    times = np.zeros(n_steps)\n\n    # Process data/perform calculations - simulate motion\n    for i in range(n_steps):\n        particle.update_position(time_step)\n        positions[i] = particle.position\n        times[i] = i * time_step\n\n    # Output results\n    print(f\"Final position: {particle.position}\")\n    print(f\"Final kinetic energy: {calculate_kinetic_energy(particle.mass, np.linalg.norm(particle.velocity))} J\")\n\n    # Visualize results (if applicable)\n    plt.figure(figsize=(10, 6))\n    plt.subplot(1, 2, 1)\n    plt.plot(positions[:, 0], positions[:, 1], 'r-')\n    plt.xlabel('X position (m)')\n    plt.ylabel('Y position (m)')\n    plt.title('Particle Trajectory')\n    plt.grid(True)\n\n    plt.subplot(1, 2, 2)\n    plt.plot(times, positions[:, 0], 'b-', label='x-position')\n    plt.plot(times, positions[:, 1], 'g-', label='y-position')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    plt.title('Position vs Time')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n\nKey Concepts\n\nModularity: Python programs are typically organized into functions and classes that encapsulate specific functionality.\nIndentation: Python uses indentation (typically 4 spaces) to define code blocks, unlike other languages that use braces {}.\nDocumentation: Good Python code includes docstrings (triple-quoted strings) that explain what functions and classes do.\nMain Block: The if __name__ == \"__main__\": block ensures code only runs when the file is executed directly, not when imported.\nReadability: Python emphasizes code readability with clear variable names and logical organization.\nPhysics Modeling: For physics problems, we typically model physical systems as objects with properties (mass, position, etc.) and behaviors (update_position, calculate_energy, etc.).\nNumerical Integration: Many physics problems require solving differential equations numerically using methods like Euler integration or Runge-Kutta.\nUnits: Always include appropriate SI units in your comments and documentation to ensure clarity in physics calculations.\n\n\n\n\n\n\n\nBest Practices\n\n\n\n\n\n\nKeep functions short and focused on a single task\nUse meaningful variable and function names\nInclude comments to explain why rather than what (the code should be self-explanatory)\nFollow PEP 8 style guidelines for consistent formatting\nStructure larger programs into multiple modules (files)\nFor physics simulations, validate your code against known analytical solutions when possible\nRemember to handle units consistently throughout your calculations\nConsider the appropriate numerical methods for the physical system you’re modeling\n\n\n\n\n\n\n\n\n\n\nPhysics-Specific Python Libraries\n\n\n\n\n\n\nNumPy: Provides array operations and mathematical functions\nSciPy: Scientific computing tools including optimization, integration, and differential equations\nMatplotlib: Plotting and visualization\nSymPy: Symbolic mathematics for analytical solutions\nPandas: Data manipulation and analysis\nastropy: Astronomy and astrophysics\nscikit-learn: Machine learning for data analysis\nPyMC: Probabilistic programming for statistical analysis",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Python & Anatomy of a Program"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01_reveal.html#variables-in-python",
    "href": "lectures/lecture01/02-lecture01_reveal.html#variables-in-python",
    "title": "Variables & Numbers",
    "section": "Variables in Python",
    "text": "Variables in Python\nSymbol Names\nVariable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\n\nReserved Keywords\n\n\nPython has keywords that cannot be used as variable names. The most common ones you’ll encounter in physics programming are:\nif, else, for, while, return, and, or, lambda\nNote that lambda is particularly relevant as it could naturally appear in physics code, but since it’s reserved for anonymous functions in Python, it cannot be used as a variable name.\n\n\n\n\nVariable Assignment\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n#| autorun: false\n# variable assignments\nx = 1.0\nmy_favorite_variable = 12.2\nx\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n#| autorun: false\ntype(x)\nIf we assign a new value to a variable, its type can change.\n#| autorun: false\nx = 1\n#| autorun: false\ntype(x)\nIf we try to use a variable that has not yet been defined, we get a NameError error.\n#| autorun: false\n#print(g)"
  },
  {
    "objectID": "lectures/lecture01/02-lecture01_reveal.html#number-types",
    "href": "lectures/lecture01/02-lecture01_reveal.html#number-types",
    "title": "Variables & Numbers",
    "section": "Number Types",
    "text": "Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers. These are some of the basic building blocks of doing arithmetic in any programming language. We will discuss each of these types in more detail.\nComparison of Number Types\n\n\n\n\n\n\n\n\n\n\nType\nExample\nDescription\nLimits\nUse Cases\n\n\n\n\nint\n42\nWhole numbers\nUnlimited precision (bounded by available memory)\nCounting, indexing\n\n\nfloat\n3.14159\nDecimal numbers\nTypically ±1.8e308 with 15-17 digits of precision (64-bit)\nScientific calculations, prices\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts\nSame as float for both real and imaginary parts\nSignal processing, electrical engineering\n\n\nbool\nTrue / False\nLogical values\nOnly two values: True (1) and False (0)\nConditional operations, flags\n\n\n\n\n\n\n\n\n\n\nExamples for Number Types\n\n\nIntegers\nInteger Representation: Integers are whole numbers without a decimal point.\n#| autorun: false\nx = 1\ntype(x)\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n#| autorun: false\n0b1010111110  # Binary\n0x0F          # Hexadecimal\nFloating Point Numbers\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n#| autorun: false\nx = 3.141\ntype(x)\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n#| autorun: false\n1.7976931348623157e+308 * 2  # Output: inf\nComplex Numbers\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n#| autorun: false\nc = 2 + 4j\ntype(c)\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n#| autorun: false\nprint(c.real)\nprint(c.imag)\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.\n#| autorun: false\nc = c.conjugate()\nprint(c)"
  },
  {
    "objectID": "lectures/lecture01/02-lecture01_reveal.html#operators",
    "href": "lectures/lecture01/02-lecture01_reveal.html#operators",
    "title": "Variables & Numbers",
    "section": "Operators",
    "text": "Operators\nPython provides a variety of operators for performing operations on variables and values. Here we’ll cover the most common operators used in scientific programming.\nArithmetic Operators\nThese operators perform basic mathematical operations:\n\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n+\nAddition\n5 + 3\n8\n\n\n-\nSubtraction\n5 - 3\n2\n\n\n*\nMultiplication\n5 * 3\n15\n\n\n/\nDivision\n5 / 3\n1.6666…\n\n\n//\nFloor Division\n5 // 3\n1\n\n\n%\nModulus (remainder)\n5 % 3\n2\n\n\n**\nExponentiation\n5 ** 3\n125\n\n\n\n#| autorun: false\n# Examples of arithmetic operators\nprint(f\"Addition: 5 + 3 = {5 + 3}\")\nprint(f\"Division: 5 / 3 = {5 / 3}\")\nprint(f\"Floor Division: 5 // 3 = {5 // 3}\")\nprint(f\"Exponentiation: 5 ** 3 = {5 ** 3}\")\nComparison Operators\nThese operators are used to compare values:\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n==\nEqual to\nx == y\n\n\n!=\nNot equal to\nx != y\n\n\n&gt;\nGreater than\nx &gt; y\n\n\n&lt;\nLess than\nx &lt; y\n\n\n&gt;=\nGreater than or equal to\nx &gt;= y\n\n\n&lt;=\nLess than or equal to\nx &lt;= y\n\n\n\n#| autorun: false\n# Examples of comparison operators\nx, y = 5, 3\nprint(f\"x = {x}, y = {y}\")\nprint(f\"x == y: {x == y}\")\nprint(f\"x &gt; y: {x &gt; y}\")\nprint(f\"x &lt;= y: {x &lt;= y}\")\nLogical Operators\nUsed to combine conditional statements:\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\n\n\n\n\nand\nReturns True if both statements are true\nx &gt; 0 and x &lt; 10\n\n\nor\nReturns True if one of the statements is true\nx &lt; 0 or x &gt; 10\n\n\nnot\nReverses the result, returns False if the result is true\nnot(x &gt; 0 and x &lt; 10)\n\n\n\n#| autorun: false\n# Examples of logical operators\nx = 7\nprint(f\"x = {x}\")\nprint(f\"x &gt; 0 and x &lt; 10: {x &gt; 0 and x &lt; 10}\")\nprint(f\"x &lt; 0 or x &gt; 10: {x &lt; 0 or x &gt; 10}\")\nprint(f\"not(x &gt; 0): {not(x &gt; 0)}\")\nAssignment Operators\nPython provides shorthand operators for updating variables:\n\n\n\nOperator\nExample\nEquivalent to\n\n\n\n\n=\nx = 5\nx = 5\n\n\n+=\nx += 3\nx = x + 3\n\n\n-=\nx -= 3\nx = x - 3\n\n\n*=\nx *= 3\nx = x * 3\n\n\n/=\nx /= 3\nx = x / 3\n\n\n//=\nx //= 3\nx = x // 3\n\n\n%=\nx %= 3\nx = x % 3\n\n\n**=\nx **= 3\nx = x ** 3\n\n\n\n#| autorun: false\n# Examples of assignment operators\nx = 10\nprint(f\"Initial x: {x}\")\n\nx += 5\nprint(f\"After x += 5: {x}\")\n\nx *= 2\nprint(f\"After x *= 2: {x}\")\n\n\n\n\n\n\n\nOperator Precedence\n\n\nPython follows the standard mathematical order of operations (PEMDAS):\n\nParentheses\nExponentiation (**)\nMultiplication and Division (*, /, //, %)\nAddition and Subtraction (+, -)\n\nWhen operators have the same precedence, they are evaluated from left to right.\n#| autorun: false\n# Operator precedence example\nresult = 2 + 3 * 4 ** 2\nprint(f\"2 + 3 * 4 ** 2 = {result}\")  # 2 + 3 * 16 = 2 + 48 = 50\n\n# Using parentheses to change precedence\nresult = (2 + 3) * 4 ** 2\nprint(f\"(2 + 3) * 4 ** 2 = {result}\")  # 5 * 16 = 80"
  },
  {
    "objectID": "lectures/lecture01/00-lecture01.html",
    "href": "lectures/lecture01/00-lecture01.html",
    "title": "Programming Background Questionnaire",
    "section": "",
    "text": "Please complete this short questionnaire to help tailor the course to your needs. Your responses are anonymous and will be used only to adapt the teaching to your level of experience.\n\n  Loading…",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Initial Questions"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html",
    "href": "lectures/lecture02/01-lecture02.html",
    "title": "Data Types",
    "section": "",
    "text": "It’s time to look at different data types we may find useful in our course. Besides the number types mentioned previously, there are also other types like strings, lists, tuples, dictionaries and sets.\nEach of these data types has a number of connected methods (functions) which allow you to manipulate the data contained in a variable. If you want to know which methods are available for a certain object use the command dir, e.g.\nThe output would be:\nThe following few cells will give you a short introduction into each type.",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Data Types"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#data-types",
    "href": "lectures/lecture02/01-lecture02.html#data-types",
    "title": "Data Types",
    "section": "Data Types",
    "text": "Data Types\n\nNumeric TypesStringsListsTuplesDictionariesBooleanSets\n\n\nPython supports several numeric data types including integers, floats, and complex numbers.\n\n\n\n\n\n\nYou can perform various arithmetic operations with numeric types:\n\n\n\n\n\n\nType conversion works between numeric types:\n\n\n\n\n\n\n\n\nStrings are lists of keyboard characters as well as other characters not on your keyboard. They are useful for printing results on the screen, during reading and writing of data.\n\n\n\n\n\n\n\n\n\n\n\n\nString can be concatenated using the + operator.\n\n\n\n\n\n\n\n\n\n\n\n\nAs strings are lists, each character in a string can be accessed by addressing the position in the string (see Lists section)\n\n\n\n\n\n\nStrings can also be made out of numbers.\n\n\n\n\n\n\nIf you want to obtain a number of a string, you can use what is known as type casting. Using type casting you may convert the string or any other data type into a different type if this is possible. To find out if a string is a pure number you may use the str.isnumeric method. For the above string, we may want to do a conversion to the type int by typing:\n\n\n\n\n\n\n\n\n\n\n\n\nThere are a number of methods connected to the string data type. Usually the relate to formatting or finding sub-strings. Formatting will be a topic in our next lecture. Here we just refer to one simple find example.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLists are ordered, mutable collections that can store items of different data types.\n\n\n\n\n\n\nYou can access and modify list elements:\n\n\n\n\n\n\nCommon list methods:\n\n\n\n\n\n\n\n\nTuples are ordered, immutable sequences.\n\n\n\n\n\n\nTuples are immutable, meaning you cannot change their elements after creation:\n\n\n\n\n\n\n\n\nDictionaries store data as key-value pairs. They are mutable and unordered.\n\n\n\n\n\n\nAccessing and modifying dictionary elements:\n\n\n\n\n\n\nCommon dictionary methods:\n\n\n\n\n\n\n\n\nThe Boolean type has only two possible values: True and False.\n\n\n\n\n\n\nBoolean values are commonly used in conditional statements:\n\n\n\n\n\n\nBoolean operations:\n\n\n\n\n\n\n\n\nSets are unordered collections of unique elements.\n\n\n\n\n\n\nCommon set operations:\n\n\n\n\n\n\nAdding and removing elements:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Data Types"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html#quiz-data-types-in-python",
    "href": "lectures/lecture02/01-lecture02.html#quiz-data-types-in-python",
    "title": "Data Types",
    "section": "Quiz: Data Types in Python",
    "text": "Quiz: Data Types in Python\nLet’s test your understanding of Python data types!\n\n\nWhat is the output of the following code?\na = [1, 2, 3]\nb = (1, 2, 3)\nprint(type(a), type(b))\n\n&lt;class 'list'&gt; &lt;class 'list'&gt;\n&lt;class 'list'&gt; &lt;class 'tuple'&gt;\n&lt;class 'tuple'&gt; &lt;class 'list'&gt;\n&lt;class 'tuple'&gt; &lt;class 'tuple'&gt;\n\nWhich of the following is mutable?\n\nList\nTuple\nString\nInteger\n\nWhat will be the output of this code?\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\nprint(my_dict['b'])\n\na\n2\nb\nKeyError\n\nHow do you create an empty set in Python?\n\n{}\n[]\nset()\n()\n\nWhat is the result of 3 + 4.0?\n\n7\n7.0\n‘7.0’\nTypeError\n\n\n\n\n\n\n\n\n\nClick to reveal answers\n\n\n\n\n\n\n&lt;class 'list'&gt; &lt;class 'tuple'&gt;\nList\n2\nset()\n7.0",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Data Types"
    ]
  },
  {
    "objectID": "course-info/assignments.html",
    "href": "course-info/assignments.html",
    "title": "Assignments",
    "section": "",
    "text": "A total of 6 exercise sheets will be provided. The exercise sheets are part of the examination! The exercise sheets are not graded, but completing them is required for the successful completion of the module. More detailed information on the evaluation of the exercise sheets can be found on the Exam page.\n\nProvision and Submission of Exercises\n\nPublication: Every Tuesday at 1:00 PM (starting second week)\nSubmission deadline: By the following Tuesday at 12:00 PM\nProcessing period: One week (minus one hour)\nPlatform: University Moodle\n\nBoth for working on and submitting assignments\n\nImportant:\n\nMake sure to submit on time within the specified deadline.\nAfter the deadline expires, the assignment is no longer available and cannot be submitted.\nPlease note that submitting the same assignment multiple times reduces the score by 10% with each submission\n\n\n\n\nMoodle page with Assignments\n\n\n\nMoodle Link",
    "crumbs": [
      "Course Info",
      "Assignments"
    ]
  },
  {
    "objectID": "course-info/exam.html",
    "href": "course-info/exam.html",
    "title": "Exams",
    "section": "",
    "text": "The examination in this case consists of the following parts:\n\nExercises:\n\n6 series of assignments that are not graded\nAt least 50% of the total points for all assignments must be achieved.\n\nTwo Tests:\n\nEach test lasts 45 minutes.\nThe test will take place in person.\nThe tests will be announced in advance.\nThe scores from both tests are added together to give an overall grade.\n\n\nBoth parts (exercises and tests) must be passed to successfully complete the module.",
    "crumbs": [
      "Course Info",
      "Exams"
    ]
  },
  {
    "objectID": "course-info/exam.html#first-time-participants",
    "href": "course-info/exam.html#first-time-participants",
    "title": "Exams",
    "section": "",
    "text": "The examination in this case consists of the following parts:\n\nExercises:\n\n6 series of assignments that are not graded\nAt least 50% of the total points for all assignments must be achieved.\n\nTwo Tests:\n\nEach test lasts 45 minutes.\nThe test will take place in person.\nThe tests will be announced in advance.\nThe scores from both tests are added together to give an overall grade.\n\n\nBoth parts (exercises and tests) must be passed to successfully complete the module.",
    "crumbs": [
      "Course Info",
      "Exams"
    ]
  },
  {
    "objectID": "course-info/exam.html#students-that-already-did-the-module",
    "href": "course-info/exam.html#students-that-already-did-the-module",
    "title": "Exams",
    "section": "Students that already did the module",
    "text": "Students that already did the module\n\nStudents that did the module in SS 2024: The examination consists of exercises and project submission.\n\nIf you have achieved ≥ 50% in the summer semester 2024: Only project submission required\nIf you have achieved &lt; 50% in the summer semester 2024: Exercises and project submission required\n\nStudents that did the module in SS 2023: The examination consists of the submission of a project and a 5-minute video about your project instead of the exercises.\nEnrollment:\n\nNew registration for the module not necessary when you are repeating the module.\nFor Moodle access: Contact Andrea Kramer (firstname.surname@uni-leipzig.de) via university email.\n\nProject Submission:\n\nDeadline: September 3, 2025, 1:00 pm sharp.\nLater Submissions will not be considered.",
    "crumbs": [
      "Course Info",
      "Exams"
    ]
  },
  {
    "objectID": "course-info/website.html",
    "href": "course-info/website.html",
    "title": "Webpages",
    "section": "",
    "text": "These Webpages\nThis website contains all the information required for our course Computer Based Physical Modelling. You will find a new lecture and a new assignment here each week. The lecture notes are accompanied by videos that explain the content of the lecture in English, but you can also get by with just reading. From these web pages, you will be guided to various resources that you can use to learn programming in Python. We will use some great tools from the internet, such as:\n\nGoogle Colab service, to host Jupyter Notebooks (https://colab.research.google.com). The Google Colab project provides a useful environment for sharing notebooks.\n\n\n\ngoogle colab screen\n\n\nWhile we don’t use direct Colab links in this course, you can use this service on your own to work with the Jupyter Notebooks. Google Colab provides a free, cloud-based environment that allows you to run Python code without installing anything on your local machine. If you prefer to use Colab, you can upload the notebook files to your Google Drive and open them with Colab.\nGitHub and GitHub Pages service for hosting websites (https://github.com). GitHub is a great place to host your collaborative coding projects including version control. In the upper right corner, you will also find a link to the GitHub repository where the notebooks are hosted.\n\n\n\ngithub screen\n\n\nAnaconda Jupyter package for notebooks on your own computer (https://www.anaconda.com/distribution/). The anaconda package provides you with the Jupyter Notebook environment including Python. If you want to use Jupyter at home without online access, this is a good package to install.\n\n\n\nanaconda screen"
  },
  {
    "objectID": "course-info/intructors.html",
    "href": "course-info/intructors.html",
    "title": "Instructor",
    "section": "",
    "text": "Linnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +49 341 97 32571\nEmail: lastname@physik.uni-leipzig.de",
    "crumbs": [
      "Course Info",
      "Instructor"
    ]
  },
  {
    "objectID": "course-info/intructors.html#prof.-dr.-frank-cichos",
    "href": "course-info/intructors.html#prof.-dr.-frank-cichos",
    "title": "Instructor",
    "section": "",
    "text": "Linnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +49 341 97 32571\nEmail: lastname@physik.uni-leipzig.de",
    "crumbs": [
      "Course Info",
      "Instructor"
    ]
  },
  {
    "objectID": "seminars/seminar01/md1.html",
    "href": "seminars/seminar01/md1.html",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "Real molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\nBefore we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation."
  },
  {
    "objectID": "seminars/seminar01/md1.html#molecular-dynamics-simulations",
    "href": "seminars/seminar01/md1.html#molecular-dynamics-simulations",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "",
    "text": "Real molecular dynamics (MD) simulations are complex and computationally expensive but very cool, as they give you a glimpse into the world of atoms and molecules. Here, we will develop a simple MD simulation from scratch in Python. The goal is to understand the basic concepts and algorithms behind MD simulations and get something running which can be extended later but also what we are proud of at the end of the course.\nBefore we can start with implementing a simulation, we need to understand the basic concepts and algorithms behind MD simulations. The following sections will guide you through the development of a simple MD simulation."
  },
  {
    "objectID": "seminars/seminar01/md1.html#basic-physical-concepts",
    "href": "seminars/seminar01/md1.html#basic-physical-concepts",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "Basic Physical Concepts",
    "text": "Basic Physical Concepts\n\nNewton’s Equations of Motion\nThe motion of particles in a molecular dynamics simulation is governed by Newton’s equations of motion:\n\\[m_i \\frac{d^2\\vec{r}_i}{dt^2} = \\vec{F}_i\\]\nwhere:\n\n\\(m_i\\) is the mass of particle \\(i\\)\n\\(\\vec{r}_i\\) is the position of particle \\(i\\)\n\\(\\vec{F}_i\\) is the force acting on particle \\(i\\)\n\nThe force acting on a particle is the sum of all forces acting on it:\n\\[\\vec{F}_i = \\sum_{j \\neq i} \\vec{F}_{ij}\\]\nwhere \\(\\vec{F}_{ij}\\) is the force acting on particle \\(i\\) due to particle \\(j\\).\n\n\nPotential Energy Functions and Forces\nThe force \\(\\vec{F}_{ij}\\) is usually derived from a potential energy function and may result from a variety of interactions, such as:\n\nBonded interactions\n\nbond stretching \nbond angle bending \ntorsional interactions \n\nNon-bonded interactions\n\nelectrostatic interactions\nvan der Waals interactions\n\nExternal forces\n\nWe will implement some of them but not all of them.\n\nLennard-Jones Potential\nThe most common potential energy function used in MD simulations is the Lennard-Jones potential. It is belonging to the class of non-bonded interactions. The force and the potential energy of the Lennard-Jones potential are given by:\n\\[V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]\nand\n\\[F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}\\]\nwhere:\n\n\\(\\epsilon\\) is the depth of the potential well\n\\(\\sigma\\) is the distance at which the potential is zero\n\\(r\\) is the distance between particles\n\nThe Lenard Jones potential is good for describing the interaction of non-bonded atoms in a molecular system e.g. in a gas or a liquid and is therefore well suited if we first want to simulate a gas or a liquid.\n\n\nCode\ndef lennard_jones(r, epsilon=1, sigma=1):\n    return 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)\n\nr = np.linspace(0.8, 3, 1000)\nV = lennard_jones(r)\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(r, V, 'b-', linewidth=2)\nplt.grid(True)\nplt.xlabel('r/σ')\nplt.ylabel('V/ε')\nplt.title('Lennard-Jones Potential')\nplt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\nplt.ylim(-1.5, 3)\nplt.show()\n\n\n\n\n\n\n\n\n\nThe figure above shows the Lenard-Jones potential as a function of the distance between particles. The potential energy is zero at the equilibrium distance \\(r = \\sigma\\) and has a minimum at \\(r = 2^{1/6}\\sigma\\). The potential energy is positive for \\(r &lt; \\sigma\\) and negative for \\(r &gt; \\sigma\\).\n\n\n\n\n\n\nValues for atomic hydrogen\n\n\n\nFor atomic hydrogen (H), typical Lennard-Jones parameters are:\n\n\\(\\sigma \\approx 2.38\\) Å = \\(2.38 \\times 10^{-10}\\) meters\n\\(\\epsilon \\approx 0.0167\\) kcal/mol = \\(1.16 \\times 10^{-21}\\) joules\n\n\n\nLater, if we manage to advance to some more complicated systems, we may want to introduce:\n\nforce in bonds between two atoms\nforce in bond angles between three atoms\nforce in dihedral angles between four atoms\n\nBut for now, we will stick to the Lennard-Jones potential."
  },
  {
    "objectID": "seminars/seminar01/md1.html#integrating-newtons-euqation-of-motion",
    "href": "seminars/seminar01/md1.html#integrating-newtons-euqation-of-motion",
    "title": "Step-by-Step Development of a Molecular Dynamics Simulation",
    "section": "Integrating Newtons Euqation of Motion",
    "text": "Integrating Newtons Euqation of Motion\nWhen we have the forces on a particle we have in principle its acceleration. To get the velocity and the position of the particle we need to integrate the equations of motion. There are several methods to do this, but we will start with the simplest one, the Euler method.\n\nEuler Method\nTo obtain this one first needs to know about the Taylor expansion of a function in general. The Taylor expansion of a function \\(f(x)\\) around a point \\(x_0\\) is providing an approximation of the function in the vicinity of \\(x_0\\). It is given by:\n\\[f(x) = f(x_0) + f'(x_0)(x - x_0) + \\frac{1}{2}f''(x_0)(x - x_0)^2 + \\cdots\\]\nwhere \\(f'(x_0)\\) is the first derivative of \\(f(x)\\) at \\(x_0\\), \\(f''(x_0)\\) is the second derivative of \\(f(x)\\) at \\(x_0\\), and so on. We can demonstrate that by expanding a sine function around \\(x_0 = 0\\):\n\\[\\sin(x) = \\sin(0) + \\cos(0)x - \\frac{1}{2}\\sin(0)x^2 + \\cdots = x - \\frac{1}{6}x^3 + \\cdots\\]\nPlotting this yields:\n\n\nCode\nx = np.linspace(-2*np.pi, 2*np.pi, 1000)\ny = np.sin(x)\ny_taylor = x - 1/6*x**3\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(x, y, 'b-', label='sin(x)', linewidth=2)\nplt.plot(x, y_taylor, 'r--', label='Taylor expansion', linewidth=2)\nplt.grid(True)\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.xlim(-2,2)\nplt.ylim(-2,2)\nplt.title('Taylor Expansion of sin(x)')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nThe expansion is therefore a good approximation in a region close to \\(x_0\\).\n\n\nVelocity Verlet Algorithm\nThe velocity Verlet algorithm is a second-order algorithm that is more accurate than the Euler method. It can be derived from the Taylor expansion of the position and velocity vectors\n\\[\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2+ O(\\Delta t^3)\\]\nThe higher order terms in the Taylor expansion are neglected, which results in an error of order \\(\\Delta t^3\\). As compared to that the Euler method is obtained by neglecting the higher order terms in the Taylor expansion of the velocity vector:\n\\[\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m}\\Delta t + O(\\Delta t^2)\\]\nand is therefore only first order accurate with an error of order \\(\\Delta t^2\\).\nThe velocity Verlet algorithm consists of three steps:\n\nUpdate positions: \\(\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\frac{\\mathbf{F}(t)}{m}\\Delta t^2\\)\nCalculate new forces: \\(\\mathbf{F}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))\\)\nUpdate velocities: \\(\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\frac{\\mathbf{F}(t) + \\mathbf{F}(t + \\Delta t)}{m}\\Delta t\\)\n\nwhere: - \\(\\mathbf{r}\\) is the position vector - \\(\\mathbf{v}\\) is the velocity vector - \\(\\mathbf{F}\\) is the force vector - \\(m\\) is the mass - \\(\\Delta t\\) is the timestep\n\n\nSimple Integration Example: Free Fall\nLet’s start and try to integrate the equation of motion for a particle in free fall with the help of the Velocity Verlet algorithm. The only force acting on the particle is gravity. The equation of motion is:\nNewton’s equation of motion: \\(\\mathbf{F} = m\\mathbf{a}\\)\nFor gravity: \\(\\mathbf{F} = -mg\\hat{\\mathbf{y}}\\)\nTherefore: \\(\\ddot{y} = -g\\)\nThe analytical solution is:\n\nPosition: \\(y(t) = y_0 + v_0t - \\frac{1}{2}gt^2\\)\nVelocity: \\(v(t) = v_0 - gt\\)\n\n\n\nCode\n# Parameters\n\ng = 9.81  # m/s^2\ndt = 0.01  # time step\nt_max = 2.0  # total simulation time\nsteps = int(t_max/dt)\n\n# Initial conditions\ny0 = 20.0  # initial height\nv0 = 0.0   # initial velocity\n\n\n# Arrays to store results\nt = np.zeros(steps)\ny = np.zeros(steps)\nv = np.zeros(steps)\na = np.zeros(steps)\n\n# Initial values\ny[0] = y0\nv[0] = v0\na[0] = -g\n\n# Velocity Verlet integration\nfor i in range(1, steps):\n    t[i] = i * dt\n    y[i] = y[i-1] + v[i-1] * dt + 0.5 * a[i-1] * dt**2  # update position\n    a_new = -g                                          # new acceleration (assuming constant gravity)\n    v[i] = v[i-1] + 0.5 * (a[i-1] + a_new) * dt         # update velocity\n    a[i] = a_new                                        # store new acceleration\n\ny_analytical = y0 + v0*t - 0.5*g*t**2\nplt.figure(figsize=get_size(8, 6), dpi=150)\nplt.plot(t, y)\nplt.plot(t, y_analytical, 'r--')\n\nplt.xlabel('Time (s)')\nplt.ylabel('Height (m)')\nplt.title('Free Fall Motion')\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "seminars/seminar01/01-seminar01.html",
    "href": "seminars/seminar01/01-seminar01.html",
    "title": "Seminar 1",
    "section": "",
    "text": "Calculate the average of all of the integers from 1 to 10.\n\n\n\n\n\n\n\nuse the sum() and len() functions\nn = range(1, 11)\n\n\n1n = range(1, 11)\n2sum(n)/len(n)\n\n1\n\ncreate the range of numbers from 1 to 10.\n\n2\n\ncalculate the sum of the numbers and divide by the number of elements in the list."
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html",
    "href": "seminars/seminar01/MDSimulation.html",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nplt.rcParams.update({'font.size': 8,\n                     'lines.linewidth': 1,\n                     'lines.markersize': 10,\n                     'axes.labelsize': 10,\n                     'axes.titlesize': 10,\n                     'xtick.labelsize' : 10,\n                     'ytick.labelsize' : 10,\n                     'xtick.top' : True,\n                     'xtick.direction' : 'in',\n                     'ytick.right' : True,\n                     'ytick.direction' : 'in',})\n\ndef get_size(w,h):\n    return((w/2.54,h/2.54))"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html#lenard-jones-potential",
    "href": "seminars/seminar01/MDSimulation.html#lenard-jones-potential",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Lenard-Jones Potential",
    "text": "Lenard-Jones Potential\n\ndef lennard_jones(r, epsilon=1, sigma=1):\n    return 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)\n\nr = np.linspace(0.8, 3, 1000)\nV = lennard_jones(r)\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(r, V, 'b-', linewidth=2)\nplt.grid(True)\nplt.xlabel('r/σ')\nplt.ylabel('V/ε')\nplt.title('Lennard-Jones Potential')\nplt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\nplt.ylim(-1.5, 3)\nplt.show()"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html#taylor-expansion",
    "href": "seminars/seminar01/MDSimulation.html#taylor-expansion",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Taylor Expansion",
    "text": "Taylor Expansion\n\nx = np.linspace(-2*np.pi, 2*np.pi, 1000)\ny = np.sin(x)\ny_taylor = x - 1/6*x**3\ny_taylor1 = x - 1/6*x**3+x**5/120\n\n\nplt.figure(figsize=get_size(8, 6),dpi=150)\nplt.plot(x, y, 'b-', label='sin(x)', linewidth=2)\nplt.plot(x, y_taylor, 'r--', label='O(5)', linewidth=2)\nplt.plot(x, y_taylor1, 'g--', label='O(7)', linewidth=2)\nplt.grid(True)\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.xlim(-2,2)\nplt.ylim(-1.3,1.3)\nplt.title('Taylor Expansion of sin(x)')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html#velocity-verlet",
    "href": "seminars/seminar01/MDSimulation.html#velocity-verlet",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Velocity Verlet",
    "text": "Velocity Verlet\n\ng = 9.81  # m/s^2\ndt = 0.01  # time step\nt_max = 2.0  # total simulation time\nsteps = int(t_max/dt)\n\n# Initial conditions\ny0 = 20.0  # initial height\nv0 = 0.0   # initial velocity\n\n\n# Arrays to store results\nt = np.zeros(steps)\ny = np.zeros(steps)\nv = np.zeros(steps)\na = np.zeros(steps)\n\n# Initial values\ny[0] = y0\nv[0] = v0\na[0] = -g\n\n# Velocity Verlet integration\nfor i in range(1, steps):\n    t[i] = i * dt\n    y[i] = y[i-1] + v[i-1] * dt + 0.5 * a[i-1] * dt**2  # update position\n    a_new = -g                                          # new acceleration (assuming constant gravity)\n    v[i] = v[i-1] + 0.5 * (a[i-1] + a_new) * dt  # update velocity\n    a[i] = a_new  # store new acceleration\n\nplt.figure(figsize=get_size(8, 6), dpi=150)\nplt.plot(t, y)\nplt.xlabel('Time (s)')\nplt.ylabel('Height (m)')\nplt.title('Free Fall Motion')\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "seminars/seminar01/MDSimulation.html#class-for-an-atom",
    "href": "seminars/seminar01/MDSimulation.html#class-for-an-atom",
    "title": "Molecular Dynamics Simulations in EMPP 2024",
    "section": "Class for an Atom",
    "text": "Class for an Atom"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CBPM 2025",
    "section": "",
    "text": "Welcome to the Course Computer-Based Physical Modelling!\nThe programming language Python is useful for all kinds of scientific and technical tasks. You can use it to analyze and visualize data. You can also use it to numerically solve scientific problems that are difficult or impossible to solve analytically. Python is freely available and, due to its modular structure, has been expanded with an almost infinite number of modules for various purposes.\nThis course aims to introduce you to programming with Python. It is primarily aimed at beginners, but we hope it will also be interesting for advanced users. We begin the course with an introduction to the Jupyter Notebook environment, which we will use throughout the entire course. Afterward, we will provide an introduction to Python and show you some basic functions, such as plotting and analyzing data through curve fitting, reading and writing files, which are some of the tasks you will encounter during your physics studies. We will also show you some advanced topics such as animation in Jupyter and the simulation of physical processes in\n\nMechanics\nElectrostatics\nWaves\nOptics\n\nIf there is time left at the end of the course, we will also take a look at machine learning methods, which have become an important tool in physics as well.\nWe will not present a comprehensive list of numerical simulation schemes, but rather use the examples to spark your curiosity. Since there are slight differences in the syntax of the various Python versions, we will always refer to the Python 3 standard in the following.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "seminars/seminar01/mdX.html",
    "href": "seminars/seminar01/mdX.html",
    "title": "Computer-Based Physical Modelling",
    "section": "",
    "text": "The Lennard-Jones potential describes the interaction between two atoms:\n\\[V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]\nThe corresponding force:\n\\[F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}\\]\nwhere: - \\(\\epsilon\\) is the depth of the potential well - \\(\\sigma\\) is the distance at which the potential is zero - \\(r\\) is the distance between particles\n\n\n\nimport numpy as np\n\ndef lennard_jones_force(pos1, pos2, epsilon=1.0, sigma=1.0):\n    r_vec = pos2 - pos1\n    r = np.linalg.norm(r_vec)\n\n    # Force magnitude\n    force_mag = 24 * epsilon * (2 * (sigma/r)**12 - (sigma/r)**6) / r\n\n    # Force vector\n    force_vec = force_mag * r_vec / r\n\n    return force_vec"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#simple-atomic-system-with-lennard-jones-potential",
    "href": "seminars/seminar01/mdX.html#simple-atomic-system-with-lennard-jones-potential",
    "title": "Computer-Based Physical Modelling",
    "section": "",
    "text": "The Lennard-Jones potential describes the interaction between two atoms:\n\\[V_{LJ}(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]\nThe corresponding force:\n\\[F_{LJ}(r) = -\\frac{dV_{LJ}}{dr} = 24\\epsilon \\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\vec{r}}{r^2}\\]\nwhere: - \\(\\epsilon\\) is the depth of the potential well - \\(\\sigma\\) is the distance at which the potential is zero - \\(r\\) is the distance between particles\n\n\n\nimport numpy as np\n\ndef lennard_jones_force(pos1, pos2, epsilon=1.0, sigma=1.0):\n    r_vec = pos2 - pos1\n    r = np.linalg.norm(r_vec)\n\n    # Force magnitude\n    force_mag = 24 * epsilon * (2 * (sigma/r)**12 - (sigma/r)**6) / r\n\n    # Force vector\n    force_vec = force_mag * r_vec / r\n\n    return force_vec"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#boundary-conditions",
    "href": "seminars/seminar01/mdX.html#boundary-conditions",
    "title": "Computer-Based Physical Modelling",
    "section": "2. Boundary Conditions",
    "text": "2. Boundary Conditions\n\n2.1 Periodic Boundary Conditions (PBC)\nParticles that exit one side of the box re-enter from the opposite side.\ndef apply_periodic_bc(positions, box_length):\n    return positions - box_length * np.floor(positions/box_length)\n\ndef minimum_image_distance(pos1, pos2, box_length):\n    dr = pos2 - pos1\n    dr = dr - box_length * np.round(dr/box_length)\n    return dr\n\n\n2.2 Reflective Boundaries\nParticles bounce off the walls:\ndef apply_reflective_bc(positions, velocities, box_length):\n    for i in range(len(positions)):\n        for dim in range(3):\n            if positions[i,dim] &lt; 0:\n                positions[i,dim] = -positions[i,dim]\n                velocities[i,dim] = -velocities[i,dim]\n            elif positions[i,dim] &gt; box_length:\n                positions[i,dim] = 2*box_length - positions[i,dim]\n                velocities[i,dim] = -velocities[i,dim]\n    return positions, velocities"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#basic-simulation-loop",
    "href": "seminars/seminar01/mdX.html#basic-simulation-loop",
    "title": "Computer-Based Physical Modelling",
    "section": "3. Basic Simulation Loop",
    "text": "3. Basic Simulation Loop\n\n3.1 Initial Implementation with Just LJ Forces\nclass MDSimulation:\n    def __init__(self, positions, velocities, mass, box_length, dt):\n        self.positions = positions\n        self.velocities = velocities\n        self.mass = mass\n        self.box_length = box_length\n        self.dt = dt\n\n    def calculate_forces(self):\n        n_particles = len(self.positions)\n        forces = np.zeros_like(self.positions)\n\n        for i in range(n_particles):\n            for j in range(i+1, n_particles):\n                r_ij = minimum_image_distance(\n                    self.positions[i],\n                    self.positions[j],\n                    self.box_length\n                )\n                f_ij = lennard_jones_force(np.zeros(3), r_ij)\n                forces[i] += f_ij\n                forces[j] -= f_ij  # Newton's third law\n\n        return forces\n\n    def velocity_verlet_step(self):\n        # Calculate initial forces\n        forces = self.calculate_forces()\n\n        # Update positions\n        self.positions += self.velocities * self.dt + \\\n                         0.5 * forces / self.mass * self.dt**2\n\n        # Apply boundary conditions\n        self.positions = apply_periodic_bc(self.positions, self.box_length)\n\n        # Calculate new forces\n        new_forces = self.calculate_forces()\n\n        # Update velocities\n        self.velocities += 0.5 * (forces + new_forces) / self.mass * self.dt"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#adding-molecular-forces",
    "href": "seminars/seminar01/mdX.html#adding-molecular-forces",
    "title": "Computer-Based Physical Modelling",
    "section": "4. Adding Molecular Forces",
    "text": "4. Adding Molecular Forces\n\n4.1 Bond Forces\nAdding harmonic bond potential:\n\\[V_{bond}(r) = \\frac{k}{2}(r - r_0)^2\\]\ndef bond_force(pos1, pos2, k_bond, r0):\n    r_vec = pos2 - pos1\n    r = np.linalg.norm(r_vec)\n    force_mag = -k_bond * (r - r0)\n    return force_mag * r_vec / r\n\n\n4.2 Angle Forces\nThree-body angle potential:\n\\[V_{angle}(\\theta) = \\frac{k_\\theta}{2}(\\theta - \\theta_0)^2\\]\ndef angle_force(pos1, pos2, pos3, k_angle, theta0):\n    # Calculate vectors\n    v1 = pos1 - pos2\n    v2 = pos3 - pos2\n\n    # Calculate angle\n    cos_theta = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n    theta = np.arccos(np.clip(cos_theta, -1.0, 1.0))\n\n    # Calculate forces (simplified version)\n    force_magnitude = -k_angle * (theta - theta0)\n\n    return force_magnitude * v1, -force_magnitude * v2\n\n\n4.3 Enhanced Simulation Class\nclass MolecularMDSimulation(MDSimulation):\n    def __init__(self, *args, bonds=None, angles=None):\n        super().__init__(*args)\n        self.bonds = bonds or []  # [(i, j, k, r0), ...]\n        self.angles = angles or []  # [(i, j, k, k_angle, theta0), ...]\n\n    def calculate_forces(self):\n        # Start with non-bonded forces\n        forces = super().calculate_forces()\n\n        # Add bond forces\n        for bond in self.bonds:\n            i, j, k_bond, r0 = bond\n            f_ij = bond_force(\n                self.positions[i],\n                self.positions[j],\n                k_bond, r0\n            )\n            forces[i] += f_ij\n            forces[j] -= f_ij\n\n        # Add angle forces\n        for angle in self.angles:\n            i, j, k, k_angle, theta0 = angle\n            f_i, f_k = angle_force(\n                self.positions[i],\n                self.positions[j],\n                self.positions[k],\n                k_angle, theta0\n            )\n            forces[i] += f_i\n            forces[k] += f_k\n            forces[j] -= (f_i + f_k)\n\n        return forces"
  },
  {
    "objectID": "seminars/seminar01/mdX.html#example-usage",
    "href": "seminars/seminar01/mdX.html#example-usage",
    "title": "Computer-Based Physical Modelling",
    "section": "5. Example Usage",
    "text": "5. Example Usage\n# Initialize system\nn_particles = 100\nbox_length = 10.0\npositions = np.random.rand(n_particles, 3) * box_length\nvelocities = np.zeros((n_particles, 3))\nmass = 1.0\ndt = 0.001\n\n# Create simulation\nsim = MolecularMDSimulation(\n    positions, velocities, mass, box_length, dt,\n    bonds=[(0, 1, 1000.0, 1.0)],  # Example bond\n    angles=[(0, 1, 2, 100.0, np.pi)]  # Example angle\n)\n\n# Run simulation\nn_steps = 1000\nfor step in range(n_steps):\n    sim.velocity_verlet_step()\nHere’s a suggested basic structure:\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id          # unique identifier\n        self.type = atom_type      # e.g., 'H', 'C', 'O'\n        self.position = position   # numpy array [x, y, z]\n        self.velocity = velocity if velocity is not None else np.zeros(3)\n        self.mass = mass\n        self.force = np.zeros(3)   # current force on atom\n\n        # Optional attributes that might be useful later:\n        self.bonded_atoms = []     # list of atoms this atom is bonded to\n        self.charges = 0.0         # for electrostatic interactions\nThen you can later create classes for: 1. Bond (connects two Atom objects)\nclass Bond:\n    def __init__(self, atom1, atom2, k, r0):\n        self.atom1 = atom1\n        self.atom2 = atom2\n        self.k = k      # force constant\n        self.r0 = r0    # equilibrium distance\n\nAngle (three Atom objects)\n\nclass Angle:\n    def __init__(self, atom1, atom2, atom3, k, theta0):\n        self.atoms = [atom1, atom2, atom3]\n        self.k = k          # force constant\n        self.theta0 = theta0  # equilibrium angle\n\nDihedral (four Atom objects)\n\nThis modular approach makes it easier to: - Add features incrementally - Debug each interaction type separately - Keep track of connectivity - Calculate forces systematically\nclass Atom:\n    def __init__(self, atom_id, atom_type, position, velocity=None, mass=None):\n        self.id = atom_id\n        self.type = atom_type\n        self.position = position\n        self.velocity = velocity if velocity is not None else np.zeros(3)\n        self.mass = mass\n        self.force = np.zeros(3)\n\n    def add_force(self, force):\n        \"\"\"Add force contribution to total force on atom\"\"\"\n        self.force += force\n\n    def reset_force(self):\n        \"\"\"Reset force to zero at start of each step\"\"\"\n        self.force = np.zeros(3)\n\n    def update_position(self, dt):\n        \"\"\"First step of velocity Verlet: update position\"\"\"\n        self.position += self.velocity * dt + 0.5 * (self.force/self.mass) * dt**2\n\n    def update_velocity(self, dt, new_force):\n        \"\"\"Second step of velocity Verlet: update velocity using average force\"\"\"\n        self.velocity += 0.5 * (new_force + self.force)/self.mass * dt\n        self.force = new_force\n\nclass ForceField:\n    def __init__(self, sigma, epsilon):\n        self.sigma = sigma\n        self.epsilon = epsilon\n\n    def calculate_lj_force(self, atom1, atom2):\n        \"\"\"Calculate LJ force between two atoms\"\"\"\n        r = atom1.position - atom2.position\n        r_mag = np.linalg.norm(r)\n        # LJ force calculation\n        force = 24 * self.epsilon * (2 * (self.sigma/r_mag)**12\n                                   - (self.sigma/r_mag)**6) * r/r_mag**2\n        return force\n\nclass MDSimulation:\n    def __init__(self, atoms, forcefield):\n        self.atoms = atoms\n        self.forcefield = forcefield\n\n    def calculate_forces(self):\n        # Reset all forces\n        for atom in self.atoms:\n            atom.reset_force()\n\n        # Calculate forces between all pairs\n        for i, atom1 in enumerate(self.atoms):\n            for atom2 in self.atoms[i+1:]:\n                force = self.forcefield.calculate_lj_force(atom1, atom2)\n                atom1.add_force(force)\n                atom2.add_force(-force)  # Newton's third law\n\nNew lecture\nclass Atom: def init(self, atom_id, atom_type, position, velocity=None, mass=None): self.id = atom_id self.type = atom_type # e.g., ‘A’, ‘B’, etc. self.position = position self.velocity = velocity if velocity is not None else np.zeros(2) self.mass = mass self.force = np.zeros(2)\nclass ForceField: def init(self): # Dictionary to store interaction parameters between atom types self.pair_parameters = {}\ndef add_pair_parameters(self, type1, type2, epsilon, sigma):\n    \"\"\"Add interaction parameters for a pair of atom types\"\"\"\n    # Store parameters symmetrically\n    key = tuple(sorted([type1, type2]))\n    self.pair_parameters[key] = {'epsilon': epsilon, 'sigma': sigma}\n\ndef get_pair_parameters(self, type1, type2):\n    \"\"\"Get interaction parameters for a pair of atom types\"\"\"\n    key = tuple(sorted([type1, type2]))\n    if key not in self.pair_parameters:\n        raise ValueError(f\"No parameters defined for atom types {type1} and {type2}\")\n    return self.pair_parameters[key]\n\ndef calculate_lj_force(self, atom1, atom2, r_vec, r_mag):\n    \"\"\"Calculate LJ force with type-specific parameters\"\"\"\n    params = self.get_pair_parameters(atom1.type, atom2.type)\n    epsilon = params['epsilon']\n    sigma = params['sigma']\n\n    force_mag = 24.0 * epsilon * (2.0 * (sigma/r_mag)**13\n                                - (sigma/r_mag)**7)\n    return force_mag * r_vec / r_mag\n\n\n\n\n    def setup_simulation():\n        # Create force field and add parameters\n        ff = ForceField()\n\n        # Add parameters for different combinations\n        ff.add_pair_parameters('A', 'A', epsilon=1.0, sigma=1.0)  # A-A interaction\n        ff.add_pair_parameters('B', 'B', epsilon=0.5, sigma=1.2)  # B-B interaction\n        ff.add_pair_parameters('A', 'B', epsilon=0.7, sigma=1.1)  # A-B interaction\n\n        # Create atoms of different types\n        atoms = [\n            Atom(0, 'A', np.array([1.0, 1.0]), mass=1.0),\n            Atom(1, 'A', np.array([2.0, 2.0]), mass=1.0),\n            Atom(2, 'B', np.array([3.0, 3.0]), mass=1.5),\n            Atom(3, 'B', np.array([4.0, 4.0]), mass=1.5)\n        ]\n\n        return ff, atoms"
  },
  {
    "objectID": "course-info/resources.html",
    "href": "course-info/resources.html",
    "title": "Resources",
    "section": "",
    "text": "Above all else, it is important for this course that you have internet access during the lectures. We will conduct many examples and exercises that refer to online resources.\nWithin the university, the Eduroam networks can be used. You can find the necessary profile data here.\nFurthermore, there are many other well-structured resources about Python available online. Below you will find only a very small selection.",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/resources.html#molecular-nanophotonics-group",
    "href": "course-info/resources.html#molecular-nanophotonics-group",
    "title": "Resources",
    "section": "Molecular Nanophotonics Group",
    "text": "Molecular Nanophotonics Group\n\nMolecular Nanophotonics Group Website",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/resources.html#additional-advanced-courses",
    "href": "course-info/resources.html#additional-advanced-courses",
    "title": "Resources",
    "section": "Additional Advanced Courses",
    "text": "Additional Advanced Courses\n\nRosenow Group (Theory), Master Course on Statistical Mechanics of Deep Learning",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/resources.html#python-documentation",
    "href": "course-info/resources.html#python-documentation",
    "title": "Resources",
    "section": "Python Documentation",
    "text": "Python Documentation\n\nPython\nMatplotlib\nPandas",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/resources.html#python-tutorials",
    "href": "course-info/resources.html#python-tutorials",
    "title": "Resources",
    "section": "Python Tutorials",
    "text": "Python Tutorials\n\nIntroduction to Python for Science\nNice MatPlotLib tutorial",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/resources.html#further-reading",
    "href": "course-info/resources.html#further-reading",
    "title": "Resources",
    "section": "Further Reading",
    "text": "Further Reading\n\nPython Official Documentation on Functions\nReal Python: Python Loops and Iterators\nPython Conditional Statements\n\nFor interactive practice:\n\nCodecademy Python Course\nHackerRank Python Practice",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/resources.html#marimo-reactive-notebook",
    "href": "course-info/resources.html#marimo-reactive-notebook",
    "title": "Resources",
    "section": "Marimo Reactive Notebook",
    "text": "Marimo Reactive Notebook\n\nMarimo Webpage",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/resources.html#julia-tutorial",
    "href": "course-info/resources.html#julia-tutorial",
    "title": "Resources",
    "section": "Julia Tutorial",
    "text": "Julia Tutorial\n\nJulia Programming Language",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/resources.html#pluto-notebook",
    "href": "course-info/resources.html#pluto-notebook",
    "title": "Resources",
    "section": "Pluto NoteBook",
    "text": "Pluto NoteBook\n\nPluto GitHub Webpage",
    "crumbs": [
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "course-info/how_to_quiz.html",
    "href": "course-info/how_to_quiz.html",
    "title": "Interactive Python Quiz",
    "section": "",
    "text": "In this quiz, you can write and execute Python code directly in your browser.\n\n\nWrite a function square(n) that returns the square of a number.\n\n\n\n\n\n# Write your Python code here\ndef square(n):\n    return n * n\n\nprint(square(5))\n\n\nRun Code"
  },
  {
    "objectID": "course-info/how_to_quiz.html#question-1",
    "href": "course-info/how_to_quiz.html#question-1",
    "title": "Interactive Python Quiz",
    "section": "",
    "text": "Write a function square(n) that returns the square of a number.\n\n\n\n\n\n# Write your Python code here\ndef square(n):\n    return n * n\n\nprint(square(5))\n\n\nRun Code"
  },
  {
    "objectID": "course-info/schedule.html",
    "href": "course-info/schedule.html",
    "title": "Course Schedule",
    "section": "",
    "text": "The course will be updated weekly with the lecture schedule. Therefore, expect a new lecture every\nTuesday from April 8, 2025, at 13:15, Thoeretical Lecture Hall\nand a new assignment from 1:00 pm (starting the second week).\nExperience has shown that the best results are achieved when you are present in the lecture hall for the lectures. However, all material will also be available online, so you can access it at any time to learn whenever it suits you.",
    "crumbs": [
      "Course Info",
      "Schedule"
    ]
  },
  {
    "objectID": "course-info/schedule.html#lectures",
    "href": "course-info/schedule.html#lectures",
    "title": "Course Schedule",
    "section": "",
    "text": "The course will be updated weekly with the lecture schedule. Therefore, expect a new lecture every\nTuesday from April 8, 2025, at 13:15, Thoeretical Lecture Hall\nand a new assignment from 1:00 pm (starting the second week).\nExperience has shown that the best results are achieved when you are present in the lecture hall for the lectures. However, all material will also be available online, so you can access it at any time to learn whenever it suits you.",
    "crumbs": [
      "Course Info",
      "Schedule"
    ]
  },
  {
    "objectID": "course-info/schedule.html#seminars",
    "href": "course-info/schedule.html#seminars",
    "title": "Course Schedule",
    "section": "Seminars",
    "text": "Seminars\nSeminars will be held on Tuesday from April 15, 2025, at 15:00, , Thoeretical Lecture Hall\nIn the seminars, we will discuss the solutions to the exercises from the previous week and provide advanced insights and examples as well as discuss the topics covered in the lectures.\nThe topics covered in the seminars depend on YOU and your interests! We will tailor the content to your needs and preferences!",
    "crumbs": [
      "Course Info",
      "Schedule"
    ]
  },
  {
    "objectID": "course-info/course_info.html",
    "href": "course-info/course_info.html",
    "title": "Course Information",
    "section": "",
    "text": "Instructor\nEmail: lastname@physik.uni-leipzig.de\n\nProf. Dr. Frank Cichos\n\nLinnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +0341 97 32571"
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html",
    "href": "lectures/lecture02/02-lecture02.html",
    "title": "Python Overview",
    "section": "",
    "text": "Building on our understanding of Python’s basic data types and operations, we’ll now explore how to control program flow and create reusable code blocks. These structures allow us to write more sophisticated programs that can make decisions, repeat operations, and organize code efficiently.\n\n\nFunctions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n\nFor LoopWhile Loop\n\n\nA for loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here’s an example:\n\n\n\n\n\n\n\n\nA while loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are if, else, and elif.\n\nIf StatementElse StatementElif Statement\n\n\nAn if statement in Python is used to execute a block of code if a certain condition is met. Here’s an example:\n\n\n\n\n\n\n\n\nAn else statement in Python is used to execute a block of code if the condition in an if statement is not met. Here’s an example:\n\n\n\n\n\n\n\n\nAn elif statement in Python is used to execute a block of code if the condition in an if statement is not met but under an extra condition. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Control Structures & Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#control-structures-and-functions",
    "href": "lectures/lecture02/02-lecture02.html#control-structures-and-functions",
    "title": "Python Overview",
    "section": "",
    "text": "Building on our understanding of Python’s basic data types and operations, we’ll now explore how to control program flow and create reusable code blocks. These structures allow us to write more sophisticated programs that can make decisions, repeat operations, and organize code efficiently.\n\n\nFunctions are reusable blocks of code that can be executed multiple times from different parts of your program. They help in organizing code, making it more readable, and reducing redundancy. Functions can take input arguments and return output values.\n\nDefining a FunctionCalling a Function\n\n\nA function in Python is defined using the def keyword followed by the name of the function, which is usually descriptive and indicates what the function does. The parameters inside the parentheses indicate what data the function expects to receive. The -&gt; symbol is used to specify the return type of the function.\nHere’s an example:\n\n\n\n\n\n\n\n\nFunctions can be called by specifying the name of the function followed by parentheses containing the arguments. The arguments passed to the function should match the number and type of parameters defined in the function. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n\nLoops are used to execute a block of code repeatedly. There are two main types of loops in Python: for loops and while loops.\n\nFor LoopWhile Loop\n\n\nA for loop in Python is used to iterate over a sequence (such as a list or string) and execute a block of code for each item in the sequence. Here’s an example:\n\n\n\n\n\n\n\n\nA while loop in Python is used to execute a block of code while a certain condition is met. The loop continues as long as the condition is true. Here’s an example:\n\n\n\n\n\n\n\n\n\n\n\n\nConditional statements are used to control the flow of your program based on conditions. The main conditional statements in Python are if, else, and elif.\n\nIf StatementElse StatementElif Statement\n\n\nAn if statement in Python is used to execute a block of code if a certain condition is met. Here’s an example:\n\n\n\n\n\n\n\n\nAn else statement in Python is used to execute a block of code if the condition in an if statement is not met. Here’s an example:\n\n\n\n\n\n\n\n\nAn elif statement in Python is used to execute a block of code if the condition in an if statement is not met but under an extra condition. Here’s an example:",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Control Structures & Functions"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#exercises",
    "href": "lectures/lecture02/02-lecture02.html#exercises",
    "title": "Python Overview",
    "section": "Exercises",
    "text": "Exercises\nThe following exercises will help you practice using functions with conditional logic.\n\n\n\n\n\n\nExercise 1: Temperature Conversion Function\n\n\n\nCreate a function that converts temperatures between Fahrenheit and Celsius scales. This exercise demonstrates how to define and use functions with conditional logic to perform different types of conversions based on user input.\nThe conversion formulas are: - Celsius to Fahrenheit: \\(F = (C \\times 9/5) + 32\\) - Fahrenheit to Celsius: \\(C = (F - 32) \\times 5/9\\)\nTime estimate: 15-20 minutes\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nUse an if-else statement to check the scale parameter. Depending on whether it’s ‘C’ or ‘F’, apply the appropriate conversion formula. Remember to return both the converted temperature value and the new scale designation (either ‘F’ or ‘C’).\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2: Prime Number Checker\n\n\n\nCreate a function that checks whether a given number is prime. This exercise demonstrates the use of loops, conditional statements, and early return to solve a common mathematical problem.\nA prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers.\nTime estimate: 15-20 minutes\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nFirst, check if the number is less than 2 (not prime). Then, use a loop to check if the number is divisible by any integer from 2 to the square root of the number. If you find a divisor, the number is not prime. If no divisors are found, the number is prime.\n\n\n\n\n\n\n\n\n\n\n\nNote",
    "crumbs": [
      "Python Basics",
      "Lecture 2",
      "Control Structures & Functions"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-summary01.html",
    "href": "lectures/lecture01/02-summary01.html",
    "title": "Computer-Based Physical Modelling",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\nx = 1.0  # Assigns 1.0 to variable x\nmy_variable = \"Hello\"  # Assigns string \"Hello\"\n\n\n\nUse a-z, A-Z, 0-9, and _\nStart with letter or underscore\nCase-sensitive\nAvoid reserved keywords\n\n\n\n\n\n\n\n\nType\nExample\nDescription\n\n\n\n\nint\n5\nWhole numbers\n\n\nfloat\n3.14\nDecimal numbers\n\n\ncomplex\n2 + 3j\nReal + imaginary\n\n\nbool\nTrue\nLogical values\n\n\n\n\n\n\nint_num = int(3.14)    # 3\nfloat_num = float(5)   # 5.0\nstr_num = str(42)      # \"42\"\n\n\n\n\na, b = 10, 3\nsum_result = a + b   # Addition\ndiff_result = a - b  # Subtraction\nprod_result = a * b  # Multiplication\ndiv_result = a / b   # Division (float)\nint_div_result = a // b  # Integer division\nmod_result = a % b   # Modulus\npower_result = a ** b  # Exponentiation\n\n\n\nc = 2 + 4j\nreal_part = c.real     # 2.0\nimag_part = c.imag     # 4.0\nconjugate = c.conjugate()  # 2 - 4j\n\n\n\ntype(variable)  # Returns type\nisinstance(variable, type)  # Checks type\n\n\n\nimport math\n\nsqrt_result = math.sqrt(16)\nlog_result = math.log(100, 10)\nsin_result = math.sin(math.pi/2)"
  },
  {
    "objectID": "lectures/lecture01/02-summary01.html#python-basics-cheat-sheet",
    "href": "lectures/lecture01/02-summary01.html#python-basics-cheat-sheet",
    "title": "Computer-Based Physical Modelling",
    "section": "",
    "text": "Click to expand Python Basics Cheat Sheet\n\n\n\n\n\n\n\n\n\nx = 1.0  # Assigns 1.0 to variable x\nmy_variable = \"Hello\"  # Assigns string \"Hello\"\n\n\n\nUse a-z, A-Z, 0-9, and _\nStart with letter or underscore\nCase-sensitive\nAvoid reserved keywords\n\n\n\n\n\n\n\n\nType\nExample\nDescription\n\n\n\n\nint\n5\nWhole numbers\n\n\nfloat\n3.14\nDecimal numbers\n\n\ncomplex\n2 + 3j\nReal + imaginary\n\n\nbool\nTrue\nLogical values\n\n\n\n\n\n\nint_num = int(3.14)    # 3\nfloat_num = float(5)   # 5.0\nstr_num = str(42)      # \"42\"\n\n\n\n\na, b = 10, 3\nsum_result = a + b   # Addition\ndiff_result = a - b  # Subtraction\nprod_result = a * b  # Multiplication\ndiv_result = a / b   # Division (float)\nint_div_result = a // b  # Integer division\nmod_result = a % b   # Modulus\npower_result = a ** b  # Exponentiation\n\n\n\nc = 2 + 4j\nreal_part = c.real     # 2.0\nimag_part = c.imag     # 4.0\nconjugate = c.conjugate()  # 2 - 4j\n\n\n\ntype(variable)  # Returns type\nisinstance(variable, type)  # Checks type\n\n\n\nimport math\n\nsqrt_result = math.sqrt(16)\nlog_result = math.log(100, 10)\nsin_result = math.sin(math.pi/2)"
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html",
    "href": "lectures/lecture01/02-lecture01.html",
    "title": "Variables & Numbers",
    "section": "",
    "text": "Variable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nPython has keywords that cannot be used as variable names. The most common ones you’ll encounter in physics programming are:\nif, else, for, while, return, and, or, lambda\nNote that lambda is particularly relevant as it could naturally appear in physics code, but since it’s reserved for anonymous functions in Python, it cannot be used as a variable name.\n\n\n\n\n\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "href": "lectures/lecture01/02-lecture01.html#variables-in-python",
    "title": "Variables & Numbers",
    "section": "",
    "text": "Variable names in Python can include alphanumerical characters a-z, A-Z, 0-9, and the special character _. Normal variable names must start with a letter or an underscore. By convention, variable names typically start with a lower-case letter, while Class names start with a capital letter and internal variables start with an underscore.\n\n\n\n\n\n\nReserved Keywords\n\n\n\nPython has keywords that cannot be used as variable names. The most common ones you’ll encounter in physics programming are:\nif, else, for, while, return, and, or, lambda\nNote that lambda is particularly relevant as it could naturally appear in physics code, but since it’s reserved for anonymous functions in Python, it cannot be used as a variable name.\n\n\n\n\n\nThe assignment operator in Python is =. Python is a dynamically typed language, so we do not need to specify the type of a variable when we create one.\nAssigning a value to a new variable creates the variable:\n\n\n\n\n\n\nAlthough not explicitly specified, a variable does have a type associated with it (e.g., integer, float, string). The type is derived from the value that was assigned to it. To determine the type of a variable, we can use the type function.\n\n\n\n\n\n\nIf we assign a new value to a variable, its type can change.\n\n\n\n\n\n\n\n\n\n\n\n\nIf we try to use a variable that has not yet been defined, we get a NameError error.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#number-types",
    "href": "lectures/lecture01/02-lecture01.html#number-types",
    "title": "Variables & Numbers",
    "section": "Number Types",
    "text": "Number Types\nPython supports various number types, including integers, floating-point numbers, and complex numbers. These are some of the basic building blocks of doing arithmetic in any programming language. We will discuss each of these types in more detail.\n\nComparison of Number Types\n\n\n\n\n\n\n\n\n\n\n\nType\nExample\nDescription\nLimits\nUse Cases\n\n\n\n\nint\n42\nWhole numbers\nUnlimited precision (bounded by available memory)\nCounting, indexing\n\n\nfloat\n3.14159\nDecimal numbers\nTypically ±1.8e308 with 15-17 digits of precision (64-bit)\nScientific calculations, prices\n\n\ncomplex\n2 + 3j\nNumbers with real and imaginary parts\nSame as float for both real and imaginary parts\nSignal processing, electrical engineering\n\n\nbool\nTrue / False\nLogical values\nOnly two values: True (1) and False (0)\nConditional operations, flags\n\n\n\n\n\n\nExamples\n\nIntegersFloating Point NumbersComplex Numbers\n\n\nInteger Representation: Integers are whole numbers without a decimal point.\n\n\n\n\n\n\nBinary, Octal, and Hexadecimal: Integers can be represented in different bases:\n\n\n\n\n\n\n\n\nFloating Point Representation: Numbers with a decimal point are treated as floating-point values.\n\n\n\n\n\n\nMaximum Float Value: Python handles large floats, converting them to infinity if they exceed the maximum representable value.\n\n\n\n\n\n\n\n\nComplex Number Representation: Complex numbers have a real and an imaginary part.\n\n\n\n\n\n\n\nAccessors for Complex Numbers:\n\nc.real: Real part of the complex number.\nc.imag: Imaginary part of the complex number.\n\n\n\n\n\n\n\n\nComplex Conjugate: Use the .conjugate() method to get the complex conjugate.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/02-lecture01.html#operators",
    "href": "lectures/lecture01/02-lecture01.html#operators",
    "title": "Variables & Numbers",
    "section": "Operators",
    "text": "Operators\nPython provides a variety of operators for performing operations on variables and values. Here we’ll cover the most common operators used in scientific programming.\n\nArithmetic OperatorsComparison OperatorsLogical OperatorsAssignment Operators\n\n\nThese operators perform basic mathematical operations:\n\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n+\nAddition\n5 + 3\n8\n\n\n-\nSubtraction\n5 - 3\n2\n\n\n*\nMultiplication\n5 * 3\n15\n\n\n/\nDivision\n5 / 3\n1.6666…\n\n\n//\nFloor Division\n5 // 3\n1\n\n\n%\nModulus (remainder)\n5 % 3\n2\n\n\n**\nExponentiation\n5 ** 3\n125\n\n\n\n\n\n\n\n\n\n\n\nThese operators are used to compare values:\n\n\n\nOperator\nDescription\nExample\n\n\n\n\n==\nEqual to\nx == y\n\n\n!=\nNot equal to\nx != y\n\n\n&gt;\nGreater than\nx &gt; y\n\n\n&lt;\nLess than\nx &lt; y\n\n\n&gt;=\nGreater than or equal to\nx &gt;= y\n\n\n&lt;=\nLess than or equal to\nx &lt;= y\n\n\n\n\n\n\n\n\n\n\n\nUsed to combine conditional statements:\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\n\n\n\n\nand\nReturns True if both statements are true\nx &gt; 0 and x &lt; 10\n\n\nor\nReturns True if one of the statements is true\nx &lt; 0 or x &gt; 10\n\n\nnot\nReverses the result, returns False if the result is true\nnot(x &gt; 0 and x &lt; 10)\n\n\n\n\n\n\n\n\n\n\n\nPython provides shorthand operators for updating variables:\n\n\n\nOperator\nExample\nEquivalent to\n\n\n\n\n=\nx = 5\nx = 5\n\n\n+=\nx += 3\nx = x + 3\n\n\n-=\nx -= 3\nx = x - 3\n\n\n*=\nx *= 3\nx = x * 3\n\n\n/=\nx /= 3\nx = x / 3\n\n\n//=\nx //= 3\nx = x // 3\n\n\n%=\nx %= 3\nx = x % 3\n\n\n**=\nx **= 3\nx = x ** 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperator Precedence\n\n\n\n\n\nPython follows the standard mathematical order of operations (PEMDAS):\n\nParentheses\nExponentiation (**)\nMultiplication and Division (*, /, //, %)\nAddition and Subtraction (+, -)\n\nWhen operators have the same precedence, they are evaluated from left to right.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Variables & Numbers"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html",
    "href": "lectures/lecture01/01-lecture01.html",
    "title": "Jupyter Notebooks",
    "section": "",
    "text": "Throughout this course we will have to create and edit python code. We will primarily use this webpage for convenience, but for day-to-day work in the laboratory, it’s beneficial to utilize a code editor or a notebook environment like JupyterLab. JupyterLab is a robust platform that enables you to develop and modify notebooks within a web browser, while also offering comprehensive capabilities for analyzing and visualizing data.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#what-is-a-jupyter-notebook",
    "href": "lectures/lecture01/01-lecture01.html#what-is-a-jupyter-notebook",
    "title": "Jupyter Notebooks",
    "section": "What is a Jupyter Notebook?",
    "text": "What is a Jupyter Notebook?\nA Jupyter Notebook is a web browser based interactive computing environment that enables users to create documents that include code to be executed, results from the executed code such as plots and images,and finally also an additional documentation in form of markdown text including equations in LaTeX.\nThese documents provide a complete and self-contained record of a computation that can be converted to various formats and shared with others using email, version control systems (like git/GitHub) or nbviewer.jupyter.org.\n\nKey Components of a Notebook\nThe Jupyter Notebook ecosystem consists of three main components:\n\nNotebook Editor\nKernels\nNotebook Documents\n\nLet’s explore each of these components in detail:\n\nNotebook Editor\nThe Notebook editor is an interactive web-based application for creating and editing notebook documents. It enables users to write and run code, add rich text, and multimedia content. When running Jupyter on a server, users typically use either the classic Jupyter Notebook interface or JupyterLab, an advanced version with more features.\nKey features of the Notebook editor include:\n\nCode Editing: Write and edit code in individual cells.\nCode Execution: Run code cells in any order and display computation results in various formats (HTML, LaTeX, PNG, SVG, PDF).\nInteractive Widgets: Create and use JavaScript widgets that connect user interface controls to kernel-side computations.\nRich Text: Add documentation using Markdown markup language, including LaTeX equations.\n\n\n\n\n\n\n\nAdvance Notebook Editor Info\n\n\n\n\n\nThe Notebook editor in Jupyter offers several advanced features:\n\nCell Metadata: Each cell has associated metadata that can be used to control its behavior. This includes tags for slideshows, hiding code cells, and controlling cell execution.\nMagic Commands: Special commands prefixed with % (line magics) or %% (cell magics) that provide additional functionality, such as timing code execution or displaying plots inline.\nAuto-completion: The editor provides context-aware auto-completion for Python code, helping users write code more efficiently.\nCode Folding: Users can collapse long code blocks for better readability.\nMultiple Cursors: Advanced editing with multiple cursors for simultaneous editing at different locations.\nSplit View: The ability to split the notebook view, allowing users to work on different parts of the notebook simultaneously.\nVariable Inspector: A tool to inspect and manage variables in the kernel’s memory.\nIntegrated Debugger: Some Jupyter environments offer an integrated debugger for step-by-step code execution and inspection.\n\n\n\n\n\n\n\nKernels\nKernels are the computational engines that execute the code contained in a notebook. They are separate processes that run independently of the notebook editor.\nKey responsibilities of kernels include: * Executing user code * Returning computation results to the notebook editor * Handling computations for interactive widgets * Providing features like tab completion and introspection\n\n\n\n\n\n\nAdvanced Kernel Info\n\n\n\n\n\nJupyter notebooks are language-agnostic. Different kernels can be installed to support various programming languages such as Python, R, Julia, and many others. The default kernel runs Python code, but users can select different kernels for each notebook via the Kernel menu.\nKernels communicate with the notebook editor using a JSON-based protocol over ZeroMQ/WebSockets. For more technical details, see the messaging specification.\nEach kernel runs in its own environment, which can be customized to include specific libraries and dependencies. This allows users to create isolated environments for different projects, ensuring that dependencies do not conflict.\nKernels also support interactive features such as:\n\nTab Completion: Provides suggestions for variable names, functions, and methods as you type, improving coding efficiency.\nIntrospection: Allows users to inspect objects, view documentation, and understand the structure of code elements.\nRich Output: Supports various output formats, including text, images, videos, and interactive widgets, enhancing the interactivity of notebooks.\n\nAdvanced users can create custom kernels to support additional languages or specialized computing environments. This involves writing a kernel specification and implementing the necessary communication protocols.\nFor managing kernels, Jupyter provides several commands and options:\n\nStarting a Kernel: Automatically starts when a notebook is opened.\nInterrupting a Kernel: Stops the execution of the current code cell, useful for halting long-running computations.\nRestarting a Kernel: Clears the kernel’s memory and restarts it, useful for resetting the environment or recovering from errors.\nShutting Down a Kernel: Stops the kernel and frees up system resources.\n\nUsers can also monitor kernel activity and resource usage through the Jupyter interface, ensuring efficient and effective use of computational resources.\n\n\n\n\n\nJupyterLab Example\nThe following is an example of a JupyterLab interface with a notebook editor, code cells, markdown cells, and a kernel selector:\nFull Screen\n\n\n\n\n\nNotebook Documents\nNotebook documents are self-contained files that encapsulate all content created in the notebook editor. They include code inputs/outputs, Markdown text, equations, images, and other media. Each document is associated with a specific kernel and serves as both a human-readable record of analysis and an executable script to reproduce the work.\nCharacteristics of notebook documents:\n\nFile Extension: Notebooks are stored as files with a .ipynb extension.\nStructure: Notebooks consist of a linear sequence of cells, which can be one of three types:\n\nCode cells: Contain executable code and its output.\nMarkdown cells: Contain formatted text, including LaTeX equations.\nRaw cells: Contain unformatted text, preserved when converting notebooks to other formats.\n\n\n\n\n\n\n\n\nAdvanced Notebook Documents Info\n\n\n\n\n\n\nVersion Control: Notebook documents can be version controlled using systems like Git. This allows users to track changes, collaborate with others, and revert to previous versions if needed. Tools like nbdime provide diff and merge capabilities specifically designed for Jupyter Notebooks.\nCell Tags: Cells in a notebook can be tagged with metadata to control their behavior during execution, export, or presentation. For example, tags can be used to hide input or output, skip execution, or designate cells as slides in a presentation.\nInteractive Widgets: Notebook documents can include interactive widgets that allow users to manipulate parameters and visualize changes in real-time. This is particularly useful for data exploration and interactive simulations.\nExtensions: The Jupyter ecosystem supports a wide range of extensions that enhance the functionality of notebook documents. These extensions can add features like spell checking, code formatting, and integration with external tools and services.\nSecurity: Notebook documents can include code that executes on the user’s machine, which poses security risks. Jupyter provides mechanisms to sanitize notebooks and prevent the execution of untrusted code. Users should be cautious when opening notebooks from unknown sources.\nCollaboration: Jupyter Notebooks can be shared and collaboratively edited in real-time using platforms like Google Colab, Microsoft Azure Notebooks, and JupyterHub. These platforms provide cloud-based environments where multiple users can work on the same notebook simultaneously.\nCustomization: Users can customize the appearance and behavior of notebook documents using CSS and JavaScript. This allows for the creation of tailored interfaces and enhanced user experiences.\nExport Options: In addition to static formats, notebooks can be exported to interactive formats like dashboards and web applications. Tools like Voila convert notebooks into standalone web applications that can be shared and deployed.\nProvenance: Notebooks can include provenance information that tracks the origin and history of data and computations. This is important for reproducibility and transparency in scientific research.\nDocumentation: Notebook documents can serve as comprehensive documentation for projects, combining code, results, and narrative text. This makes them valuable for teaching, tutorials, and sharing research findings.\nPerformance: Large notebooks with many cells and outputs can become slow and unwieldy. Techniques like cell output clearing, using lightweight data formats, and splitting notebooks into smaller parts can help maintain performance.\nIntegration: Jupyter Notebooks can integrate with a wide range of data sources, libraries, and tools. This includes databases, cloud storage, machine learning frameworks, and visualization libraries, making them a versatile tool for data science and research.\nInternal Format: Notebook files are JSON text files with binary data encoded in base64, making them easy to manipulate programmatically.\nExportability: Notebooks can be exported to various static formats (HTML, reStructuredText, LaTeX, PDF, slide shows) using Jupyter’s nbconvert utility.\nSharing: Notebooks can be shared via nbviewer, which renders notebooks from public URLs or GitHub as static web pages, allowing others to view the content without installing Jupyter.\n\n\n\n\nThis integrated system of editor, kernels, and documents makes Jupyter Notebooks a powerful tool for interactive computing, data analysis, and sharing of computational narratives.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "href": "lectures/lecture01/01-lecture01.html#using-the-notebook-editor",
    "title": "Jupyter Notebooks",
    "section": "Using the Notebook Editor",
    "text": "Using the Notebook Editor\n\n\n\nJupyter Notebook Editor\n\n\nThe Jupyter Notebook editor provides an interactive environment for writing code, creating visualizations, and documenting computational workflows. It consists of a web-based interface that allows users to create and edit notebook documents containing code, text, equations, images, and interactive elements. A Jupyter Notebook provides an interface with essentially two modes of operation:\n\nedit mode the mode where you edit a cells content.\ncommand mode the mode where you execute the cells content.\n\nIn the more advanced version of JupyterLab you can also have a presentation mode where you can present your notebook as a slideshow.\n\nEdit mode\nEdit mode is indicated by a blue cell border and a prompt showing in the editor area when a cell is selected. You can enter edit mode by pressing Enter or using the mouse to click on a cell’s editor area.\n\n\n\nEdit Mode\n\n\nWhen a cell is in edit mode, you can type into the cell, like a normal text editor\n\n\nCommand mode\nCommand mode is indicated by a grey cell border with a blue left margin. When you are in command mode, you are able to edit the notebook as a whole, but not type into individual cells. Most importantly, in command mode, the keyboard is mapped to a set of shortcuts that let you perform notebook and cell actions efficiently.\n\n\n\nCommand Mode\n\n\nIf you have a hardware keyboard connected to your iOS device, you can use Jupyter keyboard shortcuts. The modal user interface of the Jupyter Notebook has been optimized for efficient keyboard usage. This is made possible by having two different sets of keyboard shortcuts: one set that is active in edit mode and another in command mode.\n\n\nKeyboard navigation\nIn edit mode, most of the keyboard is dedicated to typing into the cell’s editor area. Thus, in edit mode there are relatively few shortcuts available. In command mode, the entire keyboard is available for shortcuts, so there are many more. Most important ones are:\n\nSwitch command and edit mods: Enter for edit mode, and Esc or Control for command mode.\nBasic navigation: ↑/k, ↓/j\nRun or render currently selected cell: Shift+Enter or Control+Enter\nSaving the notebook: s\nChange Cell types: y to make it a code cell, m for markdown and r for raw\nInserting new cells: a to insert above, b to insert below\nManipulating cells using pasteboard: x for cut, c for copy, v for paste, d for delete and z for undo delete\nKernel operations: i to interrupt and 0 to restart\n\n\n\nRunning code\nCode cells allow you to enter and run code. Run a code cell by pressing the ▶︎ button in the bottom-right panel, or Control+Enter on your hardware keyboard.\n\nv = 23752636\nprint(v)\n\n23752636\n\n\nThere are a couple of keyboard shortcuts for running code:\n\nControl+Enter run the current cell and enters command mode.\nShift+Enter runs the current cell and moves selection to the one below.\nOption+Enter runs the current cell and inserts a new one below.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "href": "lectures/lecture01/01-lecture01.html#managing-the-kernel",
    "title": "Jupyter Notebooks",
    "section": "Managing the kernel",
    "text": "Managing the kernel\nCode is run in a separate process called the kernel, which can be interrupted or restarted. You can see kernel indicator in the top-right corner reporting current kernel state: ⚪︎ means kernel is ready to execute code, and ⚫︎ means kernel is currently busy. Tapping kernel indicator will open kernel menu, where you can reconnect, interrupt or restart kernel.\nTry running the following cell — kernel indicator will switch from ⚪︎ to ⚫︎, i.e. reporting kernel as “busy”. This means that you won’t be able to run any new cells until current execution finishes, or until kernel is interrupted. You can then go to kernel menu by tapping the kernel indicator and select “Interrupt”.",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "href": "lectures/lecture01/01-lecture01.html#markdown-in-notebooks",
    "title": "Jupyter Notebooks",
    "section": "Markdown in Notebooks",
    "text": "Markdown in Notebooks\nText can be added to Jupyter Notebooks using Markdown cells. This is extremely useful providing a complete documentation of your calculations or simulations. In this way, everything really becomes an notebook. You can change the cell type to Markdown by using the “Cell Actions” menu, or with a hardware keyboard shortcut m. Markdown is a popular markup language that is a superset of HTML. Its specification can be found here:\nhttps://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\nMarkdown cells can either be rendered or unrendered.\nWhen they are rendered, you will see a nice formatted representation of the cell’s contents.\nWhen they are unrendered, you will see the raw text source of the cell. To render the selected cell, click the ▶︎ button or shift+ enter. To unrender, select the markdown cell, and press enter or just double click.\n\nMarkdown basics\nBelow are some basic markdown examples, in its rendered form. If you which to access how to create specific appearances, double click the individual cells to put the into an unrendered edit mode.\nYou can make text italic or bold. You can build nested itemized or enumerated lists:\n\n\nMarkdown lists example\n\nFirst item\n\nFirst subitem\n\nFirst sub-subitem\n\nSecond subitem\n\nFirst subitem of second subitem\nSecond subitem of second subitem\n\n\nSecond item\n\nFirst subitem\n\nThird item\n\nFirst subitem\n\n\nNow another list:\n\nHere we go\n\nSublist\n\nSublist\n\n\nThere we go\nNow this\n\n\n\nBlockquote example\n\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Namespaces are one honking great idea – let’s do more of those!\n\n\n\nWeb links example\nJupyter’s website\n\n\nHeadings\nYou can add headings by starting a line with one (or multiple) # followed by a space and the title of your section. The number of # you use will determine the size of the heading\n# Heading 1\n# Heading 2\n## Heading 2.1\n## Heading 2.2\n### Heading 2.2.1\n\n\nEmbedded code\nYou can embed code meant for illustration instead of execution in Python:\ndef f(x):\n    \"\"\"a docstring\"\"\"\n    return x**2\n\n\nLaTeX equations\nCourtesy of MathJax, you can include mathematical expressions both inline: \\(e^{i\\pi} + 1 = 0\\) and displayed:\n\\[e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i\\]\nInline expressions can be added by surrounding the latex code with $:\n$e^{i\\pi} + 1 = 0$\nExpressions on their own line are surrounded by $$:\n$$e^x=\\sum_{i=0}^\\infty \\frac{1}{i!}x^i$$\n\n\nImages\nImages may be also directly integrated into a Markdown block.\nTo include images use\n![alternative text](url)\nfor example\n\n\n\nalternative text\n\n\n\n\nVideos\nTo include videos, we use HTML code like\n&lt;video src=\"mov/movie.mp4\" width=\"320\" height=\"200\" controls preload&gt;&lt;/video&gt;\nin the Markdown cell. This works with videos stored locally.\n\n\nYou can embed YouTube Videos as well by using the IPython module.\n\nfrom IPython.display import YouTubeVideo\nYouTubeVideo('QlLx32juGzI',width=600)",
    "crumbs": [
      "Python Basics",
      "Lecture 1",
      "Jupyter Notebooks"
    ]
  }
]